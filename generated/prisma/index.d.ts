
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model user_roles
 * 
 */
export type user_roles = $Result.DefaultSelection<Prisma.$user_rolesPayload>
/**
 * Model properties
 * 
 */
export type properties = $Result.DefaultSelection<Prisma.$propertiesPayload>
/**
 * Model parking_slots
 * 
 */
export type parking_slots = $Result.DefaultSelection<Prisma.$parking_slotsPayload>
/**
 * Model vehicles
 * 
 */
export type vehicles = $Result.DefaultSelection<Prisma.$vehiclesPayload>
/**
 * Model bookings
 * 
 */
export type bookings = $Result.DefaultSelection<Prisma.$bookingsPayload>
/**
 * Model booking_slots
 * 
 */
export type booking_slots = $Result.DefaultSelection<Prisma.$booking_slotsPayload>
/**
 * Model booking_status_history
 * 
 */
export type booking_status_history = $Result.DefaultSelection<Prisma.$booking_status_historyPayload>
/**
 * Model payment_summary
 * 
 */
export type payment_summary = $Result.DefaultSelection<Prisma.$payment_summaryPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model wash_jobs
 * 
 */
export type wash_jobs = $Result.DefaultSelection<Prisma.$wash_jobsPayload>
/**
 * Model counter_transactions
 * 
 */
export type counter_transactions = $Result.DefaultSelection<Prisma.$counter_transactionsPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RoleName: {
  ADMIN: 'ADMIN',
  CUSTOMER: 'CUSTOMER',
  LANDOWNER: 'LANDOWNER',
  WASHER: 'WASHER',
  COUNTER: 'COUNTER'
};

export type RoleName = (typeof RoleName)[keyof typeof RoleName]


export const PropertyStatus: {
  ACTIVATED: 'ACTIVATED',
  NOT_ACTIVATED: 'NOT_ACTIVATED'
};

export type PropertyStatus = (typeof PropertyStatus)[keyof typeof PropertyStatus]


export const SlotType: {
  NORMAL: 'NORMAL',
  EV: 'EV',
  CAR_WASH: 'CAR_WASH'
};

export type SlotType = (typeof SlotType)[keyof typeof SlotType]


export const BookingStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PaymentMethod: {
  CARD: 'CARD',
  CASH: 'CASH'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  UNPAID: 'UNPAID',
  PAID: 'PAID',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const GatewayStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type GatewayStatus = (typeof GatewayStatus)[keyof typeof GatewayStatus]


export const WashStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  COMPLETED: 'COMPLETED'
};

export type WashStatus = (typeof WashStatus)[keyof typeof WashStatus]

}

export type RoleName = $Enums.RoleName

export const RoleName: typeof $Enums.RoleName

export type PropertyStatus = $Enums.PropertyStatus

export const PropertyStatus: typeof $Enums.PropertyStatus

export type SlotType = $Enums.SlotType

export const SlotType: typeof $Enums.SlotType

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type GatewayStatus = $Enums.GatewayStatus

export const GatewayStatus: typeof $Enums.GatewayStatus

export type WashStatus = $Enums.WashStatus

export const WashStatus: typeof $Enums.WashStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs>;

  /**
   * `prisma.user_roles`: Exposes CRUD operations for the **user_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_roles
    * const user_roles = await prisma.user_roles.findMany()
    * ```
    */
  get user_roles(): Prisma.user_rolesDelegate<ExtArgs>;

  /**
   * `prisma.properties`: Exposes CRUD operations for the **properties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.properties.findMany()
    * ```
    */
  get properties(): Prisma.propertiesDelegate<ExtArgs>;

  /**
   * `prisma.parking_slots`: Exposes CRUD operations for the **parking_slots** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parking_slots
    * const parking_slots = await prisma.parking_slots.findMany()
    * ```
    */
  get parking_slots(): Prisma.parking_slotsDelegate<ExtArgs>;

  /**
   * `prisma.vehicles`: Exposes CRUD operations for the **vehicles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicles.findMany()
    * ```
    */
  get vehicles(): Prisma.vehiclesDelegate<ExtArgs>;

  /**
   * `prisma.bookings`: Exposes CRUD operations for the **bookings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.bookings.findMany()
    * ```
    */
  get bookings(): Prisma.bookingsDelegate<ExtArgs>;

  /**
   * `prisma.booking_slots`: Exposes CRUD operations for the **booking_slots** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Booking_slots
    * const booking_slots = await prisma.booking_slots.findMany()
    * ```
    */
  get booking_slots(): Prisma.booking_slotsDelegate<ExtArgs>;

  /**
   * `prisma.booking_status_history`: Exposes CRUD operations for the **booking_status_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Booking_status_histories
    * const booking_status_histories = await prisma.booking_status_history.findMany()
    * ```
    */
  get booking_status_history(): Prisma.booking_status_historyDelegate<ExtArgs>;

  /**
   * `prisma.payment_summary`: Exposes CRUD operations for the **payment_summary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_summaries
    * const payment_summaries = await prisma.payment_summary.findMany()
    * ```
    */
  get payment_summary(): Prisma.payment_summaryDelegate<ExtArgs>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs>;

  /**
   * `prisma.wash_jobs`: Exposes CRUD operations for the **wash_jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wash_jobs
    * const wash_jobs = await prisma.wash_jobs.findMany()
    * ```
    */
  get wash_jobs(): Prisma.wash_jobsDelegate<ExtArgs>;

  /**
   * `prisma.counter_transactions`: Exposes CRUD operations for the **counter_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counter_transactions
    * const counter_transactions = await prisma.counter_transactions.findMany()
    * ```
    */
  get counter_transactions(): Prisma.counter_transactionsDelegate<ExtArgs>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    roles: 'roles',
    user_roles: 'user_roles',
    properties: 'properties',
    parking_slots: 'parking_slots',
    vehicles: 'vehicles',
    bookings: 'bookings',
    booking_slots: 'booking_slots',
    booking_status_history: 'booking_status_history',
    payment_summary: 'payment_summary',
    payments: 'payments',
    wash_jobs: 'wash_jobs',
    counter_transactions: 'counter_transactions',
    notifications: 'notifications'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "users" | "roles" | "user_roles" | "properties" | "parking_slots" | "vehicles" | "bookings" | "booking_slots" | "booking_status_history" | "payment_summary" | "payments" | "wash_jobs" | "counter_transactions" | "notifications"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      user_roles: {
        payload: Prisma.$user_rolesPayload<ExtArgs>
        fields: Prisma.user_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          findFirst: {
            args: Prisma.user_rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          findMany: {
            args: Prisma.user_rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          create: {
            args: Prisma.user_rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          createMany: {
            args: Prisma.user_rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          delete: {
            args: Prisma.user_rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          update: {
            args: Prisma.user_rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          deleteMany: {
            args: Prisma.user_rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          aggregate: {
            args: Prisma.User_rolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_roles>
          }
          groupBy: {
            args: Prisma.user_rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_rolesCountArgs<ExtArgs>
            result: $Utils.Optional<User_rolesCountAggregateOutputType> | number
          }
        }
      }
      properties: {
        payload: Prisma.$propertiesPayload<ExtArgs>
        fields: Prisma.propertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.propertiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.propertiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>
          }
          findFirst: {
            args: Prisma.propertiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.propertiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>
          }
          findMany: {
            args: Prisma.propertiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>[]
          }
          create: {
            args: Prisma.propertiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>
          }
          createMany: {
            args: Prisma.propertiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.propertiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>[]
          }
          delete: {
            args: Prisma.propertiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>
          }
          update: {
            args: Prisma.propertiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>
          }
          deleteMany: {
            args: Prisma.propertiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.propertiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.propertiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>
          }
          aggregate: {
            args: Prisma.PropertiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperties>
          }
          groupBy: {
            args: Prisma.propertiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.propertiesCountArgs<ExtArgs>
            result: $Utils.Optional<PropertiesCountAggregateOutputType> | number
          }
        }
      }
      parking_slots: {
        payload: Prisma.$parking_slotsPayload<ExtArgs>
        fields: Prisma.parking_slotsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.parking_slotsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parking_slotsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.parking_slotsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parking_slotsPayload>
          }
          findFirst: {
            args: Prisma.parking_slotsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parking_slotsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.parking_slotsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parking_slotsPayload>
          }
          findMany: {
            args: Prisma.parking_slotsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parking_slotsPayload>[]
          }
          create: {
            args: Prisma.parking_slotsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parking_slotsPayload>
          }
          createMany: {
            args: Prisma.parking_slotsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.parking_slotsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parking_slotsPayload>[]
          }
          delete: {
            args: Prisma.parking_slotsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parking_slotsPayload>
          }
          update: {
            args: Prisma.parking_slotsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parking_slotsPayload>
          }
          deleteMany: {
            args: Prisma.parking_slotsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.parking_slotsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.parking_slotsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parking_slotsPayload>
          }
          aggregate: {
            args: Prisma.Parking_slotsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParking_slots>
          }
          groupBy: {
            args: Prisma.parking_slotsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Parking_slotsGroupByOutputType>[]
          }
          count: {
            args: Prisma.parking_slotsCountArgs<ExtArgs>
            result: $Utils.Optional<Parking_slotsCountAggregateOutputType> | number
          }
        }
      }
      vehicles: {
        payload: Prisma.$vehiclesPayload<ExtArgs>
        fields: Prisma.vehiclesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehiclesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehiclesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          findFirst: {
            args: Prisma.vehiclesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehiclesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          findMany: {
            args: Prisma.vehiclesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
          }
          create: {
            args: Prisma.vehiclesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          createMany: {
            args: Prisma.vehiclesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.vehiclesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
          }
          delete: {
            args: Prisma.vehiclesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          update: {
            args: Prisma.vehiclesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          deleteMany: {
            args: Prisma.vehiclesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehiclesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehiclesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          aggregate: {
            args: Prisma.VehiclesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicles>
          }
          groupBy: {
            args: Prisma.vehiclesGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehiclesGroupByOutputType>[]
          }
          count: {
            args: Prisma.vehiclesCountArgs<ExtArgs>
            result: $Utils.Optional<VehiclesCountAggregateOutputType> | number
          }
        }
      }
      bookings: {
        payload: Prisma.$bookingsPayload<ExtArgs>
        fields: Prisma.bookingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bookingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bookingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          findFirst: {
            args: Prisma.bookingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bookingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          findMany: {
            args: Prisma.bookingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>[]
          }
          create: {
            args: Prisma.bookingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          createMany: {
            args: Prisma.bookingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bookingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>[]
          }
          delete: {
            args: Prisma.bookingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          update: {
            args: Prisma.bookingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          deleteMany: {
            args: Prisma.bookingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bookingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bookingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          aggregate: {
            args: Prisma.BookingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookings>
          }
          groupBy: {
            args: Prisma.bookingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bookingsCountArgs<ExtArgs>
            result: $Utils.Optional<BookingsCountAggregateOutputType> | number
          }
        }
      }
      booking_slots: {
        payload: Prisma.$booking_slotsPayload<ExtArgs>
        fields: Prisma.booking_slotsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.booking_slotsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_slotsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.booking_slotsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_slotsPayload>
          }
          findFirst: {
            args: Prisma.booking_slotsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_slotsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.booking_slotsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_slotsPayload>
          }
          findMany: {
            args: Prisma.booking_slotsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_slotsPayload>[]
          }
          create: {
            args: Prisma.booking_slotsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_slotsPayload>
          }
          createMany: {
            args: Prisma.booking_slotsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.booking_slotsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_slotsPayload>[]
          }
          delete: {
            args: Prisma.booking_slotsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_slotsPayload>
          }
          update: {
            args: Prisma.booking_slotsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_slotsPayload>
          }
          deleteMany: {
            args: Prisma.booking_slotsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.booking_slotsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.booking_slotsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_slotsPayload>
          }
          aggregate: {
            args: Prisma.Booking_slotsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking_slots>
          }
          groupBy: {
            args: Prisma.booking_slotsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Booking_slotsGroupByOutputType>[]
          }
          count: {
            args: Prisma.booking_slotsCountArgs<ExtArgs>
            result: $Utils.Optional<Booking_slotsCountAggregateOutputType> | number
          }
        }
      }
      booking_status_history: {
        payload: Prisma.$booking_status_historyPayload<ExtArgs>
        fields: Prisma.booking_status_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.booking_status_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_status_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.booking_status_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_status_historyPayload>
          }
          findFirst: {
            args: Prisma.booking_status_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_status_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.booking_status_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_status_historyPayload>
          }
          findMany: {
            args: Prisma.booking_status_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_status_historyPayload>[]
          }
          create: {
            args: Prisma.booking_status_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_status_historyPayload>
          }
          createMany: {
            args: Prisma.booking_status_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.booking_status_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_status_historyPayload>[]
          }
          delete: {
            args: Prisma.booking_status_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_status_historyPayload>
          }
          update: {
            args: Prisma.booking_status_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_status_historyPayload>
          }
          deleteMany: {
            args: Prisma.booking_status_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.booking_status_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.booking_status_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$booking_status_historyPayload>
          }
          aggregate: {
            args: Prisma.Booking_status_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking_status_history>
          }
          groupBy: {
            args: Prisma.booking_status_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Booking_status_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.booking_status_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Booking_status_historyCountAggregateOutputType> | number
          }
        }
      }
      payment_summary: {
        payload: Prisma.$payment_summaryPayload<ExtArgs>
        fields: Prisma.payment_summaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_summaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_summaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_summaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_summaryPayload>
          }
          findFirst: {
            args: Prisma.payment_summaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_summaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_summaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_summaryPayload>
          }
          findMany: {
            args: Prisma.payment_summaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_summaryPayload>[]
          }
          create: {
            args: Prisma.payment_summaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_summaryPayload>
          }
          createMany: {
            args: Prisma.payment_summaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_summaryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_summaryPayload>[]
          }
          delete: {
            args: Prisma.payment_summaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_summaryPayload>
          }
          update: {
            args: Prisma.payment_summaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_summaryPayload>
          }
          deleteMany: {
            args: Prisma.payment_summaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_summaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.payment_summaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_summaryPayload>
          }
          aggregate: {
            args: Prisma.Payment_summaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_summary>
          }
          groupBy: {
            args: Prisma.payment_summaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_summaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_summaryCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_summaryCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      wash_jobs: {
        payload: Prisma.$wash_jobsPayload<ExtArgs>
        fields: Prisma.wash_jobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wash_jobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wash_jobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wash_jobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wash_jobsPayload>
          }
          findFirst: {
            args: Prisma.wash_jobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wash_jobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wash_jobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wash_jobsPayload>
          }
          findMany: {
            args: Prisma.wash_jobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wash_jobsPayload>[]
          }
          create: {
            args: Prisma.wash_jobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wash_jobsPayload>
          }
          createMany: {
            args: Prisma.wash_jobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.wash_jobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wash_jobsPayload>[]
          }
          delete: {
            args: Prisma.wash_jobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wash_jobsPayload>
          }
          update: {
            args: Prisma.wash_jobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wash_jobsPayload>
          }
          deleteMany: {
            args: Prisma.wash_jobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wash_jobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.wash_jobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wash_jobsPayload>
          }
          aggregate: {
            args: Prisma.Wash_jobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWash_jobs>
          }
          groupBy: {
            args: Prisma.wash_jobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Wash_jobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.wash_jobsCountArgs<ExtArgs>
            result: $Utils.Optional<Wash_jobsCountAggregateOutputType> | number
          }
        }
      }
      counter_transactions: {
        payload: Prisma.$counter_transactionsPayload<ExtArgs>
        fields: Prisma.counter_transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.counter_transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counter_transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.counter_transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counter_transactionsPayload>
          }
          findFirst: {
            args: Prisma.counter_transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counter_transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.counter_transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counter_transactionsPayload>
          }
          findMany: {
            args: Prisma.counter_transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counter_transactionsPayload>[]
          }
          create: {
            args: Prisma.counter_transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counter_transactionsPayload>
          }
          createMany: {
            args: Prisma.counter_transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.counter_transactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counter_transactionsPayload>[]
          }
          delete: {
            args: Prisma.counter_transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counter_transactionsPayload>
          }
          update: {
            args: Prisma.counter_transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counter_transactionsPayload>
          }
          deleteMany: {
            args: Prisma.counter_transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.counter_transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.counter_transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counter_transactionsPayload>
          }
          aggregate: {
            args: Prisma.Counter_transactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCounter_transactions>
          }
          groupBy: {
            args: Prisma.counter_transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Counter_transactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.counter_transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<Counter_transactionsCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    customerBookings: number
    createdBookings: number
    bookingStatusEvents: number
    counterTransactions: number
    notifications: number
    ownedProperties: number
    createdPayments: number
    payments: number
    roles: number
    vehicles: number
    washJobs: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerBookings?: boolean | UsersCountOutputTypeCountCustomerBookingsArgs
    createdBookings?: boolean | UsersCountOutputTypeCountCreatedBookingsArgs
    bookingStatusEvents?: boolean | UsersCountOutputTypeCountBookingStatusEventsArgs
    counterTransactions?: boolean | UsersCountOutputTypeCountCounterTransactionsArgs
    notifications?: boolean | UsersCountOutputTypeCountNotificationsArgs
    ownedProperties?: boolean | UsersCountOutputTypeCountOwnedPropertiesArgs
    createdPayments?: boolean | UsersCountOutputTypeCountCreatedPaymentsArgs
    payments?: boolean | UsersCountOutputTypeCountPaymentsArgs
    roles?: boolean | UsersCountOutputTypeCountRolesArgs
    vehicles?: boolean | UsersCountOutputTypeCountVehiclesArgs
    washJobs?: boolean | UsersCountOutputTypeCountWashJobsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCustomerBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCreatedBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBookingStatusEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booking_status_historyWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCounterTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: counter_transactionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOwnedPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: propertiesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCreatedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehiclesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountWashJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wash_jobsWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    users: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RolesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
  }


  /**
   * Count Type PropertiesCountOutputType
   */

  export type PropertiesCountOutputType = {
    bookings: number
    parkingSlots: number
  }

  export type PropertiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | PropertiesCountOutputTypeCountBookingsArgs
    parkingSlots?: boolean | PropertiesCountOutputTypeCountParkingSlotsArgs
  }

  // Custom InputTypes
  /**
   * PropertiesCountOutputType without action
   */
  export type PropertiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertiesCountOutputType
     */
    select?: PropertiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertiesCountOutputType without action
   */
  export type PropertiesCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
  }

  /**
   * PropertiesCountOutputType without action
   */
  export type PropertiesCountOutputTypeCountParkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parking_slotsWhereInput
  }


  /**
   * Count Type Parking_slotsCountOutputType
   */

  export type Parking_slotsCountOutputType = {
    bookingSlots: number
  }

  export type Parking_slotsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingSlots?: boolean | Parking_slotsCountOutputTypeCountBookingSlotsArgs
  }

  // Custom InputTypes
  /**
   * Parking_slotsCountOutputType without action
   */
  export type Parking_slotsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parking_slotsCountOutputType
     */
    select?: Parking_slotsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Parking_slotsCountOutputType without action
   */
  export type Parking_slotsCountOutputTypeCountBookingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booking_slotsWhereInput
  }


  /**
   * Count Type VehiclesCountOutputType
   */

  export type VehiclesCountOutputType = {
    bookings: number
  }

  export type VehiclesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | VehiclesCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * VehiclesCountOutputType without action
   */
  export type VehiclesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehiclesCountOutputType
     */
    select?: VehiclesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehiclesCountOutputType without action
   */
  export type VehiclesCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
  }


  /**
   * Count Type BookingsCountOutputType
   */

  export type BookingsCountOutputType = {
    bookingSlots: number
    counterLogs: number
    payments: number
    statusHistory: number
  }

  export type BookingsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingSlots?: boolean | BookingsCountOutputTypeCountBookingSlotsArgs
    counterLogs?: boolean | BookingsCountOutputTypeCountCounterLogsArgs
    payments?: boolean | BookingsCountOutputTypeCountPaymentsArgs
    statusHistory?: boolean | BookingsCountOutputTypeCountStatusHistoryArgs
  }

  // Custom InputTypes
  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingsCountOutputType
     */
    select?: BookingsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeCountBookingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booking_slotsWhereInput
  }

  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeCountCounterLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: counter_transactionsWhereInput
  }

  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeCountStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booking_status_historyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    email: string | null
    phone: string | null
    nic: string | null
    residentialAddress: string | null
    passwordHash: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    email: string | null
    phone: string | null
    nic: string | null
    residentialAddress: string | null
    passwordHash: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    fullName: number
    email: number
    phone: number
    nic: number
    residentialAddress: number
    passwordHash: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    phone?: true
    nic?: true
    residentialAddress?: true
    passwordHash?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    phone?: true
    nic?: true
    residentialAddress?: true
    passwordHash?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    phone?: true
    nic?: true
    residentialAddress?: true
    passwordHash?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    fullName: string
    email: string
    phone: string | null
    nic: string | null
    residentialAddress: string | null
    passwordHash: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    nic?: boolean
    residentialAddress?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerBookings?: boolean | users$customerBookingsArgs<ExtArgs>
    createdBookings?: boolean | users$createdBookingsArgs<ExtArgs>
    bookingStatusEvents?: boolean | users$bookingStatusEventsArgs<ExtArgs>
    counterTransactions?: boolean | users$counterTransactionsArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    ownedProperties?: boolean | users$ownedPropertiesArgs<ExtArgs>
    createdPayments?: boolean | users$createdPaymentsArgs<ExtArgs>
    payments?: boolean | users$paymentsArgs<ExtArgs>
    roles?: boolean | users$rolesArgs<ExtArgs>
    vehicles?: boolean | users$vehiclesArgs<ExtArgs>
    washJobs?: boolean | users$washJobsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    nic?: boolean
    residentialAddress?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    nic?: boolean
    residentialAddress?: boolean
    passwordHash?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerBookings?: boolean | users$customerBookingsArgs<ExtArgs>
    createdBookings?: boolean | users$createdBookingsArgs<ExtArgs>
    bookingStatusEvents?: boolean | users$bookingStatusEventsArgs<ExtArgs>
    counterTransactions?: boolean | users$counterTransactionsArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    ownedProperties?: boolean | users$ownedPropertiesArgs<ExtArgs>
    createdPayments?: boolean | users$createdPaymentsArgs<ExtArgs>
    payments?: boolean | users$paymentsArgs<ExtArgs>
    roles?: boolean | users$rolesArgs<ExtArgs>
    vehicles?: boolean | users$vehiclesArgs<ExtArgs>
    washJobs?: boolean | users$washJobsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      customerBookings: Prisma.$bookingsPayload<ExtArgs>[]
      createdBookings: Prisma.$bookingsPayload<ExtArgs>[]
      bookingStatusEvents: Prisma.$booking_status_historyPayload<ExtArgs>[]
      counterTransactions: Prisma.$counter_transactionsPayload<ExtArgs>[]
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      ownedProperties: Prisma.$propertiesPayload<ExtArgs>[]
      createdPayments: Prisma.$paymentsPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      roles: Prisma.$user_rolesPayload<ExtArgs>[]
      vehicles: Prisma.$vehiclesPayload<ExtArgs>[]
      washJobs: Prisma.$wash_jobsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fullName: string
      email: string
      phone: string | null
      nic: string | null
      residentialAddress: string | null
      passwordHash: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerBookings<T extends users$customerBookingsArgs<ExtArgs> = {}>(args?: Subset<T, users$customerBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany"> | Null>
    createdBookings<T extends users$createdBookingsArgs<ExtArgs> = {}>(args?: Subset<T, users$createdBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany"> | Null>
    bookingStatusEvents<T extends users$bookingStatusEventsArgs<ExtArgs> = {}>(args?: Subset<T, users$bookingStatusEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_status_historyPayload<ExtArgs>, T, "findMany"> | Null>
    counterTransactions<T extends users$counterTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, users$counterTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$counter_transactionsPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends users$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany"> | Null>
    ownedProperties<T extends users$ownedPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, users$ownedPropertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findMany"> | Null>
    createdPayments<T extends users$createdPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, users$createdPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends users$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, users$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany"> | Null>
    roles<T extends users$rolesArgs<ExtArgs> = {}>(args?: Subset<T, users$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany"> | Null>
    vehicles<T extends users$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, users$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findMany"> | Null>
    washJobs<T extends users$washJobsArgs<ExtArgs> = {}>(args?: Subset<T, users$washJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wash_jobsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly fullName: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly nic: FieldRef<"users", 'String'>
    readonly residentialAddress: FieldRef<"users", 'String'>
    readonly passwordHash: FieldRef<"users", 'String'>
    readonly isActive: FieldRef<"users", 'Boolean'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.customerBookings
   */
  export type users$customerBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    cursor?: bookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * users.createdBookings
   */
  export type users$createdBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    cursor?: bookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * users.bookingStatusEvents
   */
  export type users$bookingStatusEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyInclude<ExtArgs> | null
    where?: booking_status_historyWhereInput
    orderBy?: booking_status_historyOrderByWithRelationInput | booking_status_historyOrderByWithRelationInput[]
    cursor?: booking_status_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Booking_status_historyScalarFieldEnum | Booking_status_historyScalarFieldEnum[]
  }

  /**
   * users.counterTransactions
   */
  export type users$counterTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsInclude<ExtArgs> | null
    where?: counter_transactionsWhereInput
    orderBy?: counter_transactionsOrderByWithRelationInput | counter_transactionsOrderByWithRelationInput[]
    cursor?: counter_transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Counter_transactionsScalarFieldEnum | Counter_transactionsScalarFieldEnum[]
  }

  /**
   * users.notifications
   */
  export type users$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * users.ownedProperties
   */
  export type users$ownedPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: propertiesInclude<ExtArgs> | null
    where?: propertiesWhereInput
    orderBy?: propertiesOrderByWithRelationInput | propertiesOrderByWithRelationInput[]
    cursor?: propertiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertiesScalarFieldEnum | PropertiesScalarFieldEnum[]
  }

  /**
   * users.createdPayments
   */
  export type users$createdPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * users.payments
   */
  export type users$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * users.roles
   */
  export type users$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    cursor?: user_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * users.vehicles
   */
  export type users$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    where?: vehiclesWhereInput
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    cursor?: vehiclesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * users.washJobs
   */
  export type users$washJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsInclude<ExtArgs> | null
    where?: wash_jobsWhereInput
    orderBy?: wash_jobsOrderByWithRelationInput | wash_jobsOrderByWithRelationInput[]
    cursor?: wash_jobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Wash_jobsScalarFieldEnum | Wash_jobsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: $Enums.RoleName | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: $Enums.RoleName | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    name: $Enums.RoleName
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | roles$usersArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | roles$usersArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      users: Prisma.$user_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: $Enums.RoleName
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {rolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends roles$usersArgs<ExtArgs> = {}>(args?: Subset<T, roles$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */ 
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'Int'>
    readonly name: FieldRef<"roles", 'RoleName'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles createManyAndReturn
   */
  export type rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
  }

  /**
   * roles.users
   */
  export type roles$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    cursor?: user_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model user_roles
   */

  export type AggregateUser_roles = {
    _count: User_rolesCountAggregateOutputType | null
    _avg: User_rolesAvgAggregateOutputType | null
    _sum: User_rolesSumAggregateOutputType | null
    _min: User_rolesMinAggregateOutputType | null
    _max: User_rolesMaxAggregateOutputType | null
  }

  export type User_rolesAvgAggregateOutputType = {
    roleId: number | null
  }

  export type User_rolesSumAggregateOutputType = {
    roleId: number | null
  }

  export type User_rolesMinAggregateOutputType = {
    userId: string | null
    roleId: number | null
  }

  export type User_rolesMaxAggregateOutputType = {
    userId: string | null
    roleId: number | null
  }

  export type User_rolesCountAggregateOutputType = {
    userId: number
    roleId: number
    _all: number
  }


  export type User_rolesAvgAggregateInputType = {
    roleId?: true
  }

  export type User_rolesSumAggregateInputType = {
    roleId?: true
  }

  export type User_rolesMinAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type User_rolesMaxAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type User_rolesCountAggregateInputType = {
    userId?: true
    roleId?: true
    _all?: true
  }

  export type User_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to aggregate.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_roles
    **/
    _count?: true | User_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_rolesMaxAggregateInputType
  }

  export type GetUser_rolesAggregateType<T extends User_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_roles[P]>
      : GetScalarType<T[P], AggregateUser_roles[P]>
  }




  export type user_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithAggregationInput | user_rolesOrderByWithAggregationInput[]
    by: User_rolesScalarFieldEnum[] | User_rolesScalarFieldEnum
    having?: user_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_rolesCountAggregateInputType | true
    _avg?: User_rolesAvgAggregateInputType
    _sum?: User_rolesSumAggregateInputType
    _min?: User_rolesMinAggregateInputType
    _max?: User_rolesMaxAggregateInputType
  }

  export type User_rolesGroupByOutputType = {
    userId: string
    roleId: number
    _count: User_rolesCountAggregateOutputType | null
    _avg: User_rolesAvgAggregateOutputType | null
    _sum: User_rolesSumAggregateOutputType | null
    _min: User_rolesMinAggregateOutputType | null
    _max: User_rolesMaxAggregateOutputType | null
  }

  type GetUser_rolesGroupByPayload<T extends user_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], User_rolesGroupByOutputType[P]>
        }
      >
    >


  export type user_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    role?: boolean | rolesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>

  export type user_rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    role?: boolean | rolesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>

  export type user_rolesSelectScalar = {
    userId?: boolean
    roleId?: boolean
  }

  export type user_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | rolesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | rolesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_roles"
    objects: {
      role: Prisma.$rolesPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      roleId: number
    }, ExtArgs["result"]["user_roles"]>
    composites: {}
  }

  type user_rolesGetPayload<S extends boolean | null | undefined | user_rolesDefaultArgs> = $Result.GetResult<Prisma.$user_rolesPayload, S>

  type user_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_rolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_rolesCountAggregateInputType | true
    }

  export interface user_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_roles'], meta: { name: 'user_roles' } }
    /**
     * Find zero or one User_roles that matches the filter.
     * @param {user_rolesFindUniqueArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_rolesFindUniqueArgs>(args: SelectSubset<T, user_rolesFindUniqueArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_rolesFindUniqueOrThrowArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindFirstArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_rolesFindFirstArgs>(args?: SelectSubset<T, user_rolesFindFirstArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindFirstOrThrowArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_roles
     * const user_roles = await prisma.user_roles.findMany()
     * 
     * // Get first 10 User_roles
     * const user_roles = await prisma.user_roles.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const user_rolesWithUserIdOnly = await prisma.user_roles.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends user_rolesFindManyArgs>(args?: SelectSubset<T, user_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_roles.
     * @param {user_rolesCreateArgs} args - Arguments to create a User_roles.
     * @example
     * // Create one User_roles
     * const User_roles = await prisma.user_roles.create({
     *   data: {
     *     // ... data to create a User_roles
     *   }
     * })
     * 
     */
    create<T extends user_rolesCreateArgs>(args: SelectSubset<T, user_rolesCreateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_roles.
     * @param {user_rolesCreateManyArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_roles = await prisma.user_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_rolesCreateManyArgs>(args?: SelectSubset<T, user_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_roles and returns the data saved in the database.
     * @param {user_rolesCreateManyAndReturnArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_roles = await prisma.user_roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_roles and only return the `userId`
     * const user_rolesWithUserIdOnly = await prisma.user_roles.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, user_rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_roles.
     * @param {user_rolesDeleteArgs} args - Arguments to delete one User_roles.
     * @example
     * // Delete one User_roles
     * const User_roles = await prisma.user_roles.delete({
     *   where: {
     *     // ... filter to delete one User_roles
     *   }
     * })
     * 
     */
    delete<T extends user_rolesDeleteArgs>(args: SelectSubset<T, user_rolesDeleteArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_roles.
     * @param {user_rolesUpdateArgs} args - Arguments to update one User_roles.
     * @example
     * // Update one User_roles
     * const user_roles = await prisma.user_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_rolesUpdateArgs>(args: SelectSubset<T, user_rolesUpdateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_roles.
     * @param {user_rolesDeleteManyArgs} args - Arguments to filter User_roles to delete.
     * @example
     * // Delete a few User_roles
     * const { count } = await prisma.user_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_rolesDeleteManyArgs>(args?: SelectSubset<T, user_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_roles
     * const user_roles = await prisma.user_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_rolesUpdateManyArgs>(args: SelectSubset<T, user_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_roles.
     * @param {user_rolesUpsertArgs} args - Arguments to update or create a User_roles.
     * @example
     * // Update or create a User_roles
     * const user_roles = await prisma.user_roles.upsert({
     *   create: {
     *     // ... data to create a User_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_roles we want to update
     *   }
     * })
     */
    upsert<T extends user_rolesUpsertArgs>(args: SelectSubset<T, user_rolesUpsertArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesCountArgs} args - Arguments to filter User_roles to count.
     * @example
     * // Count the number of User_roles
     * const count = await prisma.user_roles.count({
     *   where: {
     *     // ... the filter for the User_roles we want to count
     *   }
     * })
    **/
    count<T extends user_rolesCountArgs>(
      args?: Subset<T, user_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_rolesAggregateArgs>(args: Subset<T, User_rolesAggregateArgs>): Prisma.PrismaPromise<GetUser_rolesAggregateType<T>>

    /**
     * Group by User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_rolesGroupByArgs['orderBy'] }
        : { orderBy?: user_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_roles model
   */
  readonly fields: user_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_roles model
   */ 
  interface user_rolesFieldRefs {
    readonly userId: FieldRef<"user_roles", 'String'>
    readonly roleId: FieldRef<"user_roles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * user_roles findUnique
   */
  export type user_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles findUniqueOrThrow
   */
  export type user_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles findFirst
   */
  export type user_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles findFirstOrThrow
   */
  export type user_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles findMany
   */
  export type user_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles create
   */
  export type user_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a user_roles.
     */
    data: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>
  }

  /**
   * user_roles createMany
   */
  export type user_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_roles.
     */
    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_roles createManyAndReturn
   */
  export type user_rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_roles.
     */
    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_roles update
   */
  export type user_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a user_roles.
     */
    data: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>
    /**
     * Choose, which user_roles to update.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles updateMany
   */
  export type user_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_rolesWhereInput
  }

  /**
   * user_roles upsert
   */
  export type user_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the user_roles to update in case it exists.
     */
    where: user_rolesWhereUniqueInput
    /**
     * In case the user_roles found by the `where` argument doesn't exist, create a new user_roles with this data.
     */
    create: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>
    /**
     * In case the user_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>
  }

  /**
   * user_roles delete
   */
  export type user_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter which user_roles to delete.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles deleteMany
   */
  export type user_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to delete
     */
    where?: user_rolesWhereInput
  }

  /**
   * user_roles without action
   */
  export type user_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
  }


  /**
   * Model properties
   */

  export type AggregateProperties = {
    _count: PropertiesCountAggregateOutputType | null
    _avg: PropertiesAvgAggregateOutputType | null
    _sum: PropertiesSumAggregateOutputType | null
    _min: PropertiesMinAggregateOutputType | null
    _max: PropertiesMaxAggregateOutputType | null
  }

  export type PropertiesAvgAggregateOutputType = {
    pricePerHour: Decimal | null
    pricePerDay: Decimal | null
    totalSlots: number | null
    totalNormalSlots: number | null
    totalEvSlots: number | null
    totalCarWashSlots: number | null
  }

  export type PropertiesSumAggregateOutputType = {
    pricePerHour: Decimal | null
    pricePerDay: Decimal | null
    totalSlots: number | null
    totalNormalSlots: number | null
    totalEvSlots: number | null
    totalCarWashSlots: number | null
  }

  export type PropertiesMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    propertyName: string | null
    address: string | null
    pricePerHour: Decimal | null
    pricePerDay: Decimal | null
    currency: string | null
    status: $Enums.PropertyStatus | null
    totalSlots: number | null
    totalNormalSlots: number | null
    totalEvSlots: number | null
    totalCarWashSlots: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertiesMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    propertyName: string | null
    address: string | null
    pricePerHour: Decimal | null
    pricePerDay: Decimal | null
    currency: string | null
    status: $Enums.PropertyStatus | null
    totalSlots: number | null
    totalNormalSlots: number | null
    totalEvSlots: number | null
    totalCarWashSlots: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertiesCountAggregateOutputType = {
    id: number
    ownerId: number
    propertyName: number
    address: number
    pricePerHour: number
    pricePerDay: number
    currency: number
    status: number
    totalSlots: number
    totalNormalSlots: number
    totalEvSlots: number
    totalCarWashSlots: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertiesAvgAggregateInputType = {
    pricePerHour?: true
    pricePerDay?: true
    totalSlots?: true
    totalNormalSlots?: true
    totalEvSlots?: true
    totalCarWashSlots?: true
  }

  export type PropertiesSumAggregateInputType = {
    pricePerHour?: true
    pricePerDay?: true
    totalSlots?: true
    totalNormalSlots?: true
    totalEvSlots?: true
    totalCarWashSlots?: true
  }

  export type PropertiesMinAggregateInputType = {
    id?: true
    ownerId?: true
    propertyName?: true
    address?: true
    pricePerHour?: true
    pricePerDay?: true
    currency?: true
    status?: true
    totalSlots?: true
    totalNormalSlots?: true
    totalEvSlots?: true
    totalCarWashSlots?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertiesMaxAggregateInputType = {
    id?: true
    ownerId?: true
    propertyName?: true
    address?: true
    pricePerHour?: true
    pricePerDay?: true
    currency?: true
    status?: true
    totalSlots?: true
    totalNormalSlots?: true
    totalEvSlots?: true
    totalCarWashSlots?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertiesCountAggregateInputType = {
    id?: true
    ownerId?: true
    propertyName?: true
    address?: true
    pricePerHour?: true
    pricePerDay?: true
    currency?: true
    status?: true
    totalSlots?: true
    totalNormalSlots?: true
    totalEvSlots?: true
    totalCarWashSlots?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which properties to aggregate.
     */
    where?: propertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of properties to fetch.
     */
    orderBy?: propertiesOrderByWithRelationInput | propertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: propertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned properties
    **/
    _count?: true | PropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertiesMaxAggregateInputType
  }

  export type GetPropertiesAggregateType<T extends PropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperties[P]>
      : GetScalarType<T[P], AggregateProperties[P]>
  }




  export type propertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: propertiesWhereInput
    orderBy?: propertiesOrderByWithAggregationInput | propertiesOrderByWithAggregationInput[]
    by: PropertiesScalarFieldEnum[] | PropertiesScalarFieldEnum
    having?: propertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertiesCountAggregateInputType | true
    _avg?: PropertiesAvgAggregateInputType
    _sum?: PropertiesSumAggregateInputType
    _min?: PropertiesMinAggregateInputType
    _max?: PropertiesMaxAggregateInputType
  }

  export type PropertiesGroupByOutputType = {
    id: string
    ownerId: string
    propertyName: string
    address: string
    pricePerHour: Decimal
    pricePerDay: Decimal
    currency: string
    status: $Enums.PropertyStatus
    totalSlots: number
    totalNormalSlots: number
    totalEvSlots: number
    totalCarWashSlots: number
    createdAt: Date
    updatedAt: Date
    _count: PropertiesCountAggregateOutputType | null
    _avg: PropertiesAvgAggregateOutputType | null
    _sum: PropertiesSumAggregateOutputType | null
    _min: PropertiesMinAggregateOutputType | null
    _max: PropertiesMaxAggregateOutputType | null
  }

  type GetPropertiesGroupByPayload<T extends propertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], PropertiesGroupByOutputType[P]>
        }
      >
    >


  export type propertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    propertyName?: boolean
    address?: boolean
    pricePerHour?: boolean
    pricePerDay?: boolean
    currency?: boolean
    status?: boolean
    totalSlots?: boolean
    totalNormalSlots?: boolean
    totalEvSlots?: boolean
    totalCarWashSlots?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | properties$bookingsArgs<ExtArgs>
    owner?: boolean | usersDefaultArgs<ExtArgs>
    parkingSlots?: boolean | properties$parkingSlotsArgs<ExtArgs>
    _count?: boolean | PropertiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["properties"]>

  export type propertiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    propertyName?: boolean
    address?: boolean
    pricePerHour?: boolean
    pricePerDay?: boolean
    currency?: boolean
    status?: boolean
    totalSlots?: boolean
    totalNormalSlots?: boolean
    totalEvSlots?: boolean
    totalCarWashSlots?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["properties"]>

  export type propertiesSelectScalar = {
    id?: boolean
    ownerId?: boolean
    propertyName?: boolean
    address?: boolean
    pricePerHour?: boolean
    pricePerDay?: boolean
    currency?: boolean
    status?: boolean
    totalSlots?: boolean
    totalNormalSlots?: boolean
    totalEvSlots?: boolean
    totalCarWashSlots?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type propertiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | properties$bookingsArgs<ExtArgs>
    owner?: boolean | usersDefaultArgs<ExtArgs>
    parkingSlots?: boolean | properties$parkingSlotsArgs<ExtArgs>
    _count?: boolean | PropertiesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type propertiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $propertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "properties"
    objects: {
      bookings: Prisma.$bookingsPayload<ExtArgs>[]
      owner: Prisma.$usersPayload<ExtArgs>
      parkingSlots: Prisma.$parking_slotsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      propertyName: string
      address: string
      pricePerHour: Prisma.Decimal
      pricePerDay: Prisma.Decimal
      currency: string
      status: $Enums.PropertyStatus
      totalSlots: number
      totalNormalSlots: number
      totalEvSlots: number
      totalCarWashSlots: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["properties"]>
    composites: {}
  }

  type propertiesGetPayload<S extends boolean | null | undefined | propertiesDefaultArgs> = $Result.GetResult<Prisma.$propertiesPayload, S>

  type propertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<propertiesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PropertiesCountAggregateInputType | true
    }

  export interface propertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['properties'], meta: { name: 'properties' } }
    /**
     * Find zero or one Properties that matches the filter.
     * @param {propertiesFindUniqueArgs} args - Arguments to find a Properties
     * @example
     * // Get one Properties
     * const properties = await prisma.properties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends propertiesFindUniqueArgs>(args: SelectSubset<T, propertiesFindUniqueArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Properties that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {propertiesFindUniqueOrThrowArgs} args - Arguments to find a Properties
     * @example
     * // Get one Properties
     * const properties = await prisma.properties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends propertiesFindUniqueOrThrowArgs>(args: SelectSubset<T, propertiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {propertiesFindFirstArgs} args - Arguments to find a Properties
     * @example
     * // Get one Properties
     * const properties = await prisma.properties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends propertiesFindFirstArgs>(args?: SelectSubset<T, propertiesFindFirstArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Properties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {propertiesFindFirstOrThrowArgs} args - Arguments to find a Properties
     * @example
     * // Get one Properties
     * const properties = await prisma.properties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends propertiesFindFirstOrThrowArgs>(args?: SelectSubset<T, propertiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {propertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.properties.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.properties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertiesWithIdOnly = await prisma.properties.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends propertiesFindManyArgs>(args?: SelectSubset<T, propertiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Properties.
     * @param {propertiesCreateArgs} args - Arguments to create a Properties.
     * @example
     * // Create one Properties
     * const Properties = await prisma.properties.create({
     *   data: {
     *     // ... data to create a Properties
     *   }
     * })
     * 
     */
    create<T extends propertiesCreateArgs>(args: SelectSubset<T, propertiesCreateArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Properties.
     * @param {propertiesCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const properties = await prisma.properties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends propertiesCreateManyArgs>(args?: SelectSubset<T, propertiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {propertiesCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const properties = await prisma.properties.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertiesWithIdOnly = await prisma.properties.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends propertiesCreateManyAndReturnArgs>(args?: SelectSubset<T, propertiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Properties.
     * @param {propertiesDeleteArgs} args - Arguments to delete one Properties.
     * @example
     * // Delete one Properties
     * const Properties = await prisma.properties.delete({
     *   where: {
     *     // ... filter to delete one Properties
     *   }
     * })
     * 
     */
    delete<T extends propertiesDeleteArgs>(args: SelectSubset<T, propertiesDeleteArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Properties.
     * @param {propertiesUpdateArgs} args - Arguments to update one Properties.
     * @example
     * // Update one Properties
     * const properties = await prisma.properties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends propertiesUpdateArgs>(args: SelectSubset<T, propertiesUpdateArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Properties.
     * @param {propertiesDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.properties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends propertiesDeleteManyArgs>(args?: SelectSubset<T, propertiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {propertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const properties = await prisma.properties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends propertiesUpdateManyArgs>(args: SelectSubset<T, propertiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Properties.
     * @param {propertiesUpsertArgs} args - Arguments to update or create a Properties.
     * @example
     * // Update or create a Properties
     * const properties = await prisma.properties.upsert({
     *   create: {
     *     // ... data to create a Properties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Properties we want to update
     *   }
     * })
     */
    upsert<T extends propertiesUpsertArgs>(args: SelectSubset<T, propertiesUpsertArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {propertiesCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.properties.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends propertiesCountArgs>(
      args?: Subset<T, propertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertiesAggregateArgs>(args: Subset<T, PropertiesAggregateArgs>): Prisma.PrismaPromise<GetPropertiesAggregateType<T>>

    /**
     * Group by Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {propertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends propertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: propertiesGroupByArgs['orderBy'] }
        : { orderBy?: propertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, propertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the properties model
   */
  readonly fields: propertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for properties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__propertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends properties$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, properties$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany"> | Null>
    owner<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parkingSlots<T extends properties$parkingSlotsArgs<ExtArgs> = {}>(args?: Subset<T, properties$parkingSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parking_slotsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the properties model
   */ 
  interface propertiesFieldRefs {
    readonly id: FieldRef<"properties", 'String'>
    readonly ownerId: FieldRef<"properties", 'String'>
    readonly propertyName: FieldRef<"properties", 'String'>
    readonly address: FieldRef<"properties", 'String'>
    readonly pricePerHour: FieldRef<"properties", 'Decimal'>
    readonly pricePerDay: FieldRef<"properties", 'Decimal'>
    readonly currency: FieldRef<"properties", 'String'>
    readonly status: FieldRef<"properties", 'PropertyStatus'>
    readonly totalSlots: FieldRef<"properties", 'Int'>
    readonly totalNormalSlots: FieldRef<"properties", 'Int'>
    readonly totalEvSlots: FieldRef<"properties", 'Int'>
    readonly totalCarWashSlots: FieldRef<"properties", 'Int'>
    readonly createdAt: FieldRef<"properties", 'DateTime'>
    readonly updatedAt: FieldRef<"properties", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * properties findUnique
   */
  export type propertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: propertiesInclude<ExtArgs> | null
    /**
     * Filter, which properties to fetch.
     */
    where: propertiesWhereUniqueInput
  }

  /**
   * properties findUniqueOrThrow
   */
  export type propertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: propertiesInclude<ExtArgs> | null
    /**
     * Filter, which properties to fetch.
     */
    where: propertiesWhereUniqueInput
  }

  /**
   * properties findFirst
   */
  export type propertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: propertiesInclude<ExtArgs> | null
    /**
     * Filter, which properties to fetch.
     */
    where?: propertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of properties to fetch.
     */
    orderBy?: propertiesOrderByWithRelationInput | propertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for properties.
     */
    cursor?: propertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of properties.
     */
    distinct?: PropertiesScalarFieldEnum | PropertiesScalarFieldEnum[]
  }

  /**
   * properties findFirstOrThrow
   */
  export type propertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: propertiesInclude<ExtArgs> | null
    /**
     * Filter, which properties to fetch.
     */
    where?: propertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of properties to fetch.
     */
    orderBy?: propertiesOrderByWithRelationInput | propertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for properties.
     */
    cursor?: propertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of properties.
     */
    distinct?: PropertiesScalarFieldEnum | PropertiesScalarFieldEnum[]
  }

  /**
   * properties findMany
   */
  export type propertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: propertiesInclude<ExtArgs> | null
    /**
     * Filter, which properties to fetch.
     */
    where?: propertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of properties to fetch.
     */
    orderBy?: propertiesOrderByWithRelationInput | propertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing properties.
     */
    cursor?: propertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` properties.
     */
    skip?: number
    distinct?: PropertiesScalarFieldEnum | PropertiesScalarFieldEnum[]
  }

  /**
   * properties create
   */
  export type propertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: propertiesInclude<ExtArgs> | null
    /**
     * The data needed to create a properties.
     */
    data: XOR<propertiesCreateInput, propertiesUncheckedCreateInput>
  }

  /**
   * properties createMany
   */
  export type propertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many properties.
     */
    data: propertiesCreateManyInput | propertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * properties createManyAndReturn
   */
  export type propertiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many properties.
     */
    data: propertiesCreateManyInput | propertiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: propertiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * properties update
   */
  export type propertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: propertiesInclude<ExtArgs> | null
    /**
     * The data needed to update a properties.
     */
    data: XOR<propertiesUpdateInput, propertiesUncheckedUpdateInput>
    /**
     * Choose, which properties to update.
     */
    where: propertiesWhereUniqueInput
  }

  /**
   * properties updateMany
   */
  export type propertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update properties.
     */
    data: XOR<propertiesUpdateManyMutationInput, propertiesUncheckedUpdateManyInput>
    /**
     * Filter which properties to update
     */
    where?: propertiesWhereInput
  }

  /**
   * properties upsert
   */
  export type propertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: propertiesInclude<ExtArgs> | null
    /**
     * The filter to search for the properties to update in case it exists.
     */
    where: propertiesWhereUniqueInput
    /**
     * In case the properties found by the `where` argument doesn't exist, create a new properties with this data.
     */
    create: XOR<propertiesCreateInput, propertiesUncheckedCreateInput>
    /**
     * In case the properties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<propertiesUpdateInput, propertiesUncheckedUpdateInput>
  }

  /**
   * properties delete
   */
  export type propertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: propertiesInclude<ExtArgs> | null
    /**
     * Filter which properties to delete.
     */
    where: propertiesWhereUniqueInput
  }

  /**
   * properties deleteMany
   */
  export type propertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which properties to delete
     */
    where?: propertiesWhereInput
  }

  /**
   * properties.bookings
   */
  export type properties$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    cursor?: bookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * properties.parkingSlots
   */
  export type properties$parkingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parking_slots
     */
    select?: parking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parking_slotsInclude<ExtArgs> | null
    where?: parking_slotsWhereInput
    orderBy?: parking_slotsOrderByWithRelationInput | parking_slotsOrderByWithRelationInput[]
    cursor?: parking_slotsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Parking_slotsScalarFieldEnum | Parking_slotsScalarFieldEnum[]
  }

  /**
   * properties without action
   */
  export type propertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: propertiesInclude<ExtArgs> | null
  }


  /**
   * Model parking_slots
   */

  export type AggregateParking_slots = {
    _count: Parking_slotsCountAggregateOutputType | null
    _min: Parking_slotsMinAggregateOutputType | null
    _max: Parking_slotsMaxAggregateOutputType | null
  }

  export type Parking_slotsMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    slotNumber: string | null
    slotType: $Enums.SlotType | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type Parking_slotsMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    slotNumber: string | null
    slotType: $Enums.SlotType | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type Parking_slotsCountAggregateOutputType = {
    id: number
    propertyId: number
    slotNumber: number
    slotType: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type Parking_slotsMinAggregateInputType = {
    id?: true
    propertyId?: true
    slotNumber?: true
    slotType?: true
    isActive?: true
    createdAt?: true
  }

  export type Parking_slotsMaxAggregateInputType = {
    id?: true
    propertyId?: true
    slotNumber?: true
    slotType?: true
    isActive?: true
    createdAt?: true
  }

  export type Parking_slotsCountAggregateInputType = {
    id?: true
    propertyId?: true
    slotNumber?: true
    slotType?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type Parking_slotsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parking_slots to aggregate.
     */
    where?: parking_slotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parking_slots to fetch.
     */
    orderBy?: parking_slotsOrderByWithRelationInput | parking_slotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parking_slotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parking_slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parking_slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parking_slots
    **/
    _count?: true | Parking_slotsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Parking_slotsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Parking_slotsMaxAggregateInputType
  }

  export type GetParking_slotsAggregateType<T extends Parking_slotsAggregateArgs> = {
        [P in keyof T & keyof AggregateParking_slots]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParking_slots[P]>
      : GetScalarType<T[P], AggregateParking_slots[P]>
  }




  export type parking_slotsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parking_slotsWhereInput
    orderBy?: parking_slotsOrderByWithAggregationInput | parking_slotsOrderByWithAggregationInput[]
    by: Parking_slotsScalarFieldEnum[] | Parking_slotsScalarFieldEnum
    having?: parking_slotsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Parking_slotsCountAggregateInputType | true
    _min?: Parking_slotsMinAggregateInputType
    _max?: Parking_slotsMaxAggregateInputType
  }

  export type Parking_slotsGroupByOutputType = {
    id: string
    propertyId: string
    slotNumber: string
    slotType: $Enums.SlotType
    isActive: boolean
    createdAt: Date
    _count: Parking_slotsCountAggregateOutputType | null
    _min: Parking_slotsMinAggregateOutputType | null
    _max: Parking_slotsMaxAggregateOutputType | null
  }

  type GetParking_slotsGroupByPayload<T extends parking_slotsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Parking_slotsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Parking_slotsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Parking_slotsGroupByOutputType[P]>
            : GetScalarType<T[P], Parking_slotsGroupByOutputType[P]>
        }
      >
    >


  export type parking_slotsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    slotNumber?: boolean
    slotType?: boolean
    isActive?: boolean
    createdAt?: boolean
    bookingSlots?: boolean | parking_slots$bookingSlotsArgs<ExtArgs>
    property?: boolean | propertiesDefaultArgs<ExtArgs>
    _count?: boolean | Parking_slotsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parking_slots"]>

  export type parking_slotsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    slotNumber?: boolean
    slotType?: boolean
    isActive?: boolean
    createdAt?: boolean
    property?: boolean | propertiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parking_slots"]>

  export type parking_slotsSelectScalar = {
    id?: boolean
    propertyId?: boolean
    slotNumber?: boolean
    slotType?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type parking_slotsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingSlots?: boolean | parking_slots$bookingSlotsArgs<ExtArgs>
    property?: boolean | propertiesDefaultArgs<ExtArgs>
    _count?: boolean | Parking_slotsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type parking_slotsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | propertiesDefaultArgs<ExtArgs>
  }

  export type $parking_slotsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "parking_slots"
    objects: {
      bookingSlots: Prisma.$booking_slotsPayload<ExtArgs>[]
      property: Prisma.$propertiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      slotNumber: string
      slotType: $Enums.SlotType
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["parking_slots"]>
    composites: {}
  }

  type parking_slotsGetPayload<S extends boolean | null | undefined | parking_slotsDefaultArgs> = $Result.GetResult<Prisma.$parking_slotsPayload, S>

  type parking_slotsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<parking_slotsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Parking_slotsCountAggregateInputType | true
    }

  export interface parking_slotsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parking_slots'], meta: { name: 'parking_slots' } }
    /**
     * Find zero or one Parking_slots that matches the filter.
     * @param {parking_slotsFindUniqueArgs} args - Arguments to find a Parking_slots
     * @example
     * // Get one Parking_slots
     * const parking_slots = await prisma.parking_slots.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends parking_slotsFindUniqueArgs>(args: SelectSubset<T, parking_slotsFindUniqueArgs<ExtArgs>>): Prisma__parking_slotsClient<$Result.GetResult<Prisma.$parking_slotsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Parking_slots that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {parking_slotsFindUniqueOrThrowArgs} args - Arguments to find a Parking_slots
     * @example
     * // Get one Parking_slots
     * const parking_slots = await prisma.parking_slots.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends parking_slotsFindUniqueOrThrowArgs>(args: SelectSubset<T, parking_slotsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__parking_slotsClient<$Result.GetResult<Prisma.$parking_slotsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Parking_slots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parking_slotsFindFirstArgs} args - Arguments to find a Parking_slots
     * @example
     * // Get one Parking_slots
     * const parking_slots = await prisma.parking_slots.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends parking_slotsFindFirstArgs>(args?: SelectSubset<T, parking_slotsFindFirstArgs<ExtArgs>>): Prisma__parking_slotsClient<$Result.GetResult<Prisma.$parking_slotsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Parking_slots that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parking_slotsFindFirstOrThrowArgs} args - Arguments to find a Parking_slots
     * @example
     * // Get one Parking_slots
     * const parking_slots = await prisma.parking_slots.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends parking_slotsFindFirstOrThrowArgs>(args?: SelectSubset<T, parking_slotsFindFirstOrThrowArgs<ExtArgs>>): Prisma__parking_slotsClient<$Result.GetResult<Prisma.$parking_slotsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parking_slots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parking_slotsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parking_slots
     * const parking_slots = await prisma.parking_slots.findMany()
     * 
     * // Get first 10 Parking_slots
     * const parking_slots = await prisma.parking_slots.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parking_slotsWithIdOnly = await prisma.parking_slots.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends parking_slotsFindManyArgs>(args?: SelectSubset<T, parking_slotsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parking_slotsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Parking_slots.
     * @param {parking_slotsCreateArgs} args - Arguments to create a Parking_slots.
     * @example
     * // Create one Parking_slots
     * const Parking_slots = await prisma.parking_slots.create({
     *   data: {
     *     // ... data to create a Parking_slots
     *   }
     * })
     * 
     */
    create<T extends parking_slotsCreateArgs>(args: SelectSubset<T, parking_slotsCreateArgs<ExtArgs>>): Prisma__parking_slotsClient<$Result.GetResult<Prisma.$parking_slotsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parking_slots.
     * @param {parking_slotsCreateManyArgs} args - Arguments to create many Parking_slots.
     * @example
     * // Create many Parking_slots
     * const parking_slots = await prisma.parking_slots.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends parking_slotsCreateManyArgs>(args?: SelectSubset<T, parking_slotsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parking_slots and returns the data saved in the database.
     * @param {parking_slotsCreateManyAndReturnArgs} args - Arguments to create many Parking_slots.
     * @example
     * // Create many Parking_slots
     * const parking_slots = await prisma.parking_slots.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parking_slots and only return the `id`
     * const parking_slotsWithIdOnly = await prisma.parking_slots.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends parking_slotsCreateManyAndReturnArgs>(args?: SelectSubset<T, parking_slotsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parking_slotsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Parking_slots.
     * @param {parking_slotsDeleteArgs} args - Arguments to delete one Parking_slots.
     * @example
     * // Delete one Parking_slots
     * const Parking_slots = await prisma.parking_slots.delete({
     *   where: {
     *     // ... filter to delete one Parking_slots
     *   }
     * })
     * 
     */
    delete<T extends parking_slotsDeleteArgs>(args: SelectSubset<T, parking_slotsDeleteArgs<ExtArgs>>): Prisma__parking_slotsClient<$Result.GetResult<Prisma.$parking_slotsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Parking_slots.
     * @param {parking_slotsUpdateArgs} args - Arguments to update one Parking_slots.
     * @example
     * // Update one Parking_slots
     * const parking_slots = await prisma.parking_slots.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends parking_slotsUpdateArgs>(args: SelectSubset<T, parking_slotsUpdateArgs<ExtArgs>>): Prisma__parking_slotsClient<$Result.GetResult<Prisma.$parking_slotsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parking_slots.
     * @param {parking_slotsDeleteManyArgs} args - Arguments to filter Parking_slots to delete.
     * @example
     * // Delete a few Parking_slots
     * const { count } = await prisma.parking_slots.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends parking_slotsDeleteManyArgs>(args?: SelectSubset<T, parking_slotsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parking_slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parking_slotsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parking_slots
     * const parking_slots = await prisma.parking_slots.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends parking_slotsUpdateManyArgs>(args: SelectSubset<T, parking_slotsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parking_slots.
     * @param {parking_slotsUpsertArgs} args - Arguments to update or create a Parking_slots.
     * @example
     * // Update or create a Parking_slots
     * const parking_slots = await prisma.parking_slots.upsert({
     *   create: {
     *     // ... data to create a Parking_slots
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parking_slots we want to update
     *   }
     * })
     */
    upsert<T extends parking_slotsUpsertArgs>(args: SelectSubset<T, parking_slotsUpsertArgs<ExtArgs>>): Prisma__parking_slotsClient<$Result.GetResult<Prisma.$parking_slotsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Parking_slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parking_slotsCountArgs} args - Arguments to filter Parking_slots to count.
     * @example
     * // Count the number of Parking_slots
     * const count = await prisma.parking_slots.count({
     *   where: {
     *     // ... the filter for the Parking_slots we want to count
     *   }
     * })
    **/
    count<T extends parking_slotsCountArgs>(
      args?: Subset<T, parking_slotsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Parking_slotsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parking_slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parking_slotsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Parking_slotsAggregateArgs>(args: Subset<T, Parking_slotsAggregateArgs>): Prisma.PrismaPromise<GetParking_slotsAggregateType<T>>

    /**
     * Group by Parking_slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parking_slotsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parking_slotsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parking_slotsGroupByArgs['orderBy'] }
        : { orderBy?: parking_slotsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parking_slotsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParking_slotsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the parking_slots model
   */
  readonly fields: parking_slotsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parking_slots.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__parking_slotsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingSlots<T extends parking_slots$bookingSlotsArgs<ExtArgs> = {}>(args?: Subset<T, parking_slots$bookingSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "findMany"> | Null>
    property<T extends propertiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, propertiesDefaultArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the parking_slots model
   */ 
  interface parking_slotsFieldRefs {
    readonly id: FieldRef<"parking_slots", 'String'>
    readonly propertyId: FieldRef<"parking_slots", 'String'>
    readonly slotNumber: FieldRef<"parking_slots", 'String'>
    readonly slotType: FieldRef<"parking_slots", 'SlotType'>
    readonly isActive: FieldRef<"parking_slots", 'Boolean'>
    readonly createdAt: FieldRef<"parking_slots", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * parking_slots findUnique
   */
  export type parking_slotsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parking_slots
     */
    select?: parking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parking_slotsInclude<ExtArgs> | null
    /**
     * Filter, which parking_slots to fetch.
     */
    where: parking_slotsWhereUniqueInput
  }

  /**
   * parking_slots findUniqueOrThrow
   */
  export type parking_slotsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parking_slots
     */
    select?: parking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parking_slotsInclude<ExtArgs> | null
    /**
     * Filter, which parking_slots to fetch.
     */
    where: parking_slotsWhereUniqueInput
  }

  /**
   * parking_slots findFirst
   */
  export type parking_slotsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parking_slots
     */
    select?: parking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parking_slotsInclude<ExtArgs> | null
    /**
     * Filter, which parking_slots to fetch.
     */
    where?: parking_slotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parking_slots to fetch.
     */
    orderBy?: parking_slotsOrderByWithRelationInput | parking_slotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parking_slots.
     */
    cursor?: parking_slotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parking_slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parking_slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parking_slots.
     */
    distinct?: Parking_slotsScalarFieldEnum | Parking_slotsScalarFieldEnum[]
  }

  /**
   * parking_slots findFirstOrThrow
   */
  export type parking_slotsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parking_slots
     */
    select?: parking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parking_slotsInclude<ExtArgs> | null
    /**
     * Filter, which parking_slots to fetch.
     */
    where?: parking_slotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parking_slots to fetch.
     */
    orderBy?: parking_slotsOrderByWithRelationInput | parking_slotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parking_slots.
     */
    cursor?: parking_slotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parking_slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parking_slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parking_slots.
     */
    distinct?: Parking_slotsScalarFieldEnum | Parking_slotsScalarFieldEnum[]
  }

  /**
   * parking_slots findMany
   */
  export type parking_slotsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parking_slots
     */
    select?: parking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parking_slotsInclude<ExtArgs> | null
    /**
     * Filter, which parking_slots to fetch.
     */
    where?: parking_slotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parking_slots to fetch.
     */
    orderBy?: parking_slotsOrderByWithRelationInput | parking_slotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parking_slots.
     */
    cursor?: parking_slotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parking_slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parking_slots.
     */
    skip?: number
    distinct?: Parking_slotsScalarFieldEnum | Parking_slotsScalarFieldEnum[]
  }

  /**
   * parking_slots create
   */
  export type parking_slotsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parking_slots
     */
    select?: parking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parking_slotsInclude<ExtArgs> | null
    /**
     * The data needed to create a parking_slots.
     */
    data: XOR<parking_slotsCreateInput, parking_slotsUncheckedCreateInput>
  }

  /**
   * parking_slots createMany
   */
  export type parking_slotsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parking_slots.
     */
    data: parking_slotsCreateManyInput | parking_slotsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * parking_slots createManyAndReturn
   */
  export type parking_slotsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parking_slots
     */
    select?: parking_slotsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many parking_slots.
     */
    data: parking_slotsCreateManyInput | parking_slotsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parking_slotsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * parking_slots update
   */
  export type parking_slotsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parking_slots
     */
    select?: parking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parking_slotsInclude<ExtArgs> | null
    /**
     * The data needed to update a parking_slots.
     */
    data: XOR<parking_slotsUpdateInput, parking_slotsUncheckedUpdateInput>
    /**
     * Choose, which parking_slots to update.
     */
    where: parking_slotsWhereUniqueInput
  }

  /**
   * parking_slots updateMany
   */
  export type parking_slotsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parking_slots.
     */
    data: XOR<parking_slotsUpdateManyMutationInput, parking_slotsUncheckedUpdateManyInput>
    /**
     * Filter which parking_slots to update
     */
    where?: parking_slotsWhereInput
  }

  /**
   * parking_slots upsert
   */
  export type parking_slotsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parking_slots
     */
    select?: parking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parking_slotsInclude<ExtArgs> | null
    /**
     * The filter to search for the parking_slots to update in case it exists.
     */
    where: parking_slotsWhereUniqueInput
    /**
     * In case the parking_slots found by the `where` argument doesn't exist, create a new parking_slots with this data.
     */
    create: XOR<parking_slotsCreateInput, parking_slotsUncheckedCreateInput>
    /**
     * In case the parking_slots was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parking_slotsUpdateInput, parking_slotsUncheckedUpdateInput>
  }

  /**
   * parking_slots delete
   */
  export type parking_slotsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parking_slots
     */
    select?: parking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parking_slotsInclude<ExtArgs> | null
    /**
     * Filter which parking_slots to delete.
     */
    where: parking_slotsWhereUniqueInput
  }

  /**
   * parking_slots deleteMany
   */
  export type parking_slotsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parking_slots to delete
     */
    where?: parking_slotsWhereInput
  }

  /**
   * parking_slots.bookingSlots
   */
  export type parking_slots$bookingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsInclude<ExtArgs> | null
    where?: booking_slotsWhereInput
    orderBy?: booking_slotsOrderByWithRelationInput | booking_slotsOrderByWithRelationInput[]
    cursor?: booking_slotsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Booking_slotsScalarFieldEnum | Booking_slotsScalarFieldEnum[]
  }

  /**
   * parking_slots without action
   */
  export type parking_slotsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parking_slots
     */
    select?: parking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parking_slotsInclude<ExtArgs> | null
  }


  /**
   * Model vehicles
   */

  export type AggregateVehicles = {
    _count: VehiclesCountAggregateOutputType | null
    _min: VehiclesMinAggregateOutputType | null
    _max: VehiclesMaxAggregateOutputType | null
  }

  export type VehiclesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleNumber: string | null
    type: string | null
    model: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehiclesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vehicleNumber: string | null
    type: string | null
    model: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehiclesCountAggregateOutputType = {
    id: number
    userId: number
    vehicleNumber: number
    type: number
    model: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehiclesMinAggregateInputType = {
    id?: true
    userId?: true
    vehicleNumber?: true
    type?: true
    model?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehiclesMaxAggregateInputType = {
    id?: true
    userId?: true
    vehicleNumber?: true
    type?: true
    model?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehiclesCountAggregateInputType = {
    id?: true
    userId?: true
    vehicleNumber?: true
    type?: true
    model?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehiclesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicles to aggregate.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicles
    **/
    _count?: true | VehiclesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehiclesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehiclesMaxAggregateInputType
  }

  export type GetVehiclesAggregateType<T extends VehiclesAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicles[P]>
      : GetScalarType<T[P], AggregateVehicles[P]>
  }




  export type vehiclesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehiclesWhereInput
    orderBy?: vehiclesOrderByWithAggregationInput | vehiclesOrderByWithAggregationInput[]
    by: VehiclesScalarFieldEnum[] | VehiclesScalarFieldEnum
    having?: vehiclesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehiclesCountAggregateInputType | true
    _min?: VehiclesMinAggregateInputType
    _max?: VehiclesMaxAggregateInputType
  }

  export type VehiclesGroupByOutputType = {
    id: string
    userId: string
    vehicleNumber: string
    type: string | null
    model: string | null
    color: string | null
    createdAt: Date
    updatedAt: Date
    _count: VehiclesCountAggregateOutputType | null
    _min: VehiclesMinAggregateOutputType | null
    _max: VehiclesMaxAggregateOutputType | null
  }

  type GetVehiclesGroupByPayload<T extends vehiclesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehiclesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehiclesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehiclesGroupByOutputType[P]>
            : GetScalarType<T[P], VehiclesGroupByOutputType[P]>
        }
      >
    >


  export type vehiclesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleNumber?: boolean
    type?: boolean
    model?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | vehicles$bookingsArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | VehiclesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicles"]>

  export type vehiclesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vehicleNumber?: boolean
    type?: boolean
    model?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicles"]>

  export type vehiclesSelectScalar = {
    id?: boolean
    userId?: boolean
    vehicleNumber?: boolean
    type?: boolean
    model?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehiclesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | vehicles$bookingsArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | VehiclesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type vehiclesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $vehiclesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicles"
    objects: {
      bookings: Prisma.$bookingsPayload<ExtArgs>[]
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      vehicleNumber: string
      type: string | null
      model: string | null
      color: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicles"]>
    composites: {}
  }

  type vehiclesGetPayload<S extends boolean | null | undefined | vehiclesDefaultArgs> = $Result.GetResult<Prisma.$vehiclesPayload, S>

  type vehiclesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<vehiclesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehiclesCountAggregateInputType | true
    }

  export interface vehiclesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicles'], meta: { name: 'vehicles' } }
    /**
     * Find zero or one Vehicles that matches the filter.
     * @param {vehiclesFindUniqueArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehiclesFindUniqueArgs>(args: SelectSubset<T, vehiclesFindUniqueArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vehicles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {vehiclesFindUniqueOrThrowArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehiclesFindUniqueOrThrowArgs>(args: SelectSubset<T, vehiclesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesFindFirstArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehiclesFindFirstArgs>(args?: SelectSubset<T, vehiclesFindFirstArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vehicles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesFindFirstOrThrowArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehiclesFindFirstOrThrowArgs>(args?: SelectSubset<T, vehiclesFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicles.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehiclesWithIdOnly = await prisma.vehicles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehiclesFindManyArgs>(args?: SelectSubset<T, vehiclesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vehicles.
     * @param {vehiclesCreateArgs} args - Arguments to create a Vehicles.
     * @example
     * // Create one Vehicles
     * const Vehicles = await prisma.vehicles.create({
     *   data: {
     *     // ... data to create a Vehicles
     *   }
     * })
     * 
     */
    create<T extends vehiclesCreateArgs>(args: SelectSubset<T, vehiclesCreateArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vehicles.
     * @param {vehiclesCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicles = await prisma.vehicles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehiclesCreateManyArgs>(args?: SelectSubset<T, vehiclesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {vehiclesCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicles = await prisma.vehicles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehiclesWithIdOnly = await prisma.vehicles.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends vehiclesCreateManyAndReturnArgs>(args?: SelectSubset<T, vehiclesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vehicles.
     * @param {vehiclesDeleteArgs} args - Arguments to delete one Vehicles.
     * @example
     * // Delete one Vehicles
     * const Vehicles = await prisma.vehicles.delete({
     *   where: {
     *     // ... filter to delete one Vehicles
     *   }
     * })
     * 
     */
    delete<T extends vehiclesDeleteArgs>(args: SelectSubset<T, vehiclesDeleteArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vehicles.
     * @param {vehiclesUpdateArgs} args - Arguments to update one Vehicles.
     * @example
     * // Update one Vehicles
     * const vehicles = await prisma.vehicles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehiclesUpdateArgs>(args: SelectSubset<T, vehiclesUpdateArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vehicles.
     * @param {vehiclesDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehiclesDeleteManyArgs>(args?: SelectSubset<T, vehiclesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicles = await prisma.vehicles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehiclesUpdateManyArgs>(args: SelectSubset<T, vehiclesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicles.
     * @param {vehiclesUpsertArgs} args - Arguments to update or create a Vehicles.
     * @example
     * // Update or create a Vehicles
     * const vehicles = await prisma.vehicles.upsert({
     *   create: {
     *     // ... data to create a Vehicles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicles we want to update
     *   }
     * })
     */
    upsert<T extends vehiclesUpsertArgs>(args: SelectSubset<T, vehiclesUpsertArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicles.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends vehiclesCountArgs>(
      args?: Subset<T, vehiclesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehiclesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiclesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehiclesAggregateArgs>(args: Subset<T, VehiclesAggregateArgs>): Prisma.PrismaPromise<GetVehiclesAggregateType<T>>

    /**
     * Group by Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehiclesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehiclesGroupByArgs['orderBy'] }
        : { orderBy?: vehiclesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehiclesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehiclesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicles model
   */
  readonly fields: vehiclesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehiclesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends vehicles$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, vehicles$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicles model
   */ 
  interface vehiclesFieldRefs {
    readonly id: FieldRef<"vehicles", 'String'>
    readonly userId: FieldRef<"vehicles", 'String'>
    readonly vehicleNumber: FieldRef<"vehicles", 'String'>
    readonly type: FieldRef<"vehicles", 'String'>
    readonly model: FieldRef<"vehicles", 'String'>
    readonly color: FieldRef<"vehicles", 'String'>
    readonly createdAt: FieldRef<"vehicles", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicles findUnique
   */
  export type vehiclesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles findUniqueOrThrow
   */
  export type vehiclesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles findFirst
   */
  export type vehiclesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicles.
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicles.
     */
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * vehicles findFirstOrThrow
   */
  export type vehiclesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicles.
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicles.
     */
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * vehicles findMany
   */
  export type vehiclesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicles.
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * vehicles create
   */
  export type vehiclesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicles.
     */
    data: XOR<vehiclesCreateInput, vehiclesUncheckedCreateInput>
  }

  /**
   * vehicles createMany
   */
  export type vehiclesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicles.
     */
    data: vehiclesCreateManyInput | vehiclesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicles createManyAndReturn
   */
  export type vehiclesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many vehicles.
     */
    data: vehiclesCreateManyInput | vehiclesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * vehicles update
   */
  export type vehiclesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicles.
     */
    data: XOR<vehiclesUpdateInput, vehiclesUncheckedUpdateInput>
    /**
     * Choose, which vehicles to update.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles updateMany
   */
  export type vehiclesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicles.
     */
    data: XOR<vehiclesUpdateManyMutationInput, vehiclesUncheckedUpdateManyInput>
    /**
     * Filter which vehicles to update
     */
    where?: vehiclesWhereInput
  }

  /**
   * vehicles upsert
   */
  export type vehiclesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicles to update in case it exists.
     */
    where: vehiclesWhereUniqueInput
    /**
     * In case the vehicles found by the `where` argument doesn't exist, create a new vehicles with this data.
     */
    create: XOR<vehiclesCreateInput, vehiclesUncheckedCreateInput>
    /**
     * In case the vehicles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehiclesUpdateInput, vehiclesUncheckedUpdateInput>
  }

  /**
   * vehicles delete
   */
  export type vehiclesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    /**
     * Filter which vehicles to delete.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles deleteMany
   */
  export type vehiclesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicles to delete
     */
    where?: vehiclesWhereInput
  }

  /**
   * vehicles.bookings
   */
  export type vehicles$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    cursor?: bookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * vehicles without action
   */
  export type vehiclesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
  }


  /**
   * Model bookings
   */

  export type AggregateBookings = {
    _count: BookingsCountAggregateOutputType | null
    _min: BookingsMinAggregateOutputType | null
    _max: BookingsMaxAggregateOutputType | null
  }

  export type BookingsMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    propertyId: string | null
    vehicleId: string | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.BookingStatus | null
    parkingType: $Enums.SlotType | null
    bookingType: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingsMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    propertyId: string | null
    vehicleId: string | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.BookingStatus | null
    parkingType: $Enums.SlotType | null
    bookingType: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingsCountAggregateOutputType = {
    id: number
    customerId: number
    propertyId: number
    vehicleId: number
    startTime: number
    endTime: number
    status: number
    parkingType: number
    bookingType: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingsMinAggregateInputType = {
    id?: true
    customerId?: true
    propertyId?: true
    vehicleId?: true
    startTime?: true
    endTime?: true
    status?: true
    parkingType?: true
    bookingType?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingsMaxAggregateInputType = {
    id?: true
    customerId?: true
    propertyId?: true
    vehicleId?: true
    startTime?: true
    endTime?: true
    status?: true
    parkingType?: true
    bookingType?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingsCountAggregateInputType = {
    id?: true
    customerId?: true
    propertyId?: true
    vehicleId?: true
    startTime?: true
    endTime?: true
    status?: true
    parkingType?: true
    bookingType?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookings to aggregate.
     */
    where?: bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bookings
    **/
    _count?: true | BookingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingsMaxAggregateInputType
  }

  export type GetBookingsAggregateType<T extends BookingsAggregateArgs> = {
        [P in keyof T & keyof AggregateBookings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookings[P]>
      : GetScalarType<T[P], AggregateBookings[P]>
  }




  export type bookingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithAggregationInput | bookingsOrderByWithAggregationInput[]
    by: BookingsScalarFieldEnum[] | BookingsScalarFieldEnum
    having?: bookingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingsCountAggregateInputType | true
    _min?: BookingsMinAggregateInputType
    _max?: BookingsMaxAggregateInputType
  }

  export type BookingsGroupByOutputType = {
    id: string
    customerId: string
    propertyId: string
    vehicleId: string | null
    startTime: Date
    endTime: Date
    status: $Enums.BookingStatus
    parkingType: $Enums.SlotType
    bookingType: string
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: BookingsCountAggregateOutputType | null
    _min: BookingsMinAggregateOutputType | null
    _max: BookingsMaxAggregateOutputType | null
  }

  type GetBookingsGroupByPayload<T extends bookingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingsGroupByOutputType[P]>
            : GetScalarType<T[P], BookingsGroupByOutputType[P]>
        }
      >
    >


  export type bookingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    propertyId?: boolean
    vehicleId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    parkingType?: boolean
    bookingType?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingSlots?: boolean | bookings$bookingSlotsArgs<ExtArgs>
    customer?: boolean | usersDefaultArgs<ExtArgs>
    creator?: boolean | bookings$creatorArgs<ExtArgs>
    counterLogs?: boolean | bookings$counterLogsArgs<ExtArgs>
    paymentSummary?: boolean | bookings$paymentSummaryArgs<ExtArgs>
    payments?: boolean | bookings$paymentsArgs<ExtArgs>
    property?: boolean | propertiesDefaultArgs<ExtArgs>
    statusHistory?: boolean | bookings$statusHistoryArgs<ExtArgs>
    vehicle?: boolean | bookings$vehicleArgs<ExtArgs>
    _count?: boolean | BookingsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookings"]>

  export type bookingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    propertyId?: boolean
    vehicleId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    parkingType?: boolean
    bookingType?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | usersDefaultArgs<ExtArgs>
    creator?: boolean | bookings$creatorArgs<ExtArgs>
    property?: boolean | propertiesDefaultArgs<ExtArgs>
    vehicle?: boolean | bookings$vehicleArgs<ExtArgs>
  }, ExtArgs["result"]["bookings"]>

  export type bookingsSelectScalar = {
    id?: boolean
    customerId?: boolean
    propertyId?: boolean
    vehicleId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    parkingType?: boolean
    bookingType?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type bookingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingSlots?: boolean | bookings$bookingSlotsArgs<ExtArgs>
    customer?: boolean | usersDefaultArgs<ExtArgs>
    creator?: boolean | bookings$creatorArgs<ExtArgs>
    counterLogs?: boolean | bookings$counterLogsArgs<ExtArgs>
    paymentSummary?: boolean | bookings$paymentSummaryArgs<ExtArgs>
    payments?: boolean | bookings$paymentsArgs<ExtArgs>
    property?: boolean | propertiesDefaultArgs<ExtArgs>
    statusHistory?: boolean | bookings$statusHistoryArgs<ExtArgs>
    vehicle?: boolean | bookings$vehicleArgs<ExtArgs>
    _count?: boolean | BookingsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type bookingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | usersDefaultArgs<ExtArgs>
    creator?: boolean | bookings$creatorArgs<ExtArgs>
    property?: boolean | propertiesDefaultArgs<ExtArgs>
    vehicle?: boolean | bookings$vehicleArgs<ExtArgs>
  }

  export type $bookingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bookings"
    objects: {
      bookingSlots: Prisma.$booking_slotsPayload<ExtArgs>[]
      customer: Prisma.$usersPayload<ExtArgs>
      creator: Prisma.$usersPayload<ExtArgs> | null
      counterLogs: Prisma.$counter_transactionsPayload<ExtArgs>[]
      paymentSummary: Prisma.$payment_summaryPayload<ExtArgs> | null
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      property: Prisma.$propertiesPayload<ExtArgs>
      statusHistory: Prisma.$booking_status_historyPayload<ExtArgs>[]
      vehicle: Prisma.$vehiclesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      propertyId: string
      vehicleId: string | null
      startTime: Date
      endTime: Date
      status: $Enums.BookingStatus
      parkingType: $Enums.SlotType
      bookingType: string
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bookings"]>
    composites: {}
  }

  type bookingsGetPayload<S extends boolean | null | undefined | bookingsDefaultArgs> = $Result.GetResult<Prisma.$bookingsPayload, S>

  type bookingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bookingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingsCountAggregateInputType | true
    }

  export interface bookingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bookings'], meta: { name: 'bookings' } }
    /**
     * Find zero or one Bookings that matches the filter.
     * @param {bookingsFindUniqueArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bookingsFindUniqueArgs>(args: SelectSubset<T, bookingsFindUniqueArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bookings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {bookingsFindUniqueOrThrowArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bookingsFindUniqueOrThrowArgs>(args: SelectSubset<T, bookingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsFindFirstArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bookingsFindFirstArgs>(args?: SelectSubset<T, bookingsFindFirstArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bookings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsFindFirstOrThrowArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bookingsFindFirstOrThrowArgs>(args?: SelectSubset<T, bookingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.bookings.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.bookings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingsWithIdOnly = await prisma.bookings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bookingsFindManyArgs>(args?: SelectSubset<T, bookingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bookings.
     * @param {bookingsCreateArgs} args - Arguments to create a Bookings.
     * @example
     * // Create one Bookings
     * const Bookings = await prisma.bookings.create({
     *   data: {
     *     // ... data to create a Bookings
     *   }
     * })
     * 
     */
    create<T extends bookingsCreateArgs>(args: SelectSubset<T, bookingsCreateArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {bookingsCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const bookings = await prisma.bookings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bookingsCreateManyArgs>(args?: SelectSubset<T, bookingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {bookingsCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const bookings = await prisma.bookings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingsWithIdOnly = await prisma.bookings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bookingsCreateManyAndReturnArgs>(args?: SelectSubset<T, bookingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bookings.
     * @param {bookingsDeleteArgs} args - Arguments to delete one Bookings.
     * @example
     * // Delete one Bookings
     * const Bookings = await prisma.bookings.delete({
     *   where: {
     *     // ... filter to delete one Bookings
     *   }
     * })
     * 
     */
    delete<T extends bookingsDeleteArgs>(args: SelectSubset<T, bookingsDeleteArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bookings.
     * @param {bookingsUpdateArgs} args - Arguments to update one Bookings.
     * @example
     * // Update one Bookings
     * const bookings = await prisma.bookings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bookingsUpdateArgs>(args: SelectSubset<T, bookingsUpdateArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {bookingsDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.bookings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bookingsDeleteManyArgs>(args?: SelectSubset<T, bookingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const bookings = await prisma.bookings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bookingsUpdateManyArgs>(args: SelectSubset<T, bookingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bookings.
     * @param {bookingsUpsertArgs} args - Arguments to update or create a Bookings.
     * @example
     * // Update or create a Bookings
     * const bookings = await prisma.bookings.upsert({
     *   create: {
     *     // ... data to create a Bookings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookings we want to update
     *   }
     * })
     */
    upsert<T extends bookingsUpsertArgs>(args: SelectSubset<T, bookingsUpsertArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.bookings.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends bookingsCountArgs>(
      args?: Subset<T, bookingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingsAggregateArgs>(args: Subset<T, BookingsAggregateArgs>): Prisma.PrismaPromise<GetBookingsAggregateType<T>>

    /**
     * Group by Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bookingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bookingsGroupByArgs['orderBy'] }
        : { orderBy?: bookingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bookingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bookings model
   */
  readonly fields: bookingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bookings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bookingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingSlots<T extends bookings$bookingSlotsArgs<ExtArgs> = {}>(args?: Subset<T, bookings$bookingSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "findMany"> | Null>
    customer<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends bookings$creatorArgs<ExtArgs> = {}>(args?: Subset<T, bookings$creatorArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    counterLogs<T extends bookings$counterLogsArgs<ExtArgs> = {}>(args?: Subset<T, bookings$counterLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$counter_transactionsPayload<ExtArgs>, T, "findMany"> | Null>
    paymentSummary<T extends bookings$paymentSummaryArgs<ExtArgs> = {}>(args?: Subset<T, bookings$paymentSummaryArgs<ExtArgs>>): Prisma__payment_summaryClient<$Result.GetResult<Prisma.$payment_summaryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    payments<T extends bookings$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, bookings$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany"> | Null>
    property<T extends propertiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, propertiesDefaultArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    statusHistory<T extends bookings$statusHistoryArgs<ExtArgs> = {}>(args?: Subset<T, bookings$statusHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_status_historyPayload<ExtArgs>, T, "findMany"> | Null>
    vehicle<T extends bookings$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, bookings$vehicleArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bookings model
   */ 
  interface bookingsFieldRefs {
    readonly id: FieldRef<"bookings", 'String'>
    readonly customerId: FieldRef<"bookings", 'String'>
    readonly propertyId: FieldRef<"bookings", 'String'>
    readonly vehicleId: FieldRef<"bookings", 'String'>
    readonly startTime: FieldRef<"bookings", 'DateTime'>
    readonly endTime: FieldRef<"bookings", 'DateTime'>
    readonly status: FieldRef<"bookings", 'BookingStatus'>
    readonly parkingType: FieldRef<"bookings", 'SlotType'>
    readonly bookingType: FieldRef<"bookings", 'String'>
    readonly createdBy: FieldRef<"bookings", 'String'>
    readonly createdAt: FieldRef<"bookings", 'DateTime'>
    readonly updatedAt: FieldRef<"bookings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bookings findUnique
   */
  export type bookingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where: bookingsWhereUniqueInput
  }

  /**
   * bookings findUniqueOrThrow
   */
  export type bookingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where: bookingsWhereUniqueInput
  }

  /**
   * bookings findFirst
   */
  export type bookingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where?: bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookings.
     */
    cursor?: bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookings.
     */
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * bookings findFirstOrThrow
   */
  export type bookingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where?: bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookings.
     */
    cursor?: bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookings.
     */
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * bookings findMany
   */
  export type bookingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where?: bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bookings.
     */
    cursor?: bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * bookings create
   */
  export type bookingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * The data needed to create a bookings.
     */
    data: XOR<bookingsCreateInput, bookingsUncheckedCreateInput>
  }

  /**
   * bookings createMany
   */
  export type bookingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bookings.
     */
    data: bookingsCreateManyInput | bookingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bookings createManyAndReturn
   */
  export type bookingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many bookings.
     */
    data: bookingsCreateManyInput | bookingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * bookings update
   */
  export type bookingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * The data needed to update a bookings.
     */
    data: XOR<bookingsUpdateInput, bookingsUncheckedUpdateInput>
    /**
     * Choose, which bookings to update.
     */
    where: bookingsWhereUniqueInput
  }

  /**
   * bookings updateMany
   */
  export type bookingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bookings.
     */
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyInput>
    /**
     * Filter which bookings to update
     */
    where?: bookingsWhereInput
  }

  /**
   * bookings upsert
   */
  export type bookingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * The filter to search for the bookings to update in case it exists.
     */
    where: bookingsWhereUniqueInput
    /**
     * In case the bookings found by the `where` argument doesn't exist, create a new bookings with this data.
     */
    create: XOR<bookingsCreateInput, bookingsUncheckedCreateInput>
    /**
     * In case the bookings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bookingsUpdateInput, bookingsUncheckedUpdateInput>
  }

  /**
   * bookings delete
   */
  export type bookingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter which bookings to delete.
     */
    where: bookingsWhereUniqueInput
  }

  /**
   * bookings deleteMany
   */
  export type bookingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookings to delete
     */
    where?: bookingsWhereInput
  }

  /**
   * bookings.bookingSlots
   */
  export type bookings$bookingSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsInclude<ExtArgs> | null
    where?: booking_slotsWhereInput
    orderBy?: booking_slotsOrderByWithRelationInput | booking_slotsOrderByWithRelationInput[]
    cursor?: booking_slotsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Booking_slotsScalarFieldEnum | Booking_slotsScalarFieldEnum[]
  }

  /**
   * bookings.creator
   */
  export type bookings$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * bookings.counterLogs
   */
  export type bookings$counterLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsInclude<ExtArgs> | null
    where?: counter_transactionsWhereInput
    orderBy?: counter_transactionsOrderByWithRelationInput | counter_transactionsOrderByWithRelationInput[]
    cursor?: counter_transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Counter_transactionsScalarFieldEnum | Counter_transactionsScalarFieldEnum[]
  }

  /**
   * bookings.paymentSummary
   */
  export type bookings$paymentSummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_summary
     */
    select?: payment_summarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_summaryInclude<ExtArgs> | null
    where?: payment_summaryWhereInput
  }

  /**
   * bookings.payments
   */
  export type bookings$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * bookings.statusHistory
   */
  export type bookings$statusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyInclude<ExtArgs> | null
    where?: booking_status_historyWhereInput
    orderBy?: booking_status_historyOrderByWithRelationInput | booking_status_historyOrderByWithRelationInput[]
    cursor?: booking_status_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Booking_status_historyScalarFieldEnum | Booking_status_historyScalarFieldEnum[]
  }

  /**
   * bookings.vehicle
   */
  export type bookings$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehiclesInclude<ExtArgs> | null
    where?: vehiclesWhereInput
  }

  /**
   * bookings without action
   */
  export type bookingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
  }


  /**
   * Model booking_slots
   */

  export type AggregateBooking_slots = {
    _count: Booking_slotsCountAggregateOutputType | null
    _min: Booking_slotsMinAggregateOutputType | null
    _max: Booking_slotsMaxAggregateOutputType | null
  }

  export type Booking_slotsMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    slotId: string | null
    createdAt: Date | null
  }

  export type Booking_slotsMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    slotId: string | null
    createdAt: Date | null
  }

  export type Booking_slotsCountAggregateOutputType = {
    id: number
    bookingId: number
    slotId: number
    createdAt: number
    _all: number
  }


  export type Booking_slotsMinAggregateInputType = {
    id?: true
    bookingId?: true
    slotId?: true
    createdAt?: true
  }

  export type Booking_slotsMaxAggregateInputType = {
    id?: true
    bookingId?: true
    slotId?: true
    createdAt?: true
  }

  export type Booking_slotsCountAggregateInputType = {
    id?: true
    bookingId?: true
    slotId?: true
    createdAt?: true
    _all?: true
  }

  export type Booking_slotsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which booking_slots to aggregate.
     */
    where?: booking_slotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_slots to fetch.
     */
    orderBy?: booking_slotsOrderByWithRelationInput | booking_slotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: booking_slotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned booking_slots
    **/
    _count?: true | Booking_slotsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Booking_slotsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Booking_slotsMaxAggregateInputType
  }

  export type GetBooking_slotsAggregateType<T extends Booking_slotsAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking_slots]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking_slots[P]>
      : GetScalarType<T[P], AggregateBooking_slots[P]>
  }




  export type booking_slotsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booking_slotsWhereInput
    orderBy?: booking_slotsOrderByWithAggregationInput | booking_slotsOrderByWithAggregationInput[]
    by: Booking_slotsScalarFieldEnum[] | Booking_slotsScalarFieldEnum
    having?: booking_slotsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Booking_slotsCountAggregateInputType | true
    _min?: Booking_slotsMinAggregateInputType
    _max?: Booking_slotsMaxAggregateInputType
  }

  export type Booking_slotsGroupByOutputType = {
    id: string
    bookingId: string
    slotId: string
    createdAt: Date
    _count: Booking_slotsCountAggregateOutputType | null
    _min: Booking_slotsMinAggregateOutputType | null
    _max: Booking_slotsMaxAggregateOutputType | null
  }

  type GetBooking_slotsGroupByPayload<T extends booking_slotsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Booking_slotsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Booking_slotsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Booking_slotsGroupByOutputType[P]>
            : GetScalarType<T[P], Booking_slotsGroupByOutputType[P]>
        }
      >
    >


  export type booking_slotsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    createdAt?: boolean
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    slot?: boolean | parking_slotsDefaultArgs<ExtArgs>
    washJob?: boolean | booking_slots$washJobArgs<ExtArgs>
  }, ExtArgs["result"]["booking_slots"]>

  export type booking_slotsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    createdAt?: boolean
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    slot?: boolean | parking_slotsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking_slots"]>

  export type booking_slotsSelectScalar = {
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    createdAt?: boolean
  }

  export type booking_slotsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    slot?: boolean | parking_slotsDefaultArgs<ExtArgs>
    washJob?: boolean | booking_slots$washJobArgs<ExtArgs>
  }
  export type booking_slotsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    slot?: boolean | parking_slotsDefaultArgs<ExtArgs>
  }

  export type $booking_slotsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "booking_slots"
    objects: {
      booking: Prisma.$bookingsPayload<ExtArgs>
      slot: Prisma.$parking_slotsPayload<ExtArgs>
      washJob: Prisma.$wash_jobsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      slotId: string
      createdAt: Date
    }, ExtArgs["result"]["booking_slots"]>
    composites: {}
  }

  type booking_slotsGetPayload<S extends boolean | null | undefined | booking_slotsDefaultArgs> = $Result.GetResult<Prisma.$booking_slotsPayload, S>

  type booking_slotsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<booking_slotsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Booking_slotsCountAggregateInputType | true
    }

  export interface booking_slotsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['booking_slots'], meta: { name: 'booking_slots' } }
    /**
     * Find zero or one Booking_slots that matches the filter.
     * @param {booking_slotsFindUniqueArgs} args - Arguments to find a Booking_slots
     * @example
     * // Get one Booking_slots
     * const booking_slots = await prisma.booking_slots.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends booking_slotsFindUniqueArgs>(args: SelectSubset<T, booking_slotsFindUniqueArgs<ExtArgs>>): Prisma__booking_slotsClient<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking_slots that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {booking_slotsFindUniqueOrThrowArgs} args - Arguments to find a Booking_slots
     * @example
     * // Get one Booking_slots
     * const booking_slots = await prisma.booking_slots.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends booking_slotsFindUniqueOrThrowArgs>(args: SelectSubset<T, booking_slotsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__booking_slotsClient<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking_slots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_slotsFindFirstArgs} args - Arguments to find a Booking_slots
     * @example
     * // Get one Booking_slots
     * const booking_slots = await prisma.booking_slots.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends booking_slotsFindFirstArgs>(args?: SelectSubset<T, booking_slotsFindFirstArgs<ExtArgs>>): Prisma__booking_slotsClient<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking_slots that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_slotsFindFirstOrThrowArgs} args - Arguments to find a Booking_slots
     * @example
     * // Get one Booking_slots
     * const booking_slots = await prisma.booking_slots.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends booking_slotsFindFirstOrThrowArgs>(args?: SelectSubset<T, booking_slotsFindFirstOrThrowArgs<ExtArgs>>): Prisma__booking_slotsClient<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Booking_slots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_slotsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Booking_slots
     * const booking_slots = await prisma.booking_slots.findMany()
     * 
     * // Get first 10 Booking_slots
     * const booking_slots = await prisma.booking_slots.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const booking_slotsWithIdOnly = await prisma.booking_slots.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends booking_slotsFindManyArgs>(args?: SelectSubset<T, booking_slotsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking_slots.
     * @param {booking_slotsCreateArgs} args - Arguments to create a Booking_slots.
     * @example
     * // Create one Booking_slots
     * const Booking_slots = await prisma.booking_slots.create({
     *   data: {
     *     // ... data to create a Booking_slots
     *   }
     * })
     * 
     */
    create<T extends booking_slotsCreateArgs>(args: SelectSubset<T, booking_slotsCreateArgs<ExtArgs>>): Prisma__booking_slotsClient<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Booking_slots.
     * @param {booking_slotsCreateManyArgs} args - Arguments to create many Booking_slots.
     * @example
     * // Create many Booking_slots
     * const booking_slots = await prisma.booking_slots.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends booking_slotsCreateManyArgs>(args?: SelectSubset<T, booking_slotsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Booking_slots and returns the data saved in the database.
     * @param {booking_slotsCreateManyAndReturnArgs} args - Arguments to create many Booking_slots.
     * @example
     * // Create many Booking_slots
     * const booking_slots = await prisma.booking_slots.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Booking_slots and only return the `id`
     * const booking_slotsWithIdOnly = await prisma.booking_slots.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends booking_slotsCreateManyAndReturnArgs>(args?: SelectSubset<T, booking_slotsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking_slots.
     * @param {booking_slotsDeleteArgs} args - Arguments to delete one Booking_slots.
     * @example
     * // Delete one Booking_slots
     * const Booking_slots = await prisma.booking_slots.delete({
     *   where: {
     *     // ... filter to delete one Booking_slots
     *   }
     * })
     * 
     */
    delete<T extends booking_slotsDeleteArgs>(args: SelectSubset<T, booking_slotsDeleteArgs<ExtArgs>>): Prisma__booking_slotsClient<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking_slots.
     * @param {booking_slotsUpdateArgs} args - Arguments to update one Booking_slots.
     * @example
     * // Update one Booking_slots
     * const booking_slots = await prisma.booking_slots.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends booking_slotsUpdateArgs>(args: SelectSubset<T, booking_slotsUpdateArgs<ExtArgs>>): Prisma__booking_slotsClient<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Booking_slots.
     * @param {booking_slotsDeleteManyArgs} args - Arguments to filter Booking_slots to delete.
     * @example
     * // Delete a few Booking_slots
     * const { count } = await prisma.booking_slots.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends booking_slotsDeleteManyArgs>(args?: SelectSubset<T, booking_slotsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Booking_slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_slotsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Booking_slots
     * const booking_slots = await prisma.booking_slots.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends booking_slotsUpdateManyArgs>(args: SelectSubset<T, booking_slotsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking_slots.
     * @param {booking_slotsUpsertArgs} args - Arguments to update or create a Booking_slots.
     * @example
     * // Update or create a Booking_slots
     * const booking_slots = await prisma.booking_slots.upsert({
     *   create: {
     *     // ... data to create a Booking_slots
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking_slots we want to update
     *   }
     * })
     */
    upsert<T extends booking_slotsUpsertArgs>(args: SelectSubset<T, booking_slotsUpsertArgs<ExtArgs>>): Prisma__booking_slotsClient<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Booking_slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_slotsCountArgs} args - Arguments to filter Booking_slots to count.
     * @example
     * // Count the number of Booking_slots
     * const count = await prisma.booking_slots.count({
     *   where: {
     *     // ... the filter for the Booking_slots we want to count
     *   }
     * })
    **/
    count<T extends booking_slotsCountArgs>(
      args?: Subset<T, booking_slotsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Booking_slotsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking_slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Booking_slotsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Booking_slotsAggregateArgs>(args: Subset<T, Booking_slotsAggregateArgs>): Prisma.PrismaPromise<GetBooking_slotsAggregateType<T>>

    /**
     * Group by Booking_slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_slotsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends booking_slotsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: booking_slotsGroupByArgs['orderBy'] }
        : { orderBy?: booking_slotsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, booking_slotsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBooking_slotsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the booking_slots model
   */
  readonly fields: booking_slotsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for booking_slots.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__booking_slotsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends bookingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingsDefaultArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    slot<T extends parking_slotsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, parking_slotsDefaultArgs<ExtArgs>>): Prisma__parking_slotsClient<$Result.GetResult<Prisma.$parking_slotsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    washJob<T extends booking_slots$washJobArgs<ExtArgs> = {}>(args?: Subset<T, booking_slots$washJobArgs<ExtArgs>>): Prisma__wash_jobsClient<$Result.GetResult<Prisma.$wash_jobsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the booking_slots model
   */ 
  interface booking_slotsFieldRefs {
    readonly id: FieldRef<"booking_slots", 'String'>
    readonly bookingId: FieldRef<"booking_slots", 'String'>
    readonly slotId: FieldRef<"booking_slots", 'String'>
    readonly createdAt: FieldRef<"booking_slots", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * booking_slots findUnique
   */
  export type booking_slotsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsInclude<ExtArgs> | null
    /**
     * Filter, which booking_slots to fetch.
     */
    where: booking_slotsWhereUniqueInput
  }

  /**
   * booking_slots findUniqueOrThrow
   */
  export type booking_slotsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsInclude<ExtArgs> | null
    /**
     * Filter, which booking_slots to fetch.
     */
    where: booking_slotsWhereUniqueInput
  }

  /**
   * booking_slots findFirst
   */
  export type booking_slotsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsInclude<ExtArgs> | null
    /**
     * Filter, which booking_slots to fetch.
     */
    where?: booking_slotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_slots to fetch.
     */
    orderBy?: booking_slotsOrderByWithRelationInput | booking_slotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for booking_slots.
     */
    cursor?: booking_slotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of booking_slots.
     */
    distinct?: Booking_slotsScalarFieldEnum | Booking_slotsScalarFieldEnum[]
  }

  /**
   * booking_slots findFirstOrThrow
   */
  export type booking_slotsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsInclude<ExtArgs> | null
    /**
     * Filter, which booking_slots to fetch.
     */
    where?: booking_slotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_slots to fetch.
     */
    orderBy?: booking_slotsOrderByWithRelationInput | booking_slotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for booking_slots.
     */
    cursor?: booking_slotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of booking_slots.
     */
    distinct?: Booking_slotsScalarFieldEnum | Booking_slotsScalarFieldEnum[]
  }

  /**
   * booking_slots findMany
   */
  export type booking_slotsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsInclude<ExtArgs> | null
    /**
     * Filter, which booking_slots to fetch.
     */
    where?: booking_slotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_slots to fetch.
     */
    orderBy?: booking_slotsOrderByWithRelationInput | booking_slotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing booking_slots.
     */
    cursor?: booking_slotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_slots.
     */
    skip?: number
    distinct?: Booking_slotsScalarFieldEnum | Booking_slotsScalarFieldEnum[]
  }

  /**
   * booking_slots create
   */
  export type booking_slotsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsInclude<ExtArgs> | null
    /**
     * The data needed to create a booking_slots.
     */
    data: XOR<booking_slotsCreateInput, booking_slotsUncheckedCreateInput>
  }

  /**
   * booking_slots createMany
   */
  export type booking_slotsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many booking_slots.
     */
    data: booking_slotsCreateManyInput | booking_slotsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * booking_slots createManyAndReturn
   */
  export type booking_slotsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many booking_slots.
     */
    data: booking_slotsCreateManyInput | booking_slotsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * booking_slots update
   */
  export type booking_slotsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsInclude<ExtArgs> | null
    /**
     * The data needed to update a booking_slots.
     */
    data: XOR<booking_slotsUpdateInput, booking_slotsUncheckedUpdateInput>
    /**
     * Choose, which booking_slots to update.
     */
    where: booking_slotsWhereUniqueInput
  }

  /**
   * booking_slots updateMany
   */
  export type booking_slotsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update booking_slots.
     */
    data: XOR<booking_slotsUpdateManyMutationInput, booking_slotsUncheckedUpdateManyInput>
    /**
     * Filter which booking_slots to update
     */
    where?: booking_slotsWhereInput
  }

  /**
   * booking_slots upsert
   */
  export type booking_slotsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsInclude<ExtArgs> | null
    /**
     * The filter to search for the booking_slots to update in case it exists.
     */
    where: booking_slotsWhereUniqueInput
    /**
     * In case the booking_slots found by the `where` argument doesn't exist, create a new booking_slots with this data.
     */
    create: XOR<booking_slotsCreateInput, booking_slotsUncheckedCreateInput>
    /**
     * In case the booking_slots was found with the provided `where` argument, update it with this data.
     */
    update: XOR<booking_slotsUpdateInput, booking_slotsUncheckedUpdateInput>
  }

  /**
   * booking_slots delete
   */
  export type booking_slotsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsInclude<ExtArgs> | null
    /**
     * Filter which booking_slots to delete.
     */
    where: booking_slotsWhereUniqueInput
  }

  /**
   * booking_slots deleteMany
   */
  export type booking_slotsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which booking_slots to delete
     */
    where?: booking_slotsWhereInput
  }

  /**
   * booking_slots.washJob
   */
  export type booking_slots$washJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsInclude<ExtArgs> | null
    where?: wash_jobsWhereInput
  }

  /**
   * booking_slots without action
   */
  export type booking_slotsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_slots
     */
    select?: booking_slotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_slotsInclude<ExtArgs> | null
  }


  /**
   * Model booking_status_history
   */

  export type AggregateBooking_status_history = {
    _count: Booking_status_historyCountAggregateOutputType | null
    _min: Booking_status_historyMinAggregateOutputType | null
    _max: Booking_status_historyMaxAggregateOutputType | null
  }

  export type Booking_status_historyMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    oldStatus: string | null
    newStatus: string | null
    changedBy: string | null
    note: string | null
    changedAt: Date | null
  }

  export type Booking_status_historyMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    oldStatus: string | null
    newStatus: string | null
    changedBy: string | null
    note: string | null
    changedAt: Date | null
  }

  export type Booking_status_historyCountAggregateOutputType = {
    id: number
    bookingId: number
    oldStatus: number
    newStatus: number
    changedBy: number
    note: number
    changedAt: number
    _all: number
  }


  export type Booking_status_historyMinAggregateInputType = {
    id?: true
    bookingId?: true
    oldStatus?: true
    newStatus?: true
    changedBy?: true
    note?: true
    changedAt?: true
  }

  export type Booking_status_historyMaxAggregateInputType = {
    id?: true
    bookingId?: true
    oldStatus?: true
    newStatus?: true
    changedBy?: true
    note?: true
    changedAt?: true
  }

  export type Booking_status_historyCountAggregateInputType = {
    id?: true
    bookingId?: true
    oldStatus?: true
    newStatus?: true
    changedBy?: true
    note?: true
    changedAt?: true
    _all?: true
  }

  export type Booking_status_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which booking_status_history to aggregate.
     */
    where?: booking_status_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_status_histories to fetch.
     */
    orderBy?: booking_status_historyOrderByWithRelationInput | booking_status_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: booking_status_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_status_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_status_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned booking_status_histories
    **/
    _count?: true | Booking_status_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Booking_status_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Booking_status_historyMaxAggregateInputType
  }

  export type GetBooking_status_historyAggregateType<T extends Booking_status_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking_status_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking_status_history[P]>
      : GetScalarType<T[P], AggregateBooking_status_history[P]>
  }




  export type booking_status_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: booking_status_historyWhereInput
    orderBy?: booking_status_historyOrderByWithAggregationInput | booking_status_historyOrderByWithAggregationInput[]
    by: Booking_status_historyScalarFieldEnum[] | Booking_status_historyScalarFieldEnum
    having?: booking_status_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Booking_status_historyCountAggregateInputType | true
    _min?: Booking_status_historyMinAggregateInputType
    _max?: Booking_status_historyMaxAggregateInputType
  }

  export type Booking_status_historyGroupByOutputType = {
    id: string
    bookingId: string
    oldStatus: string | null
    newStatus: string
    changedBy: string | null
    note: string | null
    changedAt: Date
    _count: Booking_status_historyCountAggregateOutputType | null
    _min: Booking_status_historyMinAggregateOutputType | null
    _max: Booking_status_historyMaxAggregateOutputType | null
  }

  type GetBooking_status_historyGroupByPayload<T extends booking_status_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Booking_status_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Booking_status_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Booking_status_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Booking_status_historyGroupByOutputType[P]>
        }
      >
    >


  export type booking_status_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    note?: boolean
    changedAt?: boolean
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    changer?: boolean | booking_status_history$changerArgs<ExtArgs>
  }, ExtArgs["result"]["booking_status_history"]>

  export type booking_status_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    note?: boolean
    changedAt?: boolean
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    changer?: boolean | booking_status_history$changerArgs<ExtArgs>
  }, ExtArgs["result"]["booking_status_history"]>

  export type booking_status_historySelectScalar = {
    id?: boolean
    bookingId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    note?: boolean
    changedAt?: boolean
  }

  export type booking_status_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    changer?: boolean | booking_status_history$changerArgs<ExtArgs>
  }
  export type booking_status_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    changer?: boolean | booking_status_history$changerArgs<ExtArgs>
  }

  export type $booking_status_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "booking_status_history"
    objects: {
      booking: Prisma.$bookingsPayload<ExtArgs>
      changer: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      oldStatus: string | null
      newStatus: string
      changedBy: string | null
      note: string | null
      changedAt: Date
    }, ExtArgs["result"]["booking_status_history"]>
    composites: {}
  }

  type booking_status_historyGetPayload<S extends boolean | null | undefined | booking_status_historyDefaultArgs> = $Result.GetResult<Prisma.$booking_status_historyPayload, S>

  type booking_status_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<booking_status_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Booking_status_historyCountAggregateInputType | true
    }

  export interface booking_status_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['booking_status_history'], meta: { name: 'booking_status_history' } }
    /**
     * Find zero or one Booking_status_history that matches the filter.
     * @param {booking_status_historyFindUniqueArgs} args - Arguments to find a Booking_status_history
     * @example
     * // Get one Booking_status_history
     * const booking_status_history = await prisma.booking_status_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends booking_status_historyFindUniqueArgs>(args: SelectSubset<T, booking_status_historyFindUniqueArgs<ExtArgs>>): Prisma__booking_status_historyClient<$Result.GetResult<Prisma.$booking_status_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking_status_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {booking_status_historyFindUniqueOrThrowArgs} args - Arguments to find a Booking_status_history
     * @example
     * // Get one Booking_status_history
     * const booking_status_history = await prisma.booking_status_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends booking_status_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, booking_status_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__booking_status_historyClient<$Result.GetResult<Prisma.$booking_status_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking_status_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_status_historyFindFirstArgs} args - Arguments to find a Booking_status_history
     * @example
     * // Get one Booking_status_history
     * const booking_status_history = await prisma.booking_status_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends booking_status_historyFindFirstArgs>(args?: SelectSubset<T, booking_status_historyFindFirstArgs<ExtArgs>>): Prisma__booking_status_historyClient<$Result.GetResult<Prisma.$booking_status_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking_status_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_status_historyFindFirstOrThrowArgs} args - Arguments to find a Booking_status_history
     * @example
     * // Get one Booking_status_history
     * const booking_status_history = await prisma.booking_status_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends booking_status_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, booking_status_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__booking_status_historyClient<$Result.GetResult<Prisma.$booking_status_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Booking_status_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_status_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Booking_status_histories
     * const booking_status_histories = await prisma.booking_status_history.findMany()
     * 
     * // Get first 10 Booking_status_histories
     * const booking_status_histories = await prisma.booking_status_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const booking_status_historyWithIdOnly = await prisma.booking_status_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends booking_status_historyFindManyArgs>(args?: SelectSubset<T, booking_status_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_status_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking_status_history.
     * @param {booking_status_historyCreateArgs} args - Arguments to create a Booking_status_history.
     * @example
     * // Create one Booking_status_history
     * const Booking_status_history = await prisma.booking_status_history.create({
     *   data: {
     *     // ... data to create a Booking_status_history
     *   }
     * })
     * 
     */
    create<T extends booking_status_historyCreateArgs>(args: SelectSubset<T, booking_status_historyCreateArgs<ExtArgs>>): Prisma__booking_status_historyClient<$Result.GetResult<Prisma.$booking_status_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Booking_status_histories.
     * @param {booking_status_historyCreateManyArgs} args - Arguments to create many Booking_status_histories.
     * @example
     * // Create many Booking_status_histories
     * const booking_status_history = await prisma.booking_status_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends booking_status_historyCreateManyArgs>(args?: SelectSubset<T, booking_status_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Booking_status_histories and returns the data saved in the database.
     * @param {booking_status_historyCreateManyAndReturnArgs} args - Arguments to create many Booking_status_histories.
     * @example
     * // Create many Booking_status_histories
     * const booking_status_history = await prisma.booking_status_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Booking_status_histories and only return the `id`
     * const booking_status_historyWithIdOnly = await prisma.booking_status_history.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends booking_status_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, booking_status_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$booking_status_historyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking_status_history.
     * @param {booking_status_historyDeleteArgs} args - Arguments to delete one Booking_status_history.
     * @example
     * // Delete one Booking_status_history
     * const Booking_status_history = await prisma.booking_status_history.delete({
     *   where: {
     *     // ... filter to delete one Booking_status_history
     *   }
     * })
     * 
     */
    delete<T extends booking_status_historyDeleteArgs>(args: SelectSubset<T, booking_status_historyDeleteArgs<ExtArgs>>): Prisma__booking_status_historyClient<$Result.GetResult<Prisma.$booking_status_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking_status_history.
     * @param {booking_status_historyUpdateArgs} args - Arguments to update one Booking_status_history.
     * @example
     * // Update one Booking_status_history
     * const booking_status_history = await prisma.booking_status_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends booking_status_historyUpdateArgs>(args: SelectSubset<T, booking_status_historyUpdateArgs<ExtArgs>>): Prisma__booking_status_historyClient<$Result.GetResult<Prisma.$booking_status_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Booking_status_histories.
     * @param {booking_status_historyDeleteManyArgs} args - Arguments to filter Booking_status_histories to delete.
     * @example
     * // Delete a few Booking_status_histories
     * const { count } = await prisma.booking_status_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends booking_status_historyDeleteManyArgs>(args?: SelectSubset<T, booking_status_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Booking_status_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_status_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Booking_status_histories
     * const booking_status_history = await prisma.booking_status_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends booking_status_historyUpdateManyArgs>(args: SelectSubset<T, booking_status_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking_status_history.
     * @param {booking_status_historyUpsertArgs} args - Arguments to update or create a Booking_status_history.
     * @example
     * // Update or create a Booking_status_history
     * const booking_status_history = await prisma.booking_status_history.upsert({
     *   create: {
     *     // ... data to create a Booking_status_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking_status_history we want to update
     *   }
     * })
     */
    upsert<T extends booking_status_historyUpsertArgs>(args: SelectSubset<T, booking_status_historyUpsertArgs<ExtArgs>>): Prisma__booking_status_historyClient<$Result.GetResult<Prisma.$booking_status_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Booking_status_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_status_historyCountArgs} args - Arguments to filter Booking_status_histories to count.
     * @example
     * // Count the number of Booking_status_histories
     * const count = await prisma.booking_status_history.count({
     *   where: {
     *     // ... the filter for the Booking_status_histories we want to count
     *   }
     * })
    **/
    count<T extends booking_status_historyCountArgs>(
      args?: Subset<T, booking_status_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Booking_status_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking_status_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Booking_status_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Booking_status_historyAggregateArgs>(args: Subset<T, Booking_status_historyAggregateArgs>): Prisma.PrismaPromise<GetBooking_status_historyAggregateType<T>>

    /**
     * Group by Booking_status_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booking_status_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends booking_status_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: booking_status_historyGroupByArgs['orderBy'] }
        : { orderBy?: booking_status_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, booking_status_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBooking_status_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the booking_status_history model
   */
  readonly fields: booking_status_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for booking_status_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__booking_status_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends bookingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingsDefaultArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changer<T extends booking_status_history$changerArgs<ExtArgs> = {}>(args?: Subset<T, booking_status_history$changerArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the booking_status_history model
   */ 
  interface booking_status_historyFieldRefs {
    readonly id: FieldRef<"booking_status_history", 'String'>
    readonly bookingId: FieldRef<"booking_status_history", 'String'>
    readonly oldStatus: FieldRef<"booking_status_history", 'String'>
    readonly newStatus: FieldRef<"booking_status_history", 'String'>
    readonly changedBy: FieldRef<"booking_status_history", 'String'>
    readonly note: FieldRef<"booking_status_history", 'String'>
    readonly changedAt: FieldRef<"booking_status_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * booking_status_history findUnique
   */
  export type booking_status_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyInclude<ExtArgs> | null
    /**
     * Filter, which booking_status_history to fetch.
     */
    where: booking_status_historyWhereUniqueInput
  }

  /**
   * booking_status_history findUniqueOrThrow
   */
  export type booking_status_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyInclude<ExtArgs> | null
    /**
     * Filter, which booking_status_history to fetch.
     */
    where: booking_status_historyWhereUniqueInput
  }

  /**
   * booking_status_history findFirst
   */
  export type booking_status_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyInclude<ExtArgs> | null
    /**
     * Filter, which booking_status_history to fetch.
     */
    where?: booking_status_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_status_histories to fetch.
     */
    orderBy?: booking_status_historyOrderByWithRelationInput | booking_status_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for booking_status_histories.
     */
    cursor?: booking_status_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_status_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_status_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of booking_status_histories.
     */
    distinct?: Booking_status_historyScalarFieldEnum | Booking_status_historyScalarFieldEnum[]
  }

  /**
   * booking_status_history findFirstOrThrow
   */
  export type booking_status_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyInclude<ExtArgs> | null
    /**
     * Filter, which booking_status_history to fetch.
     */
    where?: booking_status_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_status_histories to fetch.
     */
    orderBy?: booking_status_historyOrderByWithRelationInput | booking_status_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for booking_status_histories.
     */
    cursor?: booking_status_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_status_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_status_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of booking_status_histories.
     */
    distinct?: Booking_status_historyScalarFieldEnum | Booking_status_historyScalarFieldEnum[]
  }

  /**
   * booking_status_history findMany
   */
  export type booking_status_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyInclude<ExtArgs> | null
    /**
     * Filter, which booking_status_histories to fetch.
     */
    where?: booking_status_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booking_status_histories to fetch.
     */
    orderBy?: booking_status_historyOrderByWithRelationInput | booking_status_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing booking_status_histories.
     */
    cursor?: booking_status_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booking_status_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booking_status_histories.
     */
    skip?: number
    distinct?: Booking_status_historyScalarFieldEnum | Booking_status_historyScalarFieldEnum[]
  }

  /**
   * booking_status_history create
   */
  export type booking_status_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a booking_status_history.
     */
    data: XOR<booking_status_historyCreateInput, booking_status_historyUncheckedCreateInput>
  }

  /**
   * booking_status_history createMany
   */
  export type booking_status_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many booking_status_histories.
     */
    data: booking_status_historyCreateManyInput | booking_status_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * booking_status_history createManyAndReturn
   */
  export type booking_status_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many booking_status_histories.
     */
    data: booking_status_historyCreateManyInput | booking_status_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * booking_status_history update
   */
  export type booking_status_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a booking_status_history.
     */
    data: XOR<booking_status_historyUpdateInput, booking_status_historyUncheckedUpdateInput>
    /**
     * Choose, which booking_status_history to update.
     */
    where: booking_status_historyWhereUniqueInput
  }

  /**
   * booking_status_history updateMany
   */
  export type booking_status_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update booking_status_histories.
     */
    data: XOR<booking_status_historyUpdateManyMutationInput, booking_status_historyUncheckedUpdateManyInput>
    /**
     * Filter which booking_status_histories to update
     */
    where?: booking_status_historyWhereInput
  }

  /**
   * booking_status_history upsert
   */
  export type booking_status_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the booking_status_history to update in case it exists.
     */
    where: booking_status_historyWhereUniqueInput
    /**
     * In case the booking_status_history found by the `where` argument doesn't exist, create a new booking_status_history with this data.
     */
    create: XOR<booking_status_historyCreateInput, booking_status_historyUncheckedCreateInput>
    /**
     * In case the booking_status_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<booking_status_historyUpdateInput, booking_status_historyUncheckedUpdateInput>
  }

  /**
   * booking_status_history delete
   */
  export type booking_status_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyInclude<ExtArgs> | null
    /**
     * Filter which booking_status_history to delete.
     */
    where: booking_status_historyWhereUniqueInput
  }

  /**
   * booking_status_history deleteMany
   */
  export type booking_status_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which booking_status_histories to delete
     */
    where?: booking_status_historyWhereInput
  }

  /**
   * booking_status_history.changer
   */
  export type booking_status_history$changerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * booking_status_history without action
   */
  export type booking_status_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the booking_status_history
     */
    select?: booking_status_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: booking_status_historyInclude<ExtArgs> | null
  }


  /**
   * Model payment_summary
   */

  export type AggregatePayment_summary = {
    _count: Payment_summaryCountAggregateOutputType | null
    _avg: Payment_summaryAvgAggregateOutputType | null
    _sum: Payment_summarySumAggregateOutputType | null
    _min: Payment_summaryMinAggregateOutputType | null
    _max: Payment_summaryMaxAggregateOutputType | null
  }

  export type Payment_summaryAvgAggregateOutputType = {
    totalAmount: Decimal | null
    onlinePaid: Decimal | null
    cashPaid: Decimal | null
    balanceDue: Decimal | null
  }

  export type Payment_summarySumAggregateOutputType = {
    totalAmount: Decimal | null
    onlinePaid: Decimal | null
    cashPaid: Decimal | null
    balanceDue: Decimal | null
  }

  export type Payment_summaryMinAggregateOutputType = {
    bookingId: string | null
    totalAmount: Decimal | null
    onlinePaid: Decimal | null
    cashPaid: Decimal | null
    balanceDue: Decimal | null
    currency: string | null
    updatedAt: Date | null
  }

  export type Payment_summaryMaxAggregateOutputType = {
    bookingId: string | null
    totalAmount: Decimal | null
    onlinePaid: Decimal | null
    cashPaid: Decimal | null
    balanceDue: Decimal | null
    currency: string | null
    updatedAt: Date | null
  }

  export type Payment_summaryCountAggregateOutputType = {
    bookingId: number
    totalAmount: number
    onlinePaid: number
    cashPaid: number
    balanceDue: number
    currency: number
    updatedAt: number
    _all: number
  }


  export type Payment_summaryAvgAggregateInputType = {
    totalAmount?: true
    onlinePaid?: true
    cashPaid?: true
    balanceDue?: true
  }

  export type Payment_summarySumAggregateInputType = {
    totalAmount?: true
    onlinePaid?: true
    cashPaid?: true
    balanceDue?: true
  }

  export type Payment_summaryMinAggregateInputType = {
    bookingId?: true
    totalAmount?: true
    onlinePaid?: true
    cashPaid?: true
    balanceDue?: true
    currency?: true
    updatedAt?: true
  }

  export type Payment_summaryMaxAggregateInputType = {
    bookingId?: true
    totalAmount?: true
    onlinePaid?: true
    cashPaid?: true
    balanceDue?: true
    currency?: true
    updatedAt?: true
  }

  export type Payment_summaryCountAggregateInputType = {
    bookingId?: true
    totalAmount?: true
    onlinePaid?: true
    cashPaid?: true
    balanceDue?: true
    currency?: true
    updatedAt?: true
    _all?: true
  }

  export type Payment_summaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_summary to aggregate.
     */
    where?: payment_summaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_summaries to fetch.
     */
    orderBy?: payment_summaryOrderByWithRelationInput | payment_summaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_summaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_summaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_summaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_summaries
    **/
    _count?: true | Payment_summaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_summaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_summarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_summaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_summaryMaxAggregateInputType
  }

  export type GetPayment_summaryAggregateType<T extends Payment_summaryAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_summary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_summary[P]>
      : GetScalarType<T[P], AggregatePayment_summary[P]>
  }




  export type payment_summaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_summaryWhereInput
    orderBy?: payment_summaryOrderByWithAggregationInput | payment_summaryOrderByWithAggregationInput[]
    by: Payment_summaryScalarFieldEnum[] | Payment_summaryScalarFieldEnum
    having?: payment_summaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_summaryCountAggregateInputType | true
    _avg?: Payment_summaryAvgAggregateInputType
    _sum?: Payment_summarySumAggregateInputType
    _min?: Payment_summaryMinAggregateInputType
    _max?: Payment_summaryMaxAggregateInputType
  }

  export type Payment_summaryGroupByOutputType = {
    bookingId: string
    totalAmount: Decimal
    onlinePaid: Decimal
    cashPaid: Decimal
    balanceDue: Decimal
    currency: string
    updatedAt: Date
    _count: Payment_summaryCountAggregateOutputType | null
    _avg: Payment_summaryAvgAggregateOutputType | null
    _sum: Payment_summarySumAggregateOutputType | null
    _min: Payment_summaryMinAggregateOutputType | null
    _max: Payment_summaryMaxAggregateOutputType | null
  }

  type GetPayment_summaryGroupByPayload<T extends payment_summaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_summaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_summaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_summaryGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_summaryGroupByOutputType[P]>
        }
      >
    >


  export type payment_summarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bookingId?: boolean
    totalAmount?: boolean
    onlinePaid?: boolean
    cashPaid?: boolean
    balanceDue?: boolean
    currency?: boolean
    updatedAt?: boolean
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_summary"]>

  export type payment_summarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bookingId?: boolean
    totalAmount?: boolean
    onlinePaid?: boolean
    cashPaid?: boolean
    balanceDue?: boolean
    currency?: boolean
    updatedAt?: boolean
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_summary"]>

  export type payment_summarySelectScalar = {
    bookingId?: boolean
    totalAmount?: boolean
    onlinePaid?: boolean
    cashPaid?: boolean
    balanceDue?: boolean
    currency?: boolean
    updatedAt?: boolean
  }

  export type payment_summaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
  }
  export type payment_summaryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
  }

  export type $payment_summaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_summary"
    objects: {
      booking: Prisma.$bookingsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bookingId: string
      totalAmount: Prisma.Decimal
      onlinePaid: Prisma.Decimal
      cashPaid: Prisma.Decimal
      balanceDue: Prisma.Decimal
      currency: string
      updatedAt: Date
    }, ExtArgs["result"]["payment_summary"]>
    composites: {}
  }

  type payment_summaryGetPayload<S extends boolean | null | undefined | payment_summaryDefaultArgs> = $Result.GetResult<Prisma.$payment_summaryPayload, S>

  type payment_summaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<payment_summaryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Payment_summaryCountAggregateInputType | true
    }

  export interface payment_summaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_summary'], meta: { name: 'payment_summary' } }
    /**
     * Find zero or one Payment_summary that matches the filter.
     * @param {payment_summaryFindUniqueArgs} args - Arguments to find a Payment_summary
     * @example
     * // Get one Payment_summary
     * const payment_summary = await prisma.payment_summary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_summaryFindUniqueArgs>(args: SelectSubset<T, payment_summaryFindUniqueArgs<ExtArgs>>): Prisma__payment_summaryClient<$Result.GetResult<Prisma.$payment_summaryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment_summary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {payment_summaryFindUniqueOrThrowArgs} args - Arguments to find a Payment_summary
     * @example
     * // Get one Payment_summary
     * const payment_summary = await prisma.payment_summary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_summaryFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_summaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_summaryClient<$Result.GetResult<Prisma.$payment_summaryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment_summary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_summaryFindFirstArgs} args - Arguments to find a Payment_summary
     * @example
     * // Get one Payment_summary
     * const payment_summary = await prisma.payment_summary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_summaryFindFirstArgs>(args?: SelectSubset<T, payment_summaryFindFirstArgs<ExtArgs>>): Prisma__payment_summaryClient<$Result.GetResult<Prisma.$payment_summaryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment_summary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_summaryFindFirstOrThrowArgs} args - Arguments to find a Payment_summary
     * @example
     * // Get one Payment_summary
     * const payment_summary = await prisma.payment_summary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_summaryFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_summaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_summaryClient<$Result.GetResult<Prisma.$payment_summaryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payment_summaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_summaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_summaries
     * const payment_summaries = await prisma.payment_summary.findMany()
     * 
     * // Get first 10 Payment_summaries
     * const payment_summaries = await prisma.payment_summary.findMany({ take: 10 })
     * 
     * // Only select the `bookingId`
     * const payment_summaryWithBookingIdOnly = await prisma.payment_summary.findMany({ select: { bookingId: true } })
     * 
     */
    findMany<T extends payment_summaryFindManyArgs>(args?: SelectSubset<T, payment_summaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_summaryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment_summary.
     * @param {payment_summaryCreateArgs} args - Arguments to create a Payment_summary.
     * @example
     * // Create one Payment_summary
     * const Payment_summary = await prisma.payment_summary.create({
     *   data: {
     *     // ... data to create a Payment_summary
     *   }
     * })
     * 
     */
    create<T extends payment_summaryCreateArgs>(args: SelectSubset<T, payment_summaryCreateArgs<ExtArgs>>): Prisma__payment_summaryClient<$Result.GetResult<Prisma.$payment_summaryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payment_summaries.
     * @param {payment_summaryCreateManyArgs} args - Arguments to create many Payment_summaries.
     * @example
     * // Create many Payment_summaries
     * const payment_summary = await prisma.payment_summary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_summaryCreateManyArgs>(args?: SelectSubset<T, payment_summaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_summaries and returns the data saved in the database.
     * @param {payment_summaryCreateManyAndReturnArgs} args - Arguments to create many Payment_summaries.
     * @example
     * // Create many Payment_summaries
     * const payment_summary = await prisma.payment_summary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_summaries and only return the `bookingId`
     * const payment_summaryWithBookingIdOnly = await prisma.payment_summary.createManyAndReturn({ 
     *   select: { bookingId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_summaryCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_summaryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_summaryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment_summary.
     * @param {payment_summaryDeleteArgs} args - Arguments to delete one Payment_summary.
     * @example
     * // Delete one Payment_summary
     * const Payment_summary = await prisma.payment_summary.delete({
     *   where: {
     *     // ... filter to delete one Payment_summary
     *   }
     * })
     * 
     */
    delete<T extends payment_summaryDeleteArgs>(args: SelectSubset<T, payment_summaryDeleteArgs<ExtArgs>>): Prisma__payment_summaryClient<$Result.GetResult<Prisma.$payment_summaryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment_summary.
     * @param {payment_summaryUpdateArgs} args - Arguments to update one Payment_summary.
     * @example
     * // Update one Payment_summary
     * const payment_summary = await prisma.payment_summary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_summaryUpdateArgs>(args: SelectSubset<T, payment_summaryUpdateArgs<ExtArgs>>): Prisma__payment_summaryClient<$Result.GetResult<Prisma.$payment_summaryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payment_summaries.
     * @param {payment_summaryDeleteManyArgs} args - Arguments to filter Payment_summaries to delete.
     * @example
     * // Delete a few Payment_summaries
     * const { count } = await prisma.payment_summary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_summaryDeleteManyArgs>(args?: SelectSubset<T, payment_summaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_summaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_summaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_summaries
     * const payment_summary = await prisma.payment_summary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_summaryUpdateManyArgs>(args: SelectSubset<T, payment_summaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment_summary.
     * @param {payment_summaryUpsertArgs} args - Arguments to update or create a Payment_summary.
     * @example
     * // Update or create a Payment_summary
     * const payment_summary = await prisma.payment_summary.upsert({
     *   create: {
     *     // ... data to create a Payment_summary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_summary we want to update
     *   }
     * })
     */
    upsert<T extends payment_summaryUpsertArgs>(args: SelectSubset<T, payment_summaryUpsertArgs<ExtArgs>>): Prisma__payment_summaryClient<$Result.GetResult<Prisma.$payment_summaryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payment_summaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_summaryCountArgs} args - Arguments to filter Payment_summaries to count.
     * @example
     * // Count the number of Payment_summaries
     * const count = await prisma.payment_summary.count({
     *   where: {
     *     // ... the filter for the Payment_summaries we want to count
     *   }
     * })
    **/
    count<T extends payment_summaryCountArgs>(
      args?: Subset<T, payment_summaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_summaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_summary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_summaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_summaryAggregateArgs>(args: Subset<T, Payment_summaryAggregateArgs>): Prisma.PrismaPromise<GetPayment_summaryAggregateType<T>>

    /**
     * Group by Payment_summary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_summaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_summaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_summaryGroupByArgs['orderBy'] }
        : { orderBy?: payment_summaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_summaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_summaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_summary model
   */
  readonly fields: payment_summaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_summary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_summaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends bookingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingsDefaultArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_summary model
   */ 
  interface payment_summaryFieldRefs {
    readonly bookingId: FieldRef<"payment_summary", 'String'>
    readonly totalAmount: FieldRef<"payment_summary", 'Decimal'>
    readonly onlinePaid: FieldRef<"payment_summary", 'Decimal'>
    readonly cashPaid: FieldRef<"payment_summary", 'Decimal'>
    readonly balanceDue: FieldRef<"payment_summary", 'Decimal'>
    readonly currency: FieldRef<"payment_summary", 'String'>
    readonly updatedAt: FieldRef<"payment_summary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payment_summary findUnique
   */
  export type payment_summaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_summary
     */
    select?: payment_summarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_summaryInclude<ExtArgs> | null
    /**
     * Filter, which payment_summary to fetch.
     */
    where: payment_summaryWhereUniqueInput
  }

  /**
   * payment_summary findUniqueOrThrow
   */
  export type payment_summaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_summary
     */
    select?: payment_summarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_summaryInclude<ExtArgs> | null
    /**
     * Filter, which payment_summary to fetch.
     */
    where: payment_summaryWhereUniqueInput
  }

  /**
   * payment_summary findFirst
   */
  export type payment_summaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_summary
     */
    select?: payment_summarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_summaryInclude<ExtArgs> | null
    /**
     * Filter, which payment_summary to fetch.
     */
    where?: payment_summaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_summaries to fetch.
     */
    orderBy?: payment_summaryOrderByWithRelationInput | payment_summaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_summaries.
     */
    cursor?: payment_summaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_summaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_summaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_summaries.
     */
    distinct?: Payment_summaryScalarFieldEnum | Payment_summaryScalarFieldEnum[]
  }

  /**
   * payment_summary findFirstOrThrow
   */
  export type payment_summaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_summary
     */
    select?: payment_summarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_summaryInclude<ExtArgs> | null
    /**
     * Filter, which payment_summary to fetch.
     */
    where?: payment_summaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_summaries to fetch.
     */
    orderBy?: payment_summaryOrderByWithRelationInput | payment_summaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_summaries.
     */
    cursor?: payment_summaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_summaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_summaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_summaries.
     */
    distinct?: Payment_summaryScalarFieldEnum | Payment_summaryScalarFieldEnum[]
  }

  /**
   * payment_summary findMany
   */
  export type payment_summaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_summary
     */
    select?: payment_summarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_summaryInclude<ExtArgs> | null
    /**
     * Filter, which payment_summaries to fetch.
     */
    where?: payment_summaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_summaries to fetch.
     */
    orderBy?: payment_summaryOrderByWithRelationInput | payment_summaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_summaries.
     */
    cursor?: payment_summaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_summaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_summaries.
     */
    skip?: number
    distinct?: Payment_summaryScalarFieldEnum | Payment_summaryScalarFieldEnum[]
  }

  /**
   * payment_summary create
   */
  export type payment_summaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_summary
     */
    select?: payment_summarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_summaryInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_summary.
     */
    data: XOR<payment_summaryCreateInput, payment_summaryUncheckedCreateInput>
  }

  /**
   * payment_summary createMany
   */
  export type payment_summaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_summaries.
     */
    data: payment_summaryCreateManyInput | payment_summaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_summary createManyAndReturn
   */
  export type payment_summaryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_summary
     */
    select?: payment_summarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many payment_summaries.
     */
    data: payment_summaryCreateManyInput | payment_summaryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_summaryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment_summary update
   */
  export type payment_summaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_summary
     */
    select?: payment_summarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_summaryInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_summary.
     */
    data: XOR<payment_summaryUpdateInput, payment_summaryUncheckedUpdateInput>
    /**
     * Choose, which payment_summary to update.
     */
    where: payment_summaryWhereUniqueInput
  }

  /**
   * payment_summary updateMany
   */
  export type payment_summaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_summaries.
     */
    data: XOR<payment_summaryUpdateManyMutationInput, payment_summaryUncheckedUpdateManyInput>
    /**
     * Filter which payment_summaries to update
     */
    where?: payment_summaryWhereInput
  }

  /**
   * payment_summary upsert
   */
  export type payment_summaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_summary
     */
    select?: payment_summarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_summaryInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_summary to update in case it exists.
     */
    where: payment_summaryWhereUniqueInput
    /**
     * In case the payment_summary found by the `where` argument doesn't exist, create a new payment_summary with this data.
     */
    create: XOR<payment_summaryCreateInput, payment_summaryUncheckedCreateInput>
    /**
     * In case the payment_summary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_summaryUpdateInput, payment_summaryUncheckedUpdateInput>
  }

  /**
   * payment_summary delete
   */
  export type payment_summaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_summary
     */
    select?: payment_summarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_summaryInclude<ExtArgs> | null
    /**
     * Filter which payment_summary to delete.
     */
    where: payment_summaryWhereUniqueInput
  }

  /**
   * payment_summary deleteMany
   */
  export type payment_summaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_summaries to delete
     */
    where?: payment_summaryWhereInput
  }

  /**
   * payment_summary without action
   */
  export type payment_summaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_summary
     */
    select?: payment_summarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_summaryInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    amount: Decimal | null
    cardExpMonth: number | null
    cardExpYear: number | null
  }

  export type PaymentsSumAggregateOutputType = {
    amount: Decimal | null
    cardExpMonth: number | null
    cardExpYear: number | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    payerId: string | null
    amount: Decimal | null
    currency: string | null
    method: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus | null
    gatewayStatus: $Enums.GatewayStatus | null
    gatewayProvider: string | null
    transactionId: string | null
    cardLast4: string | null
    cardBrand: string | null
    cardExpMonth: number | null
    cardExpYear: number | null
    paidAt: Date | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    payerId: string | null
    amount: Decimal | null
    currency: string | null
    method: $Enums.PaymentMethod | null
    paymentStatus: $Enums.PaymentStatus | null
    gatewayStatus: $Enums.GatewayStatus | null
    gatewayProvider: string | null
    transactionId: string | null
    cardLast4: string | null
    cardBrand: string | null
    cardExpMonth: number | null
    cardExpYear: number | null
    paidAt: Date | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    bookingId: number
    payerId: number
    amount: number
    currency: number
    method: number
    paymentStatus: number
    gatewayStatus: number
    gatewayProvider: number
    transactionId: number
    cardLast4: number
    cardBrand: number
    cardExpMonth: number
    cardExpYear: number
    paidAt: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    amount?: true
    cardExpMonth?: true
    cardExpYear?: true
  }

  export type PaymentsSumAggregateInputType = {
    amount?: true
    cardExpMonth?: true
    cardExpYear?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    bookingId?: true
    payerId?: true
    amount?: true
    currency?: true
    method?: true
    paymentStatus?: true
    gatewayStatus?: true
    gatewayProvider?: true
    transactionId?: true
    cardLast4?: true
    cardBrand?: true
    cardExpMonth?: true
    cardExpYear?: true
    paidAt?: true
    createdBy?: true
    createdAt?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    bookingId?: true
    payerId?: true
    amount?: true
    currency?: true
    method?: true
    paymentStatus?: true
    gatewayStatus?: true
    gatewayProvider?: true
    transactionId?: true
    cardLast4?: true
    cardBrand?: true
    cardExpMonth?: true
    cardExpYear?: true
    paidAt?: true
    createdBy?: true
    createdAt?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    bookingId?: true
    payerId?: true
    amount?: true
    currency?: true
    method?: true
    paymentStatus?: true
    gatewayStatus?: true
    gatewayProvider?: true
    transactionId?: true
    cardLast4?: true
    cardBrand?: true
    cardExpMonth?: true
    cardExpYear?: true
    paidAt?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: string
    bookingId: string
    payerId: string
    amount: Decimal
    currency: string
    method: $Enums.PaymentMethod
    paymentStatus: $Enums.PaymentStatus
    gatewayStatus: $Enums.GatewayStatus
    gatewayProvider: string | null
    transactionId: string | null
    cardLast4: string | null
    cardBrand: string | null
    cardExpMonth: number | null
    cardExpYear: number | null
    paidAt: Date | null
    createdBy: string | null
    createdAt: Date
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    payerId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    paymentStatus?: boolean
    gatewayStatus?: boolean
    gatewayProvider?: boolean
    transactionId?: boolean
    cardLast4?: boolean
    cardBrand?: boolean
    cardExpMonth?: boolean
    cardExpYear?: boolean
    paidAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    creator?: boolean | payments$creatorArgs<ExtArgs>
    payer?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    payerId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    paymentStatus?: boolean
    gatewayStatus?: boolean
    gatewayProvider?: boolean
    transactionId?: boolean
    cardLast4?: boolean
    cardBrand?: boolean
    cardExpMonth?: boolean
    cardExpYear?: boolean
    paidAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    creator?: boolean | payments$creatorArgs<ExtArgs>
    payer?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    bookingId?: boolean
    payerId?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    paymentStatus?: boolean
    gatewayStatus?: boolean
    gatewayProvider?: boolean
    transactionId?: boolean
    cardLast4?: boolean
    cardBrand?: boolean
    cardExpMonth?: boolean
    cardExpYear?: boolean
    paidAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    creator?: boolean | payments$creatorArgs<ExtArgs>
    payer?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    creator?: boolean | payments$creatorArgs<ExtArgs>
    payer?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      booking: Prisma.$bookingsPayload<ExtArgs>
      creator: Prisma.$usersPayload<ExtArgs> | null
      payer: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      payerId: string
      amount: Prisma.Decimal
      currency: string
      method: $Enums.PaymentMethod
      paymentStatus: $Enums.PaymentStatus
      gatewayStatus: $Enums.GatewayStatus
      gatewayProvider: string | null
      transactionId: string | null
      cardLast4: string | null
      cardBrand: string | null
      cardExpMonth: number | null
      cardExpYear: number | null
      paidAt: Date | null
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends bookingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingsDefaultArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends payments$creatorArgs<ExtArgs> = {}>(args?: Subset<T, payments$creatorArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    payer<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */ 
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'String'>
    readonly bookingId: FieldRef<"payments", 'String'>
    readonly payerId: FieldRef<"payments", 'String'>
    readonly amount: FieldRef<"payments", 'Decimal'>
    readonly currency: FieldRef<"payments", 'String'>
    readonly method: FieldRef<"payments", 'PaymentMethod'>
    readonly paymentStatus: FieldRef<"payments", 'PaymentStatus'>
    readonly gatewayStatus: FieldRef<"payments", 'GatewayStatus'>
    readonly gatewayProvider: FieldRef<"payments", 'String'>
    readonly transactionId: FieldRef<"payments", 'String'>
    readonly cardLast4: FieldRef<"payments", 'String'>
    readonly cardBrand: FieldRef<"payments", 'String'>
    readonly cardExpMonth: FieldRef<"payments", 'Int'>
    readonly cardExpYear: FieldRef<"payments", 'Int'>
    readonly paidAt: FieldRef<"payments", 'DateTime'>
    readonly createdBy: FieldRef<"payments", 'String'>
    readonly createdAt: FieldRef<"payments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
  }

  /**
   * payments.creator
   */
  export type payments$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model wash_jobs
   */

  export type AggregateWash_jobs = {
    _count: Wash_jobsCountAggregateOutputType | null
    _min: Wash_jobsMinAggregateOutputType | null
    _max: Wash_jobsMaxAggregateOutputType | null
  }

  export type Wash_jobsMinAggregateOutputType = {
    id: string | null
    bookingSlotId: string | null
    washerId: string | null
    status: $Enums.WashStatus | null
    acceptedAt: Date | null
    completedAt: Date | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Wash_jobsMaxAggregateOutputType = {
    id: string | null
    bookingSlotId: string | null
    washerId: string | null
    status: $Enums.WashStatus | null
    acceptedAt: Date | null
    completedAt: Date | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Wash_jobsCountAggregateOutputType = {
    id: number
    bookingSlotId: number
    washerId: number
    status: number
    acceptedAt: number
    completedAt: number
    note: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Wash_jobsMinAggregateInputType = {
    id?: true
    bookingSlotId?: true
    washerId?: true
    status?: true
    acceptedAt?: true
    completedAt?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Wash_jobsMaxAggregateInputType = {
    id?: true
    bookingSlotId?: true
    washerId?: true
    status?: true
    acceptedAt?: true
    completedAt?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Wash_jobsCountAggregateInputType = {
    id?: true
    bookingSlotId?: true
    washerId?: true
    status?: true
    acceptedAt?: true
    completedAt?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Wash_jobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wash_jobs to aggregate.
     */
    where?: wash_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wash_jobs to fetch.
     */
    orderBy?: wash_jobsOrderByWithRelationInput | wash_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wash_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wash_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wash_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wash_jobs
    **/
    _count?: true | Wash_jobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wash_jobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wash_jobsMaxAggregateInputType
  }

  export type GetWash_jobsAggregateType<T extends Wash_jobsAggregateArgs> = {
        [P in keyof T & keyof AggregateWash_jobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWash_jobs[P]>
      : GetScalarType<T[P], AggregateWash_jobs[P]>
  }




  export type wash_jobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wash_jobsWhereInput
    orderBy?: wash_jobsOrderByWithAggregationInput | wash_jobsOrderByWithAggregationInput[]
    by: Wash_jobsScalarFieldEnum[] | Wash_jobsScalarFieldEnum
    having?: wash_jobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wash_jobsCountAggregateInputType | true
    _min?: Wash_jobsMinAggregateInputType
    _max?: Wash_jobsMaxAggregateInputType
  }

  export type Wash_jobsGroupByOutputType = {
    id: string
    bookingSlotId: string
    washerId: string | null
    status: $Enums.WashStatus
    acceptedAt: Date | null
    completedAt: Date | null
    note: string | null
    createdAt: Date
    updatedAt: Date
    _count: Wash_jobsCountAggregateOutputType | null
    _min: Wash_jobsMinAggregateOutputType | null
    _max: Wash_jobsMaxAggregateOutputType | null
  }

  type GetWash_jobsGroupByPayload<T extends wash_jobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Wash_jobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wash_jobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wash_jobsGroupByOutputType[P]>
            : GetScalarType<T[P], Wash_jobsGroupByOutputType[P]>
        }
      >
    >


  export type wash_jobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingSlotId?: boolean
    washerId?: boolean
    status?: boolean
    acceptedAt?: boolean
    completedAt?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingSlot?: boolean | booking_slotsDefaultArgs<ExtArgs>
    washer?: boolean | wash_jobs$washerArgs<ExtArgs>
  }, ExtArgs["result"]["wash_jobs"]>

  export type wash_jobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingSlotId?: boolean
    washerId?: boolean
    status?: boolean
    acceptedAt?: boolean
    completedAt?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingSlot?: boolean | booking_slotsDefaultArgs<ExtArgs>
    washer?: boolean | wash_jobs$washerArgs<ExtArgs>
  }, ExtArgs["result"]["wash_jobs"]>

  export type wash_jobsSelectScalar = {
    id?: boolean
    bookingSlotId?: boolean
    washerId?: boolean
    status?: boolean
    acceptedAt?: boolean
    completedAt?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type wash_jobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingSlot?: boolean | booking_slotsDefaultArgs<ExtArgs>
    washer?: boolean | wash_jobs$washerArgs<ExtArgs>
  }
  export type wash_jobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingSlot?: boolean | booking_slotsDefaultArgs<ExtArgs>
    washer?: boolean | wash_jobs$washerArgs<ExtArgs>
  }

  export type $wash_jobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wash_jobs"
    objects: {
      bookingSlot: Prisma.$booking_slotsPayload<ExtArgs>
      washer: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingSlotId: string
      washerId: string | null
      status: $Enums.WashStatus
      acceptedAt: Date | null
      completedAt: Date | null
      note: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wash_jobs"]>
    composites: {}
  }

  type wash_jobsGetPayload<S extends boolean | null | undefined | wash_jobsDefaultArgs> = $Result.GetResult<Prisma.$wash_jobsPayload, S>

  type wash_jobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<wash_jobsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Wash_jobsCountAggregateInputType | true
    }

  export interface wash_jobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wash_jobs'], meta: { name: 'wash_jobs' } }
    /**
     * Find zero or one Wash_jobs that matches the filter.
     * @param {wash_jobsFindUniqueArgs} args - Arguments to find a Wash_jobs
     * @example
     * // Get one Wash_jobs
     * const wash_jobs = await prisma.wash_jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wash_jobsFindUniqueArgs>(args: SelectSubset<T, wash_jobsFindUniqueArgs<ExtArgs>>): Prisma__wash_jobsClient<$Result.GetResult<Prisma.$wash_jobsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wash_jobs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {wash_jobsFindUniqueOrThrowArgs} args - Arguments to find a Wash_jobs
     * @example
     * // Get one Wash_jobs
     * const wash_jobs = await prisma.wash_jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wash_jobsFindUniqueOrThrowArgs>(args: SelectSubset<T, wash_jobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wash_jobsClient<$Result.GetResult<Prisma.$wash_jobsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wash_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wash_jobsFindFirstArgs} args - Arguments to find a Wash_jobs
     * @example
     * // Get one Wash_jobs
     * const wash_jobs = await prisma.wash_jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wash_jobsFindFirstArgs>(args?: SelectSubset<T, wash_jobsFindFirstArgs<ExtArgs>>): Prisma__wash_jobsClient<$Result.GetResult<Prisma.$wash_jobsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wash_jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wash_jobsFindFirstOrThrowArgs} args - Arguments to find a Wash_jobs
     * @example
     * // Get one Wash_jobs
     * const wash_jobs = await prisma.wash_jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wash_jobsFindFirstOrThrowArgs>(args?: SelectSubset<T, wash_jobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__wash_jobsClient<$Result.GetResult<Prisma.$wash_jobsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wash_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wash_jobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wash_jobs
     * const wash_jobs = await prisma.wash_jobs.findMany()
     * 
     * // Get first 10 Wash_jobs
     * const wash_jobs = await prisma.wash_jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wash_jobsWithIdOnly = await prisma.wash_jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wash_jobsFindManyArgs>(args?: SelectSubset<T, wash_jobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wash_jobsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wash_jobs.
     * @param {wash_jobsCreateArgs} args - Arguments to create a Wash_jobs.
     * @example
     * // Create one Wash_jobs
     * const Wash_jobs = await prisma.wash_jobs.create({
     *   data: {
     *     // ... data to create a Wash_jobs
     *   }
     * })
     * 
     */
    create<T extends wash_jobsCreateArgs>(args: SelectSubset<T, wash_jobsCreateArgs<ExtArgs>>): Prisma__wash_jobsClient<$Result.GetResult<Prisma.$wash_jobsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wash_jobs.
     * @param {wash_jobsCreateManyArgs} args - Arguments to create many Wash_jobs.
     * @example
     * // Create many Wash_jobs
     * const wash_jobs = await prisma.wash_jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wash_jobsCreateManyArgs>(args?: SelectSubset<T, wash_jobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wash_jobs and returns the data saved in the database.
     * @param {wash_jobsCreateManyAndReturnArgs} args - Arguments to create many Wash_jobs.
     * @example
     * // Create many Wash_jobs
     * const wash_jobs = await prisma.wash_jobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wash_jobs and only return the `id`
     * const wash_jobsWithIdOnly = await prisma.wash_jobs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends wash_jobsCreateManyAndReturnArgs>(args?: SelectSubset<T, wash_jobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wash_jobsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Wash_jobs.
     * @param {wash_jobsDeleteArgs} args - Arguments to delete one Wash_jobs.
     * @example
     * // Delete one Wash_jobs
     * const Wash_jobs = await prisma.wash_jobs.delete({
     *   where: {
     *     // ... filter to delete one Wash_jobs
     *   }
     * })
     * 
     */
    delete<T extends wash_jobsDeleteArgs>(args: SelectSubset<T, wash_jobsDeleteArgs<ExtArgs>>): Prisma__wash_jobsClient<$Result.GetResult<Prisma.$wash_jobsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wash_jobs.
     * @param {wash_jobsUpdateArgs} args - Arguments to update one Wash_jobs.
     * @example
     * // Update one Wash_jobs
     * const wash_jobs = await prisma.wash_jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wash_jobsUpdateArgs>(args: SelectSubset<T, wash_jobsUpdateArgs<ExtArgs>>): Prisma__wash_jobsClient<$Result.GetResult<Prisma.$wash_jobsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wash_jobs.
     * @param {wash_jobsDeleteManyArgs} args - Arguments to filter Wash_jobs to delete.
     * @example
     * // Delete a few Wash_jobs
     * const { count } = await prisma.wash_jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wash_jobsDeleteManyArgs>(args?: SelectSubset<T, wash_jobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wash_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wash_jobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wash_jobs
     * const wash_jobs = await prisma.wash_jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wash_jobsUpdateManyArgs>(args: SelectSubset<T, wash_jobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wash_jobs.
     * @param {wash_jobsUpsertArgs} args - Arguments to update or create a Wash_jobs.
     * @example
     * // Update or create a Wash_jobs
     * const wash_jobs = await prisma.wash_jobs.upsert({
     *   create: {
     *     // ... data to create a Wash_jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wash_jobs we want to update
     *   }
     * })
     */
    upsert<T extends wash_jobsUpsertArgs>(args: SelectSubset<T, wash_jobsUpsertArgs<ExtArgs>>): Prisma__wash_jobsClient<$Result.GetResult<Prisma.$wash_jobsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wash_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wash_jobsCountArgs} args - Arguments to filter Wash_jobs to count.
     * @example
     * // Count the number of Wash_jobs
     * const count = await prisma.wash_jobs.count({
     *   where: {
     *     // ... the filter for the Wash_jobs we want to count
     *   }
     * })
    **/
    count<T extends wash_jobsCountArgs>(
      args?: Subset<T, wash_jobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wash_jobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wash_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wash_jobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wash_jobsAggregateArgs>(args: Subset<T, Wash_jobsAggregateArgs>): Prisma.PrismaPromise<GetWash_jobsAggregateType<T>>

    /**
     * Group by Wash_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wash_jobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wash_jobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wash_jobsGroupByArgs['orderBy'] }
        : { orderBy?: wash_jobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wash_jobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWash_jobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wash_jobs model
   */
  readonly fields: wash_jobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wash_jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wash_jobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingSlot<T extends booking_slotsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, booking_slotsDefaultArgs<ExtArgs>>): Prisma__booking_slotsClient<$Result.GetResult<Prisma.$booking_slotsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    washer<T extends wash_jobs$washerArgs<ExtArgs> = {}>(args?: Subset<T, wash_jobs$washerArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wash_jobs model
   */ 
  interface wash_jobsFieldRefs {
    readonly id: FieldRef<"wash_jobs", 'String'>
    readonly bookingSlotId: FieldRef<"wash_jobs", 'String'>
    readonly washerId: FieldRef<"wash_jobs", 'String'>
    readonly status: FieldRef<"wash_jobs", 'WashStatus'>
    readonly acceptedAt: FieldRef<"wash_jobs", 'DateTime'>
    readonly completedAt: FieldRef<"wash_jobs", 'DateTime'>
    readonly note: FieldRef<"wash_jobs", 'String'>
    readonly createdAt: FieldRef<"wash_jobs", 'DateTime'>
    readonly updatedAt: FieldRef<"wash_jobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wash_jobs findUnique
   */
  export type wash_jobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsInclude<ExtArgs> | null
    /**
     * Filter, which wash_jobs to fetch.
     */
    where: wash_jobsWhereUniqueInput
  }

  /**
   * wash_jobs findUniqueOrThrow
   */
  export type wash_jobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsInclude<ExtArgs> | null
    /**
     * Filter, which wash_jobs to fetch.
     */
    where: wash_jobsWhereUniqueInput
  }

  /**
   * wash_jobs findFirst
   */
  export type wash_jobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsInclude<ExtArgs> | null
    /**
     * Filter, which wash_jobs to fetch.
     */
    where?: wash_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wash_jobs to fetch.
     */
    orderBy?: wash_jobsOrderByWithRelationInput | wash_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wash_jobs.
     */
    cursor?: wash_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wash_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wash_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wash_jobs.
     */
    distinct?: Wash_jobsScalarFieldEnum | Wash_jobsScalarFieldEnum[]
  }

  /**
   * wash_jobs findFirstOrThrow
   */
  export type wash_jobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsInclude<ExtArgs> | null
    /**
     * Filter, which wash_jobs to fetch.
     */
    where?: wash_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wash_jobs to fetch.
     */
    orderBy?: wash_jobsOrderByWithRelationInput | wash_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wash_jobs.
     */
    cursor?: wash_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wash_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wash_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wash_jobs.
     */
    distinct?: Wash_jobsScalarFieldEnum | Wash_jobsScalarFieldEnum[]
  }

  /**
   * wash_jobs findMany
   */
  export type wash_jobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsInclude<ExtArgs> | null
    /**
     * Filter, which wash_jobs to fetch.
     */
    where?: wash_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wash_jobs to fetch.
     */
    orderBy?: wash_jobsOrderByWithRelationInput | wash_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wash_jobs.
     */
    cursor?: wash_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wash_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wash_jobs.
     */
    skip?: number
    distinct?: Wash_jobsScalarFieldEnum | Wash_jobsScalarFieldEnum[]
  }

  /**
   * wash_jobs create
   */
  export type wash_jobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsInclude<ExtArgs> | null
    /**
     * The data needed to create a wash_jobs.
     */
    data: XOR<wash_jobsCreateInput, wash_jobsUncheckedCreateInput>
  }

  /**
   * wash_jobs createMany
   */
  export type wash_jobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wash_jobs.
     */
    data: wash_jobsCreateManyInput | wash_jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wash_jobs createManyAndReturn
   */
  export type wash_jobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many wash_jobs.
     */
    data: wash_jobsCreateManyInput | wash_jobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * wash_jobs update
   */
  export type wash_jobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsInclude<ExtArgs> | null
    /**
     * The data needed to update a wash_jobs.
     */
    data: XOR<wash_jobsUpdateInput, wash_jobsUncheckedUpdateInput>
    /**
     * Choose, which wash_jobs to update.
     */
    where: wash_jobsWhereUniqueInput
  }

  /**
   * wash_jobs updateMany
   */
  export type wash_jobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wash_jobs.
     */
    data: XOR<wash_jobsUpdateManyMutationInput, wash_jobsUncheckedUpdateManyInput>
    /**
     * Filter which wash_jobs to update
     */
    where?: wash_jobsWhereInput
  }

  /**
   * wash_jobs upsert
   */
  export type wash_jobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsInclude<ExtArgs> | null
    /**
     * The filter to search for the wash_jobs to update in case it exists.
     */
    where: wash_jobsWhereUniqueInput
    /**
     * In case the wash_jobs found by the `where` argument doesn't exist, create a new wash_jobs with this data.
     */
    create: XOR<wash_jobsCreateInput, wash_jobsUncheckedCreateInput>
    /**
     * In case the wash_jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wash_jobsUpdateInput, wash_jobsUncheckedUpdateInput>
  }

  /**
   * wash_jobs delete
   */
  export type wash_jobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsInclude<ExtArgs> | null
    /**
     * Filter which wash_jobs to delete.
     */
    where: wash_jobsWhereUniqueInput
  }

  /**
   * wash_jobs deleteMany
   */
  export type wash_jobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wash_jobs to delete
     */
    where?: wash_jobsWhereInput
  }

  /**
   * wash_jobs.washer
   */
  export type wash_jobs$washerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * wash_jobs without action
   */
  export type wash_jobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wash_jobs
     */
    select?: wash_jobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wash_jobsInclude<ExtArgs> | null
  }


  /**
   * Model counter_transactions
   */

  export type AggregateCounter_transactions = {
    _count: Counter_transactionsCountAggregateOutputType | null
    _min: Counter_transactionsMinAggregateOutputType | null
    _max: Counter_transactionsMaxAggregateOutputType | null
  }

  export type Counter_transactionsMinAggregateOutputType = {
    id: string | null
    counterUserId: string | null
    bookingId: string | null
    action: string | null
    note: string | null
    createdAt: Date | null
  }

  export type Counter_transactionsMaxAggregateOutputType = {
    id: string | null
    counterUserId: string | null
    bookingId: string | null
    action: string | null
    note: string | null
    createdAt: Date | null
  }

  export type Counter_transactionsCountAggregateOutputType = {
    id: number
    counterUserId: number
    bookingId: number
    action: number
    note: number
    createdAt: number
    _all: number
  }


  export type Counter_transactionsMinAggregateInputType = {
    id?: true
    counterUserId?: true
    bookingId?: true
    action?: true
    note?: true
    createdAt?: true
  }

  export type Counter_transactionsMaxAggregateInputType = {
    id?: true
    counterUserId?: true
    bookingId?: true
    action?: true
    note?: true
    createdAt?: true
  }

  export type Counter_transactionsCountAggregateInputType = {
    id?: true
    counterUserId?: true
    bookingId?: true
    action?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type Counter_transactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counter_transactions to aggregate.
     */
    where?: counter_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counter_transactions to fetch.
     */
    orderBy?: counter_transactionsOrderByWithRelationInput | counter_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: counter_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counter_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counter_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned counter_transactions
    **/
    _count?: true | Counter_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Counter_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Counter_transactionsMaxAggregateInputType
  }

  export type GetCounter_transactionsAggregateType<T extends Counter_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCounter_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounter_transactions[P]>
      : GetScalarType<T[P], AggregateCounter_transactions[P]>
  }




  export type counter_transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: counter_transactionsWhereInput
    orderBy?: counter_transactionsOrderByWithAggregationInput | counter_transactionsOrderByWithAggregationInput[]
    by: Counter_transactionsScalarFieldEnum[] | Counter_transactionsScalarFieldEnum
    having?: counter_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Counter_transactionsCountAggregateInputType | true
    _min?: Counter_transactionsMinAggregateInputType
    _max?: Counter_transactionsMaxAggregateInputType
  }

  export type Counter_transactionsGroupByOutputType = {
    id: string
    counterUserId: string
    bookingId: string
    action: string
    note: string | null
    createdAt: Date
    _count: Counter_transactionsCountAggregateOutputType | null
    _min: Counter_transactionsMinAggregateOutputType | null
    _max: Counter_transactionsMaxAggregateOutputType | null
  }

  type GetCounter_transactionsGroupByPayload<T extends counter_transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Counter_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Counter_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Counter_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Counter_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type counter_transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    counterUserId?: boolean
    bookingId?: boolean
    action?: boolean
    note?: boolean
    createdAt?: boolean
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    counterUser?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["counter_transactions"]>

  export type counter_transactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    counterUserId?: boolean
    bookingId?: boolean
    action?: boolean
    note?: boolean
    createdAt?: boolean
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    counterUser?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["counter_transactions"]>

  export type counter_transactionsSelectScalar = {
    id?: boolean
    counterUserId?: boolean
    bookingId?: boolean
    action?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type counter_transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    counterUser?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type counter_transactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    counterUser?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $counter_transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "counter_transactions"
    objects: {
      booking: Prisma.$bookingsPayload<ExtArgs>
      counterUser: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      counterUserId: string
      bookingId: string
      action: string
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["counter_transactions"]>
    composites: {}
  }

  type counter_transactionsGetPayload<S extends boolean | null | undefined | counter_transactionsDefaultArgs> = $Result.GetResult<Prisma.$counter_transactionsPayload, S>

  type counter_transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<counter_transactionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Counter_transactionsCountAggregateInputType | true
    }

  export interface counter_transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['counter_transactions'], meta: { name: 'counter_transactions' } }
    /**
     * Find zero or one Counter_transactions that matches the filter.
     * @param {counter_transactionsFindUniqueArgs} args - Arguments to find a Counter_transactions
     * @example
     * // Get one Counter_transactions
     * const counter_transactions = await prisma.counter_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends counter_transactionsFindUniqueArgs>(args: SelectSubset<T, counter_transactionsFindUniqueArgs<ExtArgs>>): Prisma__counter_transactionsClient<$Result.GetResult<Prisma.$counter_transactionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Counter_transactions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {counter_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Counter_transactions
     * @example
     * // Get one Counter_transactions
     * const counter_transactions = await prisma.counter_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends counter_transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, counter_transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__counter_transactionsClient<$Result.GetResult<Prisma.$counter_transactionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Counter_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counter_transactionsFindFirstArgs} args - Arguments to find a Counter_transactions
     * @example
     * // Get one Counter_transactions
     * const counter_transactions = await prisma.counter_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends counter_transactionsFindFirstArgs>(args?: SelectSubset<T, counter_transactionsFindFirstArgs<ExtArgs>>): Prisma__counter_transactionsClient<$Result.GetResult<Prisma.$counter_transactionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Counter_transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counter_transactionsFindFirstOrThrowArgs} args - Arguments to find a Counter_transactions
     * @example
     * // Get one Counter_transactions
     * const counter_transactions = await prisma.counter_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends counter_transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, counter_transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__counter_transactionsClient<$Result.GetResult<Prisma.$counter_transactionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Counter_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counter_transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counter_transactions
     * const counter_transactions = await prisma.counter_transactions.findMany()
     * 
     * // Get first 10 Counter_transactions
     * const counter_transactions = await prisma.counter_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const counter_transactionsWithIdOnly = await prisma.counter_transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends counter_transactionsFindManyArgs>(args?: SelectSubset<T, counter_transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$counter_transactionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Counter_transactions.
     * @param {counter_transactionsCreateArgs} args - Arguments to create a Counter_transactions.
     * @example
     * // Create one Counter_transactions
     * const Counter_transactions = await prisma.counter_transactions.create({
     *   data: {
     *     // ... data to create a Counter_transactions
     *   }
     * })
     * 
     */
    create<T extends counter_transactionsCreateArgs>(args: SelectSubset<T, counter_transactionsCreateArgs<ExtArgs>>): Prisma__counter_transactionsClient<$Result.GetResult<Prisma.$counter_transactionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Counter_transactions.
     * @param {counter_transactionsCreateManyArgs} args - Arguments to create many Counter_transactions.
     * @example
     * // Create many Counter_transactions
     * const counter_transactions = await prisma.counter_transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends counter_transactionsCreateManyArgs>(args?: SelectSubset<T, counter_transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Counter_transactions and returns the data saved in the database.
     * @param {counter_transactionsCreateManyAndReturnArgs} args - Arguments to create many Counter_transactions.
     * @example
     * // Create many Counter_transactions
     * const counter_transactions = await prisma.counter_transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Counter_transactions and only return the `id`
     * const counter_transactionsWithIdOnly = await prisma.counter_transactions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends counter_transactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, counter_transactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$counter_transactionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Counter_transactions.
     * @param {counter_transactionsDeleteArgs} args - Arguments to delete one Counter_transactions.
     * @example
     * // Delete one Counter_transactions
     * const Counter_transactions = await prisma.counter_transactions.delete({
     *   where: {
     *     // ... filter to delete one Counter_transactions
     *   }
     * })
     * 
     */
    delete<T extends counter_transactionsDeleteArgs>(args: SelectSubset<T, counter_transactionsDeleteArgs<ExtArgs>>): Prisma__counter_transactionsClient<$Result.GetResult<Prisma.$counter_transactionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Counter_transactions.
     * @param {counter_transactionsUpdateArgs} args - Arguments to update one Counter_transactions.
     * @example
     * // Update one Counter_transactions
     * const counter_transactions = await prisma.counter_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends counter_transactionsUpdateArgs>(args: SelectSubset<T, counter_transactionsUpdateArgs<ExtArgs>>): Prisma__counter_transactionsClient<$Result.GetResult<Prisma.$counter_transactionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Counter_transactions.
     * @param {counter_transactionsDeleteManyArgs} args - Arguments to filter Counter_transactions to delete.
     * @example
     * // Delete a few Counter_transactions
     * const { count } = await prisma.counter_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends counter_transactionsDeleteManyArgs>(args?: SelectSubset<T, counter_transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counter_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counter_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counter_transactions
     * const counter_transactions = await prisma.counter_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends counter_transactionsUpdateManyArgs>(args: SelectSubset<T, counter_transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Counter_transactions.
     * @param {counter_transactionsUpsertArgs} args - Arguments to update or create a Counter_transactions.
     * @example
     * // Update or create a Counter_transactions
     * const counter_transactions = await prisma.counter_transactions.upsert({
     *   create: {
     *     // ... data to create a Counter_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Counter_transactions we want to update
     *   }
     * })
     */
    upsert<T extends counter_transactionsUpsertArgs>(args: SelectSubset<T, counter_transactionsUpsertArgs<ExtArgs>>): Prisma__counter_transactionsClient<$Result.GetResult<Prisma.$counter_transactionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Counter_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counter_transactionsCountArgs} args - Arguments to filter Counter_transactions to count.
     * @example
     * // Count the number of Counter_transactions
     * const count = await prisma.counter_transactions.count({
     *   where: {
     *     // ... the filter for the Counter_transactions we want to count
     *   }
     * })
    **/
    count<T extends counter_transactionsCountArgs>(
      args?: Subset<T, counter_transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Counter_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Counter_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Counter_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Counter_transactionsAggregateArgs>(args: Subset<T, Counter_transactionsAggregateArgs>): Prisma.PrismaPromise<GetCounter_transactionsAggregateType<T>>

    /**
     * Group by Counter_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counter_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends counter_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: counter_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: counter_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, counter_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCounter_transactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the counter_transactions model
   */
  readonly fields: counter_transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for counter_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__counter_transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends bookingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingsDefaultArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    counterUser<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the counter_transactions model
   */ 
  interface counter_transactionsFieldRefs {
    readonly id: FieldRef<"counter_transactions", 'String'>
    readonly counterUserId: FieldRef<"counter_transactions", 'String'>
    readonly bookingId: FieldRef<"counter_transactions", 'String'>
    readonly action: FieldRef<"counter_transactions", 'String'>
    readonly note: FieldRef<"counter_transactions", 'String'>
    readonly createdAt: FieldRef<"counter_transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * counter_transactions findUnique
   */
  export type counter_transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which counter_transactions to fetch.
     */
    where: counter_transactionsWhereUniqueInput
  }

  /**
   * counter_transactions findUniqueOrThrow
   */
  export type counter_transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which counter_transactions to fetch.
     */
    where: counter_transactionsWhereUniqueInput
  }

  /**
   * counter_transactions findFirst
   */
  export type counter_transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which counter_transactions to fetch.
     */
    where?: counter_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counter_transactions to fetch.
     */
    orderBy?: counter_transactionsOrderByWithRelationInput | counter_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counter_transactions.
     */
    cursor?: counter_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counter_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counter_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counter_transactions.
     */
    distinct?: Counter_transactionsScalarFieldEnum | Counter_transactionsScalarFieldEnum[]
  }

  /**
   * counter_transactions findFirstOrThrow
   */
  export type counter_transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which counter_transactions to fetch.
     */
    where?: counter_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counter_transactions to fetch.
     */
    orderBy?: counter_transactionsOrderByWithRelationInput | counter_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counter_transactions.
     */
    cursor?: counter_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counter_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counter_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counter_transactions.
     */
    distinct?: Counter_transactionsScalarFieldEnum | Counter_transactionsScalarFieldEnum[]
  }

  /**
   * counter_transactions findMany
   */
  export type counter_transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which counter_transactions to fetch.
     */
    where?: counter_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counter_transactions to fetch.
     */
    orderBy?: counter_transactionsOrderByWithRelationInput | counter_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing counter_transactions.
     */
    cursor?: counter_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counter_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counter_transactions.
     */
    skip?: number
    distinct?: Counter_transactionsScalarFieldEnum | Counter_transactionsScalarFieldEnum[]
  }

  /**
   * counter_transactions create
   */
  export type counter_transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a counter_transactions.
     */
    data: XOR<counter_transactionsCreateInput, counter_transactionsUncheckedCreateInput>
  }

  /**
   * counter_transactions createMany
   */
  export type counter_transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many counter_transactions.
     */
    data: counter_transactionsCreateManyInput | counter_transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * counter_transactions createManyAndReturn
   */
  export type counter_transactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many counter_transactions.
     */
    data: counter_transactionsCreateManyInput | counter_transactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * counter_transactions update
   */
  export type counter_transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a counter_transactions.
     */
    data: XOR<counter_transactionsUpdateInput, counter_transactionsUncheckedUpdateInput>
    /**
     * Choose, which counter_transactions to update.
     */
    where: counter_transactionsWhereUniqueInput
  }

  /**
   * counter_transactions updateMany
   */
  export type counter_transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update counter_transactions.
     */
    data: XOR<counter_transactionsUpdateManyMutationInput, counter_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which counter_transactions to update
     */
    where?: counter_transactionsWhereInput
  }

  /**
   * counter_transactions upsert
   */
  export type counter_transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the counter_transactions to update in case it exists.
     */
    where: counter_transactionsWhereUniqueInput
    /**
     * In case the counter_transactions found by the `where` argument doesn't exist, create a new counter_transactions with this data.
     */
    create: XOR<counter_transactionsCreateInput, counter_transactionsUncheckedCreateInput>
    /**
     * In case the counter_transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<counter_transactionsUpdateInput, counter_transactionsUncheckedUpdateInput>
  }

  /**
   * counter_transactions delete
   */
  export type counter_transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsInclude<ExtArgs> | null
    /**
     * Filter which counter_transactions to delete.
     */
    where: counter_transactionsWhereUniqueInput
  }

  /**
   * counter_transactions deleteMany
   */
  export type counter_transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counter_transactions to delete
     */
    where?: counter_transactionsWhereInput
  }

  /**
   * counter_transactions without action
   */
  export type counter_transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counter_transactions
     */
    select?: counter_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counter_transactionsInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    isRead: boolean
    createdAt: Date
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */ 
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'String'>
    readonly userId: FieldRef<"notifications", 'String'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly message: FieldRef<"notifications", 'String'>
    readonly isRead: FieldRef<"notifications", 'Boolean'>
    readonly createdAt: FieldRef<"notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications createManyAndReturn
   */
  export type notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    email: 'email',
    phone: 'phone',
    nic: 'nic',
    residentialAddress: 'residentialAddress',
    passwordHash: 'passwordHash',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const User_rolesScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId'
  };

  export type User_rolesScalarFieldEnum = (typeof User_rolesScalarFieldEnum)[keyof typeof User_rolesScalarFieldEnum]


  export const PropertiesScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    propertyName: 'propertyName',
    address: 'address',
    pricePerHour: 'pricePerHour',
    pricePerDay: 'pricePerDay',
    currency: 'currency',
    status: 'status',
    totalSlots: 'totalSlots',
    totalNormalSlots: 'totalNormalSlots',
    totalEvSlots: 'totalEvSlots',
    totalCarWashSlots: 'totalCarWashSlots',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertiesScalarFieldEnum = (typeof PropertiesScalarFieldEnum)[keyof typeof PropertiesScalarFieldEnum]


  export const Parking_slotsScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    slotNumber: 'slotNumber',
    slotType: 'slotType',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type Parking_slotsScalarFieldEnum = (typeof Parking_slotsScalarFieldEnum)[keyof typeof Parking_slotsScalarFieldEnum]


  export const VehiclesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vehicleNumber: 'vehicleNumber',
    type: 'type',
    model: 'model',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehiclesScalarFieldEnum = (typeof VehiclesScalarFieldEnum)[keyof typeof VehiclesScalarFieldEnum]


  export const BookingsScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    propertyId: 'propertyId',
    vehicleId: 'vehicleId',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    parkingType: 'parkingType',
    bookingType: 'bookingType',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingsScalarFieldEnum = (typeof BookingsScalarFieldEnum)[keyof typeof BookingsScalarFieldEnum]


  export const Booking_slotsScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    slotId: 'slotId',
    createdAt: 'createdAt'
  };

  export type Booking_slotsScalarFieldEnum = (typeof Booking_slotsScalarFieldEnum)[keyof typeof Booking_slotsScalarFieldEnum]


  export const Booking_status_historyScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    oldStatus: 'oldStatus',
    newStatus: 'newStatus',
    changedBy: 'changedBy',
    note: 'note',
    changedAt: 'changedAt'
  };

  export type Booking_status_historyScalarFieldEnum = (typeof Booking_status_historyScalarFieldEnum)[keyof typeof Booking_status_historyScalarFieldEnum]


  export const Payment_summaryScalarFieldEnum: {
    bookingId: 'bookingId',
    totalAmount: 'totalAmount',
    onlinePaid: 'onlinePaid',
    cashPaid: 'cashPaid',
    balanceDue: 'balanceDue',
    currency: 'currency',
    updatedAt: 'updatedAt'
  };

  export type Payment_summaryScalarFieldEnum = (typeof Payment_summaryScalarFieldEnum)[keyof typeof Payment_summaryScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    payerId: 'payerId',
    amount: 'amount',
    currency: 'currency',
    method: 'method',
    paymentStatus: 'paymentStatus',
    gatewayStatus: 'gatewayStatus',
    gatewayProvider: 'gatewayProvider',
    transactionId: 'transactionId',
    cardLast4: 'cardLast4',
    cardBrand: 'cardBrand',
    cardExpMonth: 'cardExpMonth',
    cardExpYear: 'cardExpYear',
    paidAt: 'paidAt',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const Wash_jobsScalarFieldEnum: {
    id: 'id',
    bookingSlotId: 'bookingSlotId',
    washerId: 'washerId',
    status: 'status',
    acceptedAt: 'acceptedAt',
    completedAt: 'completedAt',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Wash_jobsScalarFieldEnum = (typeof Wash_jobsScalarFieldEnum)[keyof typeof Wash_jobsScalarFieldEnum]


  export const Counter_transactionsScalarFieldEnum: {
    id: 'id',
    counterUserId: 'counterUserId',
    bookingId: 'bookingId',
    action: 'action',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type Counter_transactionsScalarFieldEnum = (typeof Counter_transactionsScalarFieldEnum)[keyof typeof Counter_transactionsScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'RoleName'
   */
  export type EnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName'>
    


  /**
   * Reference to a field of type 'RoleName[]'
   */
  export type ListEnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'PropertyStatus'
   */
  export type EnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus'>
    


  /**
   * Reference to a field of type 'PropertyStatus[]'
   */
  export type ListEnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus[]'>
    


  /**
   * Reference to a field of type 'SlotType'
   */
  export type EnumSlotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SlotType'>
    


  /**
   * Reference to a field of type 'SlotType[]'
   */
  export type ListEnumSlotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SlotType[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'GatewayStatus'
   */
  export type EnumGatewayStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GatewayStatus'>
    


  /**
   * Reference to a field of type 'GatewayStatus[]'
   */
  export type ListEnumGatewayStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GatewayStatus[]'>
    


  /**
   * Reference to a field of type 'WashStatus'
   */
  export type EnumWashStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WashStatus'>
    


  /**
   * Reference to a field of type 'WashStatus[]'
   */
  export type ListEnumWashStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WashStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: UuidFilter<"users"> | string
    fullName?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    phone?: StringNullableFilter<"users"> | string | null
    nic?: StringNullableFilter<"users"> | string | null
    residentialAddress?: StringNullableFilter<"users"> | string | null
    passwordHash?: StringFilter<"users"> | string
    isActive?: BoolFilter<"users"> | boolean
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    customerBookings?: BookingsListRelationFilter
    createdBookings?: BookingsListRelationFilter
    bookingStatusEvents?: Booking_status_historyListRelationFilter
    counterTransactions?: Counter_transactionsListRelationFilter
    notifications?: NotificationsListRelationFilter
    ownedProperties?: PropertiesListRelationFilter
    createdPayments?: PaymentsListRelationFilter
    payments?: PaymentsListRelationFilter
    roles?: User_rolesListRelationFilter
    vehicles?: VehiclesListRelationFilter
    washJobs?: Wash_jobsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    nic?: SortOrderInput | SortOrder
    residentialAddress?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerBookings?: bookingsOrderByRelationAggregateInput
    createdBookings?: bookingsOrderByRelationAggregateInput
    bookingStatusEvents?: booking_status_historyOrderByRelationAggregateInput
    counterTransactions?: counter_transactionsOrderByRelationAggregateInput
    notifications?: notificationsOrderByRelationAggregateInput
    ownedProperties?: propertiesOrderByRelationAggregateInput
    createdPayments?: paymentsOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
    roles?: user_rolesOrderByRelationAggregateInput
    vehicles?: vehiclesOrderByRelationAggregateInput
    washJobs?: wash_jobsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    nic?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    fullName?: StringFilter<"users"> | string
    residentialAddress?: StringNullableFilter<"users"> | string | null
    passwordHash?: StringFilter<"users"> | string
    isActive?: BoolFilter<"users"> | boolean
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    customerBookings?: BookingsListRelationFilter
    createdBookings?: BookingsListRelationFilter
    bookingStatusEvents?: Booking_status_historyListRelationFilter
    counterTransactions?: Counter_transactionsListRelationFilter
    notifications?: NotificationsListRelationFilter
    ownedProperties?: PropertiesListRelationFilter
    createdPayments?: PaymentsListRelationFilter
    payments?: PaymentsListRelationFilter
    roles?: User_rolesListRelationFilter
    vehicles?: VehiclesListRelationFilter
    washJobs?: Wash_jobsListRelationFilter
  }, "id" | "email" | "phone" | "nic">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    nic?: SortOrderInput | SortOrder
    residentialAddress?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"users"> | string
    fullName?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    nic?: StringNullableWithAggregatesFilter<"users"> | string | null
    residentialAddress?: StringNullableWithAggregatesFilter<"users"> | string | null
    passwordHash?: StringWithAggregatesFilter<"users"> | string
    isActive?: BoolWithAggregatesFilter<"users"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: IntFilter<"roles"> | number
    name?: EnumRoleNameFilter<"roles"> | $Enums.RoleName
    users?: User_rolesListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: user_rolesOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: $Enums.RoleName
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    users?: User_rolesListRelationFilter
  }, "id" | "name">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roles"> | number
    name?: EnumRoleNameWithAggregatesFilter<"roles"> | $Enums.RoleName
  }

  export type user_rolesWhereInput = {
    AND?: user_rolesWhereInput | user_rolesWhereInput[]
    OR?: user_rolesWhereInput[]
    NOT?: user_rolesWhereInput | user_rolesWhereInput[]
    userId?: UuidFilter<"user_roles"> | string
    roleId?: IntFilter<"user_roles"> | number
    role?: XOR<RolesRelationFilter, rolesWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_rolesOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    role?: rolesOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type user_rolesWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: user_rolesUserIdRoleIdCompoundUniqueInput
    AND?: user_rolesWhereInput | user_rolesWhereInput[]
    OR?: user_rolesWhereInput[]
    NOT?: user_rolesWhereInput | user_rolesWhereInput[]
    userId?: UuidFilter<"user_roles"> | string
    roleId?: IntFilter<"user_roles"> | number
    role?: XOR<RolesRelationFilter, rolesWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "userId_roleId">

  export type user_rolesOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    _count?: user_rolesCountOrderByAggregateInput
    _avg?: user_rolesAvgOrderByAggregateInput
    _max?: user_rolesMaxOrderByAggregateInput
    _min?: user_rolesMinOrderByAggregateInput
    _sum?: user_rolesSumOrderByAggregateInput
  }

  export type user_rolesScalarWhereWithAggregatesInput = {
    AND?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]
    OR?: user_rolesScalarWhereWithAggregatesInput[]
    NOT?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"user_roles"> | string
    roleId?: IntWithAggregatesFilter<"user_roles"> | number
  }

  export type propertiesWhereInput = {
    AND?: propertiesWhereInput | propertiesWhereInput[]
    OR?: propertiesWhereInput[]
    NOT?: propertiesWhereInput | propertiesWhereInput[]
    id?: UuidFilter<"properties"> | string
    ownerId?: UuidFilter<"properties"> | string
    propertyName?: StringFilter<"properties"> | string
    address?: StringFilter<"properties"> | string
    pricePerHour?: DecimalFilter<"properties"> | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFilter<"properties"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"properties"> | string
    status?: EnumPropertyStatusFilter<"properties"> | $Enums.PropertyStatus
    totalSlots?: IntFilter<"properties"> | number
    totalNormalSlots?: IntFilter<"properties"> | number
    totalEvSlots?: IntFilter<"properties"> | number
    totalCarWashSlots?: IntFilter<"properties"> | number
    createdAt?: DateTimeFilter<"properties"> | Date | string
    updatedAt?: DateTimeFilter<"properties"> | Date | string
    bookings?: BookingsListRelationFilter
    owner?: XOR<UsersRelationFilter, usersWhereInput>
    parkingSlots?: Parking_slotsListRelationFilter
  }

  export type propertiesOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    propertyName?: SortOrder
    address?: SortOrder
    pricePerHour?: SortOrder
    pricePerDay?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    totalSlots?: SortOrder
    totalNormalSlots?: SortOrder
    totalEvSlots?: SortOrder
    totalCarWashSlots?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: bookingsOrderByRelationAggregateInput
    owner?: usersOrderByWithRelationInput
    parkingSlots?: parking_slotsOrderByRelationAggregateInput
  }

  export type propertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: propertiesWhereInput | propertiesWhereInput[]
    OR?: propertiesWhereInput[]
    NOT?: propertiesWhereInput | propertiesWhereInput[]
    ownerId?: UuidFilter<"properties"> | string
    propertyName?: StringFilter<"properties"> | string
    address?: StringFilter<"properties"> | string
    pricePerHour?: DecimalFilter<"properties"> | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFilter<"properties"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"properties"> | string
    status?: EnumPropertyStatusFilter<"properties"> | $Enums.PropertyStatus
    totalSlots?: IntFilter<"properties"> | number
    totalNormalSlots?: IntFilter<"properties"> | number
    totalEvSlots?: IntFilter<"properties"> | number
    totalCarWashSlots?: IntFilter<"properties"> | number
    createdAt?: DateTimeFilter<"properties"> | Date | string
    updatedAt?: DateTimeFilter<"properties"> | Date | string
    bookings?: BookingsListRelationFilter
    owner?: XOR<UsersRelationFilter, usersWhereInput>
    parkingSlots?: Parking_slotsListRelationFilter
  }, "id">

  export type propertiesOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    propertyName?: SortOrder
    address?: SortOrder
    pricePerHour?: SortOrder
    pricePerDay?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    totalSlots?: SortOrder
    totalNormalSlots?: SortOrder
    totalEvSlots?: SortOrder
    totalCarWashSlots?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: propertiesCountOrderByAggregateInput
    _avg?: propertiesAvgOrderByAggregateInput
    _max?: propertiesMaxOrderByAggregateInput
    _min?: propertiesMinOrderByAggregateInput
    _sum?: propertiesSumOrderByAggregateInput
  }

  export type propertiesScalarWhereWithAggregatesInput = {
    AND?: propertiesScalarWhereWithAggregatesInput | propertiesScalarWhereWithAggregatesInput[]
    OR?: propertiesScalarWhereWithAggregatesInput[]
    NOT?: propertiesScalarWhereWithAggregatesInput | propertiesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"properties"> | string
    ownerId?: UuidWithAggregatesFilter<"properties"> | string
    propertyName?: StringWithAggregatesFilter<"properties"> | string
    address?: StringWithAggregatesFilter<"properties"> | string
    pricePerHour?: DecimalWithAggregatesFilter<"properties"> | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalWithAggregatesFilter<"properties"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"properties"> | string
    status?: EnumPropertyStatusWithAggregatesFilter<"properties"> | $Enums.PropertyStatus
    totalSlots?: IntWithAggregatesFilter<"properties"> | number
    totalNormalSlots?: IntWithAggregatesFilter<"properties"> | number
    totalEvSlots?: IntWithAggregatesFilter<"properties"> | number
    totalCarWashSlots?: IntWithAggregatesFilter<"properties"> | number
    createdAt?: DateTimeWithAggregatesFilter<"properties"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"properties"> | Date | string
  }

  export type parking_slotsWhereInput = {
    AND?: parking_slotsWhereInput | parking_slotsWhereInput[]
    OR?: parking_slotsWhereInput[]
    NOT?: parking_slotsWhereInput | parking_slotsWhereInput[]
    id?: UuidFilter<"parking_slots"> | string
    propertyId?: UuidFilter<"parking_slots"> | string
    slotNumber?: StringFilter<"parking_slots"> | string
    slotType?: EnumSlotTypeFilter<"parking_slots"> | $Enums.SlotType
    isActive?: BoolFilter<"parking_slots"> | boolean
    createdAt?: DateTimeFilter<"parking_slots"> | Date | string
    bookingSlots?: Booking_slotsListRelationFilter
    property?: XOR<PropertiesRelationFilter, propertiesWhereInput>
  }

  export type parking_slotsOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    slotNumber?: SortOrder
    slotType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    bookingSlots?: booking_slotsOrderByRelationAggregateInput
    property?: propertiesOrderByWithRelationInput
  }

  export type parking_slotsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId_slotNumber?: parking_slotsPropertyIdSlotNumberCompoundUniqueInput
    AND?: parking_slotsWhereInput | parking_slotsWhereInput[]
    OR?: parking_slotsWhereInput[]
    NOT?: parking_slotsWhereInput | parking_slotsWhereInput[]
    propertyId?: UuidFilter<"parking_slots"> | string
    slotNumber?: StringFilter<"parking_slots"> | string
    slotType?: EnumSlotTypeFilter<"parking_slots"> | $Enums.SlotType
    isActive?: BoolFilter<"parking_slots"> | boolean
    createdAt?: DateTimeFilter<"parking_slots"> | Date | string
    bookingSlots?: Booking_slotsListRelationFilter
    property?: XOR<PropertiesRelationFilter, propertiesWhereInput>
  }, "id" | "propertyId_slotNumber">

  export type parking_slotsOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    slotNumber?: SortOrder
    slotType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: parking_slotsCountOrderByAggregateInput
    _max?: parking_slotsMaxOrderByAggregateInput
    _min?: parking_slotsMinOrderByAggregateInput
  }

  export type parking_slotsScalarWhereWithAggregatesInput = {
    AND?: parking_slotsScalarWhereWithAggregatesInput | parking_slotsScalarWhereWithAggregatesInput[]
    OR?: parking_slotsScalarWhereWithAggregatesInput[]
    NOT?: parking_slotsScalarWhereWithAggregatesInput | parking_slotsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"parking_slots"> | string
    propertyId?: UuidWithAggregatesFilter<"parking_slots"> | string
    slotNumber?: StringWithAggregatesFilter<"parking_slots"> | string
    slotType?: EnumSlotTypeWithAggregatesFilter<"parking_slots"> | $Enums.SlotType
    isActive?: BoolWithAggregatesFilter<"parking_slots"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"parking_slots"> | Date | string
  }

  export type vehiclesWhereInput = {
    AND?: vehiclesWhereInput | vehiclesWhereInput[]
    OR?: vehiclesWhereInput[]
    NOT?: vehiclesWhereInput | vehiclesWhereInput[]
    id?: UuidFilter<"vehicles"> | string
    userId?: UuidFilter<"vehicles"> | string
    vehicleNumber?: StringFilter<"vehicles"> | string
    type?: StringNullableFilter<"vehicles"> | string | null
    model?: StringNullableFilter<"vehicles"> | string | null
    color?: StringNullableFilter<"vehicles"> | string | null
    createdAt?: DateTimeFilter<"vehicles"> | Date | string
    updatedAt?: DateTimeFilter<"vehicles"> | Date | string
    bookings?: BookingsListRelationFilter
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type vehiclesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleNumber?: SortOrder
    type?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: bookingsOrderByRelationAggregateInput
    user?: usersOrderByWithRelationInput
  }

  export type vehiclesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vehicleNumber?: string
    AND?: vehiclesWhereInput | vehiclesWhereInput[]
    OR?: vehiclesWhereInput[]
    NOT?: vehiclesWhereInput | vehiclesWhereInput[]
    userId?: UuidFilter<"vehicles"> | string
    type?: StringNullableFilter<"vehicles"> | string | null
    model?: StringNullableFilter<"vehicles"> | string | null
    color?: StringNullableFilter<"vehicles"> | string | null
    createdAt?: DateTimeFilter<"vehicles"> | Date | string
    updatedAt?: DateTimeFilter<"vehicles"> | Date | string
    bookings?: BookingsListRelationFilter
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "vehicleNumber">

  export type vehiclesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleNumber?: SortOrder
    type?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vehiclesCountOrderByAggregateInput
    _max?: vehiclesMaxOrderByAggregateInput
    _min?: vehiclesMinOrderByAggregateInput
  }

  export type vehiclesScalarWhereWithAggregatesInput = {
    AND?: vehiclesScalarWhereWithAggregatesInput | vehiclesScalarWhereWithAggregatesInput[]
    OR?: vehiclesScalarWhereWithAggregatesInput[]
    NOT?: vehiclesScalarWhereWithAggregatesInput | vehiclesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"vehicles"> | string
    userId?: UuidWithAggregatesFilter<"vehicles"> | string
    vehicleNumber?: StringWithAggregatesFilter<"vehicles"> | string
    type?: StringNullableWithAggregatesFilter<"vehicles"> | string | null
    model?: StringNullableWithAggregatesFilter<"vehicles"> | string | null
    color?: StringNullableWithAggregatesFilter<"vehicles"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"vehicles"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vehicles"> | Date | string
  }

  export type bookingsWhereInput = {
    AND?: bookingsWhereInput | bookingsWhereInput[]
    OR?: bookingsWhereInput[]
    NOT?: bookingsWhereInput | bookingsWhereInput[]
    id?: UuidFilter<"bookings"> | string
    customerId?: UuidFilter<"bookings"> | string
    propertyId?: UuidFilter<"bookings"> | string
    vehicleId?: UuidNullableFilter<"bookings"> | string | null
    startTime?: DateTimeFilter<"bookings"> | Date | string
    endTime?: DateTimeFilter<"bookings"> | Date | string
    status?: EnumBookingStatusFilter<"bookings"> | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFilter<"bookings"> | $Enums.SlotType
    bookingType?: StringFilter<"bookings"> | string
    createdBy?: UuidNullableFilter<"bookings"> | string | null
    createdAt?: DateTimeFilter<"bookings"> | Date | string
    updatedAt?: DateTimeFilter<"bookings"> | Date | string
    bookingSlots?: Booking_slotsListRelationFilter
    customer?: XOR<UsersRelationFilter, usersWhereInput>
    creator?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    counterLogs?: Counter_transactionsListRelationFilter
    paymentSummary?: XOR<Payment_summaryNullableRelationFilter, payment_summaryWhereInput> | null
    payments?: PaymentsListRelationFilter
    property?: XOR<PropertiesRelationFilter, propertiesWhereInput>
    statusHistory?: Booking_status_historyListRelationFilter
    vehicle?: XOR<VehiclesNullableRelationFilter, vehiclesWhereInput> | null
  }

  export type bookingsOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    propertyId?: SortOrder
    vehicleId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    parkingType?: SortOrder
    bookingType?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingSlots?: booking_slotsOrderByRelationAggregateInput
    customer?: usersOrderByWithRelationInput
    creator?: usersOrderByWithRelationInput
    counterLogs?: counter_transactionsOrderByRelationAggregateInput
    paymentSummary?: payment_summaryOrderByWithRelationInput
    payments?: paymentsOrderByRelationAggregateInput
    property?: propertiesOrderByWithRelationInput
    statusHistory?: booking_status_historyOrderByRelationAggregateInput
    vehicle?: vehiclesOrderByWithRelationInput
  }

  export type bookingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: bookingsWhereInput | bookingsWhereInput[]
    OR?: bookingsWhereInput[]
    NOT?: bookingsWhereInput | bookingsWhereInput[]
    customerId?: UuidFilter<"bookings"> | string
    propertyId?: UuidFilter<"bookings"> | string
    vehicleId?: UuidNullableFilter<"bookings"> | string | null
    startTime?: DateTimeFilter<"bookings"> | Date | string
    endTime?: DateTimeFilter<"bookings"> | Date | string
    status?: EnumBookingStatusFilter<"bookings"> | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFilter<"bookings"> | $Enums.SlotType
    bookingType?: StringFilter<"bookings"> | string
    createdBy?: UuidNullableFilter<"bookings"> | string | null
    createdAt?: DateTimeFilter<"bookings"> | Date | string
    updatedAt?: DateTimeFilter<"bookings"> | Date | string
    bookingSlots?: Booking_slotsListRelationFilter
    customer?: XOR<UsersRelationFilter, usersWhereInput>
    creator?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    counterLogs?: Counter_transactionsListRelationFilter
    paymentSummary?: XOR<Payment_summaryNullableRelationFilter, payment_summaryWhereInput> | null
    payments?: PaymentsListRelationFilter
    property?: XOR<PropertiesRelationFilter, propertiesWhereInput>
    statusHistory?: Booking_status_historyListRelationFilter
    vehicle?: XOR<VehiclesNullableRelationFilter, vehiclesWhereInput> | null
  }, "id">

  export type bookingsOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    propertyId?: SortOrder
    vehicleId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    parkingType?: SortOrder
    bookingType?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: bookingsCountOrderByAggregateInput
    _max?: bookingsMaxOrderByAggregateInput
    _min?: bookingsMinOrderByAggregateInput
  }

  export type bookingsScalarWhereWithAggregatesInput = {
    AND?: bookingsScalarWhereWithAggregatesInput | bookingsScalarWhereWithAggregatesInput[]
    OR?: bookingsScalarWhereWithAggregatesInput[]
    NOT?: bookingsScalarWhereWithAggregatesInput | bookingsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bookings"> | string
    customerId?: UuidWithAggregatesFilter<"bookings"> | string
    propertyId?: UuidWithAggregatesFilter<"bookings"> | string
    vehicleId?: UuidNullableWithAggregatesFilter<"bookings"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"bookings"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"bookings"> | Date | string
    status?: EnumBookingStatusWithAggregatesFilter<"bookings"> | $Enums.BookingStatus
    parkingType?: EnumSlotTypeWithAggregatesFilter<"bookings"> | $Enums.SlotType
    bookingType?: StringWithAggregatesFilter<"bookings"> | string
    createdBy?: UuidNullableWithAggregatesFilter<"bookings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"bookings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"bookings"> | Date | string
  }

  export type booking_slotsWhereInput = {
    AND?: booking_slotsWhereInput | booking_slotsWhereInput[]
    OR?: booking_slotsWhereInput[]
    NOT?: booking_slotsWhereInput | booking_slotsWhereInput[]
    id?: UuidFilter<"booking_slots"> | string
    bookingId?: UuidFilter<"booking_slots"> | string
    slotId?: UuidFilter<"booking_slots"> | string
    createdAt?: DateTimeFilter<"booking_slots"> | Date | string
    booking?: XOR<BookingsRelationFilter, bookingsWhereInput>
    slot?: XOR<Parking_slotsRelationFilter, parking_slotsWhereInput>
    washJob?: XOR<Wash_jobsNullableRelationFilter, wash_jobsWhereInput> | null
  }

  export type booking_slotsOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    createdAt?: SortOrder
    booking?: bookingsOrderByWithRelationInput
    slot?: parking_slotsOrderByWithRelationInput
    washJob?: wash_jobsOrderByWithRelationInput
  }

  export type booking_slotsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingId_slotId?: booking_slotsBookingIdSlotIdCompoundUniqueInput
    AND?: booking_slotsWhereInput | booking_slotsWhereInput[]
    OR?: booking_slotsWhereInput[]
    NOT?: booking_slotsWhereInput | booking_slotsWhereInput[]
    bookingId?: UuidFilter<"booking_slots"> | string
    slotId?: UuidFilter<"booking_slots"> | string
    createdAt?: DateTimeFilter<"booking_slots"> | Date | string
    booking?: XOR<BookingsRelationFilter, bookingsWhereInput>
    slot?: XOR<Parking_slotsRelationFilter, parking_slotsWhereInput>
    washJob?: XOR<Wash_jobsNullableRelationFilter, wash_jobsWhereInput> | null
  }, "id" | "bookingId_slotId">

  export type booking_slotsOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    createdAt?: SortOrder
    _count?: booking_slotsCountOrderByAggregateInput
    _max?: booking_slotsMaxOrderByAggregateInput
    _min?: booking_slotsMinOrderByAggregateInput
  }

  export type booking_slotsScalarWhereWithAggregatesInput = {
    AND?: booking_slotsScalarWhereWithAggregatesInput | booking_slotsScalarWhereWithAggregatesInput[]
    OR?: booking_slotsScalarWhereWithAggregatesInput[]
    NOT?: booking_slotsScalarWhereWithAggregatesInput | booking_slotsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"booking_slots"> | string
    bookingId?: UuidWithAggregatesFilter<"booking_slots"> | string
    slotId?: UuidWithAggregatesFilter<"booking_slots"> | string
    createdAt?: DateTimeWithAggregatesFilter<"booking_slots"> | Date | string
  }

  export type booking_status_historyWhereInput = {
    AND?: booking_status_historyWhereInput | booking_status_historyWhereInput[]
    OR?: booking_status_historyWhereInput[]
    NOT?: booking_status_historyWhereInput | booking_status_historyWhereInput[]
    id?: UuidFilter<"booking_status_history"> | string
    bookingId?: UuidFilter<"booking_status_history"> | string
    oldStatus?: StringNullableFilter<"booking_status_history"> | string | null
    newStatus?: StringFilter<"booking_status_history"> | string
    changedBy?: UuidNullableFilter<"booking_status_history"> | string | null
    note?: StringNullableFilter<"booking_status_history"> | string | null
    changedAt?: DateTimeFilter<"booking_status_history"> | Date | string
    booking?: XOR<BookingsRelationFilter, bookingsWhereInput>
    changer?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type booking_status_historyOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    oldStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    booking?: bookingsOrderByWithRelationInput
    changer?: usersOrderByWithRelationInput
  }

  export type booking_status_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: booking_status_historyWhereInput | booking_status_historyWhereInput[]
    OR?: booking_status_historyWhereInput[]
    NOT?: booking_status_historyWhereInput | booking_status_historyWhereInput[]
    bookingId?: UuidFilter<"booking_status_history"> | string
    oldStatus?: StringNullableFilter<"booking_status_history"> | string | null
    newStatus?: StringFilter<"booking_status_history"> | string
    changedBy?: UuidNullableFilter<"booking_status_history"> | string | null
    note?: StringNullableFilter<"booking_status_history"> | string | null
    changedAt?: DateTimeFilter<"booking_status_history"> | Date | string
    booking?: XOR<BookingsRelationFilter, bookingsWhereInput>
    changer?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type booking_status_historyOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    oldStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    _count?: booking_status_historyCountOrderByAggregateInput
    _max?: booking_status_historyMaxOrderByAggregateInput
    _min?: booking_status_historyMinOrderByAggregateInput
  }

  export type booking_status_historyScalarWhereWithAggregatesInput = {
    AND?: booking_status_historyScalarWhereWithAggregatesInput | booking_status_historyScalarWhereWithAggregatesInput[]
    OR?: booking_status_historyScalarWhereWithAggregatesInput[]
    NOT?: booking_status_historyScalarWhereWithAggregatesInput | booking_status_historyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"booking_status_history"> | string
    bookingId?: UuidWithAggregatesFilter<"booking_status_history"> | string
    oldStatus?: StringNullableWithAggregatesFilter<"booking_status_history"> | string | null
    newStatus?: StringWithAggregatesFilter<"booking_status_history"> | string
    changedBy?: UuidNullableWithAggregatesFilter<"booking_status_history"> | string | null
    note?: StringNullableWithAggregatesFilter<"booking_status_history"> | string | null
    changedAt?: DateTimeWithAggregatesFilter<"booking_status_history"> | Date | string
  }

  export type payment_summaryWhereInput = {
    AND?: payment_summaryWhereInput | payment_summaryWhereInput[]
    OR?: payment_summaryWhereInput[]
    NOT?: payment_summaryWhereInput | payment_summaryWhereInput[]
    bookingId?: UuidFilter<"payment_summary"> | string
    totalAmount?: DecimalFilter<"payment_summary"> | Decimal | DecimalJsLike | number | string
    onlinePaid?: DecimalFilter<"payment_summary"> | Decimal | DecimalJsLike | number | string
    cashPaid?: DecimalFilter<"payment_summary"> | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFilter<"payment_summary"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"payment_summary"> | string
    updatedAt?: DateTimeFilter<"payment_summary"> | Date | string
    booking?: XOR<BookingsRelationFilter, bookingsWhereInput>
  }

  export type payment_summaryOrderByWithRelationInput = {
    bookingId?: SortOrder
    totalAmount?: SortOrder
    onlinePaid?: SortOrder
    cashPaid?: SortOrder
    balanceDue?: SortOrder
    currency?: SortOrder
    updatedAt?: SortOrder
    booking?: bookingsOrderByWithRelationInput
  }

  export type payment_summaryWhereUniqueInput = Prisma.AtLeast<{
    bookingId?: string
    AND?: payment_summaryWhereInput | payment_summaryWhereInput[]
    OR?: payment_summaryWhereInput[]
    NOT?: payment_summaryWhereInput | payment_summaryWhereInput[]
    totalAmount?: DecimalFilter<"payment_summary"> | Decimal | DecimalJsLike | number | string
    onlinePaid?: DecimalFilter<"payment_summary"> | Decimal | DecimalJsLike | number | string
    cashPaid?: DecimalFilter<"payment_summary"> | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFilter<"payment_summary"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"payment_summary"> | string
    updatedAt?: DateTimeFilter<"payment_summary"> | Date | string
    booking?: XOR<BookingsRelationFilter, bookingsWhereInput>
  }, "bookingId">

  export type payment_summaryOrderByWithAggregationInput = {
    bookingId?: SortOrder
    totalAmount?: SortOrder
    onlinePaid?: SortOrder
    cashPaid?: SortOrder
    balanceDue?: SortOrder
    currency?: SortOrder
    updatedAt?: SortOrder
    _count?: payment_summaryCountOrderByAggregateInput
    _avg?: payment_summaryAvgOrderByAggregateInput
    _max?: payment_summaryMaxOrderByAggregateInput
    _min?: payment_summaryMinOrderByAggregateInput
    _sum?: payment_summarySumOrderByAggregateInput
  }

  export type payment_summaryScalarWhereWithAggregatesInput = {
    AND?: payment_summaryScalarWhereWithAggregatesInput | payment_summaryScalarWhereWithAggregatesInput[]
    OR?: payment_summaryScalarWhereWithAggregatesInput[]
    NOT?: payment_summaryScalarWhereWithAggregatesInput | payment_summaryScalarWhereWithAggregatesInput[]
    bookingId?: UuidWithAggregatesFilter<"payment_summary"> | string
    totalAmount?: DecimalWithAggregatesFilter<"payment_summary"> | Decimal | DecimalJsLike | number | string
    onlinePaid?: DecimalWithAggregatesFilter<"payment_summary"> | Decimal | DecimalJsLike | number | string
    cashPaid?: DecimalWithAggregatesFilter<"payment_summary"> | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalWithAggregatesFilter<"payment_summary"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"payment_summary"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"payment_summary"> | Date | string
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: UuidFilter<"payments"> | string
    bookingId?: UuidFilter<"payments"> | string
    payerId?: UuidFilter<"payments"> | string
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"payments"> | string
    method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFilter<"payments"> | $Enums.GatewayStatus
    gatewayProvider?: StringNullableFilter<"payments"> | string | null
    transactionId?: StringNullableFilter<"payments"> | string | null
    cardLast4?: StringNullableFilter<"payments"> | string | null
    cardBrand?: StringNullableFilter<"payments"> | string | null
    cardExpMonth?: IntNullableFilter<"payments"> | number | null
    cardExpYear?: IntNullableFilter<"payments"> | number | null
    paidAt?: DateTimeNullableFilter<"payments"> | Date | string | null
    createdBy?: UuidNullableFilter<"payments"> | string | null
    createdAt?: DateTimeFilter<"payments"> | Date | string
    booking?: XOR<BookingsRelationFilter, bookingsWhereInput>
    creator?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    payer?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    payerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentStatus?: SortOrder
    gatewayStatus?: SortOrder
    gatewayProvider?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    cardLast4?: SortOrderInput | SortOrder
    cardBrand?: SortOrderInput | SortOrder
    cardExpMonth?: SortOrderInput | SortOrder
    cardExpYear?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    booking?: bookingsOrderByWithRelationInput
    creator?: usersOrderByWithRelationInput
    payer?: usersOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    bookingId?: UuidFilter<"payments"> | string
    payerId?: UuidFilter<"payments"> | string
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"payments"> | string
    method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFilter<"payments"> | $Enums.GatewayStatus
    gatewayProvider?: StringNullableFilter<"payments"> | string | null
    transactionId?: StringNullableFilter<"payments"> | string | null
    cardLast4?: StringNullableFilter<"payments"> | string | null
    cardBrand?: StringNullableFilter<"payments"> | string | null
    cardExpMonth?: IntNullableFilter<"payments"> | number | null
    cardExpYear?: IntNullableFilter<"payments"> | number | null
    paidAt?: DateTimeNullableFilter<"payments"> | Date | string | null
    createdBy?: UuidNullableFilter<"payments"> | string | null
    createdAt?: DateTimeFilter<"payments"> | Date | string
    booking?: XOR<BookingsRelationFilter, bookingsWhereInput>
    creator?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    payer?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    payerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentStatus?: SortOrder
    gatewayStatus?: SortOrder
    gatewayProvider?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    cardLast4?: SortOrderInput | SortOrder
    cardBrand?: SortOrderInput | SortOrder
    cardExpMonth?: SortOrderInput | SortOrder
    cardExpYear?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"payments"> | string
    bookingId?: UuidWithAggregatesFilter<"payments"> | string
    payerId?: UuidWithAggregatesFilter<"payments"> | string
    amount?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"payments"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"payments"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"payments"> | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusWithAggregatesFilter<"payments"> | $Enums.GatewayStatus
    gatewayProvider?: StringNullableWithAggregatesFilter<"payments"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"payments"> | string | null
    cardLast4?: StringNullableWithAggregatesFilter<"payments"> | string | null
    cardBrand?: StringNullableWithAggregatesFilter<"payments"> | string | null
    cardExpMonth?: IntNullableWithAggregatesFilter<"payments"> | number | null
    cardExpYear?: IntNullableWithAggregatesFilter<"payments"> | number | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    createdBy?: UuidNullableWithAggregatesFilter<"payments"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"payments"> | Date | string
  }

  export type wash_jobsWhereInput = {
    AND?: wash_jobsWhereInput | wash_jobsWhereInput[]
    OR?: wash_jobsWhereInput[]
    NOT?: wash_jobsWhereInput | wash_jobsWhereInput[]
    id?: UuidFilter<"wash_jobs"> | string
    bookingSlotId?: UuidFilter<"wash_jobs"> | string
    washerId?: UuidNullableFilter<"wash_jobs"> | string | null
    status?: EnumWashStatusFilter<"wash_jobs"> | $Enums.WashStatus
    acceptedAt?: DateTimeNullableFilter<"wash_jobs"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"wash_jobs"> | Date | string | null
    note?: StringNullableFilter<"wash_jobs"> | string | null
    createdAt?: DateTimeFilter<"wash_jobs"> | Date | string
    updatedAt?: DateTimeFilter<"wash_jobs"> | Date | string
    bookingSlot?: XOR<Booking_slotsRelationFilter, booking_slotsWhereInput>
    washer?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type wash_jobsOrderByWithRelationInput = {
    id?: SortOrder
    bookingSlotId?: SortOrder
    washerId?: SortOrderInput | SortOrder
    status?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingSlot?: booking_slotsOrderByWithRelationInput
    washer?: usersOrderByWithRelationInput
  }

  export type wash_jobsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingSlotId?: string
    AND?: wash_jobsWhereInput | wash_jobsWhereInput[]
    OR?: wash_jobsWhereInput[]
    NOT?: wash_jobsWhereInput | wash_jobsWhereInput[]
    washerId?: UuidNullableFilter<"wash_jobs"> | string | null
    status?: EnumWashStatusFilter<"wash_jobs"> | $Enums.WashStatus
    acceptedAt?: DateTimeNullableFilter<"wash_jobs"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"wash_jobs"> | Date | string | null
    note?: StringNullableFilter<"wash_jobs"> | string | null
    createdAt?: DateTimeFilter<"wash_jobs"> | Date | string
    updatedAt?: DateTimeFilter<"wash_jobs"> | Date | string
    bookingSlot?: XOR<Booking_slotsRelationFilter, booking_slotsWhereInput>
    washer?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id" | "bookingSlotId">

  export type wash_jobsOrderByWithAggregationInput = {
    id?: SortOrder
    bookingSlotId?: SortOrder
    washerId?: SortOrderInput | SortOrder
    status?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: wash_jobsCountOrderByAggregateInput
    _max?: wash_jobsMaxOrderByAggregateInput
    _min?: wash_jobsMinOrderByAggregateInput
  }

  export type wash_jobsScalarWhereWithAggregatesInput = {
    AND?: wash_jobsScalarWhereWithAggregatesInput | wash_jobsScalarWhereWithAggregatesInput[]
    OR?: wash_jobsScalarWhereWithAggregatesInput[]
    NOT?: wash_jobsScalarWhereWithAggregatesInput | wash_jobsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"wash_jobs"> | string
    bookingSlotId?: UuidWithAggregatesFilter<"wash_jobs"> | string
    washerId?: UuidNullableWithAggregatesFilter<"wash_jobs"> | string | null
    status?: EnumWashStatusWithAggregatesFilter<"wash_jobs"> | $Enums.WashStatus
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"wash_jobs"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"wash_jobs"> | Date | string | null
    note?: StringNullableWithAggregatesFilter<"wash_jobs"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"wash_jobs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"wash_jobs"> | Date | string
  }

  export type counter_transactionsWhereInput = {
    AND?: counter_transactionsWhereInput | counter_transactionsWhereInput[]
    OR?: counter_transactionsWhereInput[]
    NOT?: counter_transactionsWhereInput | counter_transactionsWhereInput[]
    id?: UuidFilter<"counter_transactions"> | string
    counterUserId?: UuidFilter<"counter_transactions"> | string
    bookingId?: UuidFilter<"counter_transactions"> | string
    action?: StringFilter<"counter_transactions"> | string
    note?: StringNullableFilter<"counter_transactions"> | string | null
    createdAt?: DateTimeFilter<"counter_transactions"> | Date | string
    booking?: XOR<BookingsRelationFilter, bookingsWhereInput>
    counterUser?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type counter_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    counterUserId?: SortOrder
    bookingId?: SortOrder
    action?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    booking?: bookingsOrderByWithRelationInput
    counterUser?: usersOrderByWithRelationInput
  }

  export type counter_transactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: counter_transactionsWhereInput | counter_transactionsWhereInput[]
    OR?: counter_transactionsWhereInput[]
    NOT?: counter_transactionsWhereInput | counter_transactionsWhereInput[]
    counterUserId?: UuidFilter<"counter_transactions"> | string
    bookingId?: UuidFilter<"counter_transactions"> | string
    action?: StringFilter<"counter_transactions"> | string
    note?: StringNullableFilter<"counter_transactions"> | string | null
    createdAt?: DateTimeFilter<"counter_transactions"> | Date | string
    booking?: XOR<BookingsRelationFilter, bookingsWhereInput>
    counterUser?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type counter_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    counterUserId?: SortOrder
    bookingId?: SortOrder
    action?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: counter_transactionsCountOrderByAggregateInput
    _max?: counter_transactionsMaxOrderByAggregateInput
    _min?: counter_transactionsMinOrderByAggregateInput
  }

  export type counter_transactionsScalarWhereWithAggregatesInput = {
    AND?: counter_transactionsScalarWhereWithAggregatesInput | counter_transactionsScalarWhereWithAggregatesInput[]
    OR?: counter_transactionsScalarWhereWithAggregatesInput[]
    NOT?: counter_transactionsScalarWhereWithAggregatesInput | counter_transactionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"counter_transactions"> | string
    counterUserId?: UuidWithAggregatesFilter<"counter_transactions"> | string
    bookingId?: UuidWithAggregatesFilter<"counter_transactions"> | string
    action?: StringWithAggregatesFilter<"counter_transactions"> | string
    note?: StringNullableWithAggregatesFilter<"counter_transactions"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"counter_transactions"> | Date | string
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: UuidFilter<"notifications"> | string
    userId?: UuidFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    isRead?: BoolFilter<"notifications"> | boolean
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    userId?: UuidFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    isRead?: BoolFilter<"notifications"> | boolean
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"notifications"> | string
    userId?: UuidWithAggregatesFilter<"notifications"> | string
    title?: StringWithAggregatesFilter<"notifications"> | string
    message?: StringWithAggregatesFilter<"notifications"> | string
    isRead?: BoolWithAggregatesFilter<"notifications"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
  }

  export type usersCreateInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsCreateNestedManyWithoutCreatorInput
    payments?: paymentsCreateNestedManyWithoutPayerInput
    roles?: user_rolesCreateNestedManyWithoutUserInput
    vehicles?: vehiclesCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsCreateNestedManyWithoutWasherInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsUncheckedCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsUncheckedCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyUncheckedCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsUncheckedCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesUncheckedCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsUncheckedCreateNestedManyWithoutCreatorInput
    payments?: paymentsUncheckedCreateNestedManyWithoutPayerInput
    roles?: user_rolesUncheckedCreateNestedManyWithoutUserInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsUncheckedCreateNestedManyWithoutWasherInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUpdateManyWithoutWasherNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUncheckedUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUncheckedUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUncheckedUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUncheckedUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUncheckedUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUncheckedUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUncheckedUpdateManyWithoutWasherNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesCreateInput = {
    name: $Enums.RoleName
    users?: user_rolesCreateNestedManyWithoutRoleInput
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    name: $Enums.RoleName
    users?: user_rolesUncheckedCreateNestedManyWithoutRoleInput
  }

  export type rolesUpdateInput = {
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    users?: user_rolesUpdateManyWithoutRoleNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    users?: user_rolesUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type rolesCreateManyInput = {
    id?: number
    name: $Enums.RoleName
  }

  export type rolesUpdateManyMutationInput = {
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
  }

  export type user_rolesCreateInput = {
    role: rolesCreateNestedOneWithoutUsersInput
    user: usersCreateNestedOneWithoutRolesInput
  }

  export type user_rolesUncheckedCreateInput = {
    userId: string
    roleId: number
  }

  export type user_rolesUpdateInput = {
    role?: rolesUpdateOneRequiredWithoutUsersNestedInput
    user?: usersUpdateOneRequiredWithoutRolesNestedInput
  }

  export type user_rolesUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type user_rolesCreateManyInput = {
    userId: string
    roleId: number
  }

  export type user_rolesUpdateManyMutationInput = {

  }

  export type user_rolesUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type propertiesCreateInput = {
    id?: string
    propertyName: string
    address: string
    pricePerHour?: Decimal | DecimalJsLike | number | string
    pricePerDay?: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PropertyStatus
    totalSlots?: number
    totalNormalSlots?: number
    totalEvSlots?: number
    totalCarWashSlots?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: bookingsCreateNestedManyWithoutPropertyInput
    owner: usersCreateNestedOneWithoutOwnedPropertiesInput
    parkingSlots?: parking_slotsCreateNestedManyWithoutPropertyInput
  }

  export type propertiesUncheckedCreateInput = {
    id?: string
    ownerId: string
    propertyName: string
    address: string
    pricePerHour?: Decimal | DecimalJsLike | number | string
    pricePerDay?: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PropertyStatus
    totalSlots?: number
    totalNormalSlots?: number
    totalEvSlots?: number
    totalCarWashSlots?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: bookingsUncheckedCreateNestedManyWithoutPropertyInput
    parkingSlots?: parking_slotsUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type propertiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    totalSlots?: IntFieldUpdateOperationsInput | number
    totalNormalSlots?: IntFieldUpdateOperationsInput | number
    totalEvSlots?: IntFieldUpdateOperationsInput | number
    totalCarWashSlots?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUpdateManyWithoutPropertyNestedInput
    owner?: usersUpdateOneRequiredWithoutOwnedPropertiesNestedInput
    parkingSlots?: parking_slotsUpdateManyWithoutPropertyNestedInput
  }

  export type propertiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    totalSlots?: IntFieldUpdateOperationsInput | number
    totalNormalSlots?: IntFieldUpdateOperationsInput | number
    totalEvSlots?: IntFieldUpdateOperationsInput | number
    totalCarWashSlots?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUncheckedUpdateManyWithoutPropertyNestedInput
    parkingSlots?: parking_slotsUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type propertiesCreateManyInput = {
    id?: string
    ownerId: string
    propertyName: string
    address: string
    pricePerHour?: Decimal | DecimalJsLike | number | string
    pricePerDay?: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PropertyStatus
    totalSlots?: number
    totalNormalSlots?: number
    totalEvSlots?: number
    totalCarWashSlots?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type propertiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    totalSlots?: IntFieldUpdateOperationsInput | number
    totalNormalSlots?: IntFieldUpdateOperationsInput | number
    totalEvSlots?: IntFieldUpdateOperationsInput | number
    totalCarWashSlots?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type propertiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    totalSlots?: IntFieldUpdateOperationsInput | number
    totalNormalSlots?: IntFieldUpdateOperationsInput | number
    totalEvSlots?: IntFieldUpdateOperationsInput | number
    totalCarWashSlots?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type parking_slotsCreateInput = {
    id?: string
    slotNumber: string
    slotType: $Enums.SlotType
    isActive?: boolean
    createdAt?: Date | string
    bookingSlots?: booking_slotsCreateNestedManyWithoutSlotInput
    property: propertiesCreateNestedOneWithoutParkingSlotsInput
  }

  export type parking_slotsUncheckedCreateInput = {
    id?: string
    propertyId: string
    slotNumber: string
    slotType: $Enums.SlotType
    isActive?: boolean
    createdAt?: Date | string
    bookingSlots?: booking_slotsUncheckedCreateNestedManyWithoutSlotInput
  }

  export type parking_slotsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUpdateManyWithoutSlotNestedInput
    property?: propertiesUpdateOneRequiredWithoutParkingSlotsNestedInput
  }

  export type parking_slotsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type parking_slotsCreateManyInput = {
    id?: string
    propertyId: string
    slotNumber: string
    slotType: $Enums.SlotType
    isActive?: boolean
    createdAt?: Date | string
  }

  export type parking_slotsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type parking_slotsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehiclesCreateInput = {
    id?: string
    vehicleNumber: string
    type?: string | null
    model?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: bookingsCreateNestedManyWithoutVehicleInput
    user: usersCreateNestedOneWithoutVehiclesInput
  }

  export type vehiclesUncheckedCreateInput = {
    id?: string
    userId: string
    vehicleNumber: string
    type?: string | null
    model?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: bookingsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehiclesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUpdateManyWithoutVehicleNestedInput
    user?: usersUpdateOneRequiredWithoutVehiclesNestedInput
  }

  export type vehiclesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehiclesCreateManyInput = {
    id?: string
    userId: string
    vehicleNumber: string
    type?: string | null
    model?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehiclesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehiclesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookingsCreateInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsCreateNestedManyWithoutBookingInput
    customer: usersCreateNestedOneWithoutCustomerBookingsInput
    creator?: usersCreateNestedOneWithoutCreatedBookingsInput
    counterLogs?: counter_transactionsCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryCreateNestedOneWithoutBookingInput
    payments?: paymentsCreateNestedManyWithoutBookingInput
    property: propertiesCreateNestedOneWithoutBookingsInput
    statusHistory?: booking_status_historyCreateNestedManyWithoutBookingInput
    vehicle?: vehiclesCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateInput = {
    id?: string
    customerId: string
    propertyId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsUncheckedCreateNestedManyWithoutBookingInput
    counterLogs?: counter_transactionsUncheckedCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryUncheckedCreateNestedOneWithoutBookingInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingInput
    statusHistory?: booking_status_historyUncheckedCreateNestedManyWithoutBookingInput
  }

  export type bookingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUpdateManyWithoutBookingNestedInput
    customer?: usersUpdateOneRequiredWithoutCustomerBookingsNestedInput
    creator?: usersUpdateOneWithoutCreatedBookingsNestedInput
    counterLogs?: counter_transactionsUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUpdateOneWithoutBookingNestedInput
    payments?: paymentsUpdateManyWithoutBookingNestedInput
    property?: propertiesUpdateOneRequiredWithoutBookingsNestedInput
    statusHistory?: booking_status_historyUpdateManyWithoutBookingNestedInput
    vehicle?: vehiclesUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUncheckedUpdateManyWithoutBookingNestedInput
    counterLogs?: counter_transactionsUncheckedUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUncheckedUpdateOneWithoutBookingNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingNestedInput
    statusHistory?: booking_status_historyUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type bookingsCreateManyInput = {
    id?: string
    customerId: string
    propertyId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type bookingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_slotsCreateInput = {
    id?: string
    createdAt?: Date | string
    booking: bookingsCreateNestedOneWithoutBookingSlotsInput
    slot: parking_slotsCreateNestedOneWithoutBookingSlotsInput
    washJob?: wash_jobsCreateNestedOneWithoutBookingSlotInput
  }

  export type booking_slotsUncheckedCreateInput = {
    id?: string
    bookingId: string
    slotId: string
    createdAt?: Date | string
    washJob?: wash_jobsUncheckedCreateNestedOneWithoutBookingSlotInput
  }

  export type booking_slotsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: bookingsUpdateOneRequiredWithoutBookingSlotsNestedInput
    slot?: parking_slotsUpdateOneRequiredWithoutBookingSlotsNestedInput
    washJob?: wash_jobsUpdateOneWithoutBookingSlotNestedInput
  }

  export type booking_slotsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    washJob?: wash_jobsUncheckedUpdateOneWithoutBookingSlotNestedInput
  }

  export type booking_slotsCreateManyInput = {
    id?: string
    bookingId: string
    slotId: string
    createdAt?: Date | string
  }

  export type booking_slotsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_slotsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_status_historyCreateInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    note?: string | null
    changedAt?: Date | string
    booking: bookingsCreateNestedOneWithoutStatusHistoryInput
    changer?: usersCreateNestedOneWithoutBookingStatusEventsInput
  }

  export type booking_status_historyUncheckedCreateInput = {
    id?: string
    bookingId: string
    oldStatus?: string | null
    newStatus: string
    changedBy?: string | null
    note?: string | null
    changedAt?: Date | string
  }

  export type booking_status_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: bookingsUpdateOneRequiredWithoutStatusHistoryNestedInput
    changer?: usersUpdateOneWithoutBookingStatusEventsNestedInput
  }

  export type booking_status_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_status_historyCreateManyInput = {
    id?: string
    bookingId: string
    oldStatus?: string | null
    newStatus: string
    changedBy?: string | null
    note?: string | null
    changedAt?: Date | string
  }

  export type booking_status_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_status_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_summaryCreateInput = {
    totalAmount?: Decimal | DecimalJsLike | number | string
    onlinePaid?: Decimal | DecimalJsLike | number | string
    cashPaid?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    updatedAt?: Date | string
    booking: bookingsCreateNestedOneWithoutPaymentSummaryInput
  }

  export type payment_summaryUncheckedCreateInput = {
    bookingId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    onlinePaid?: Decimal | DecimalJsLike | number | string
    cashPaid?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    updatedAt?: Date | string
  }

  export type payment_summaryUpdateInput = {
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onlinePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: bookingsUpdateOneRequiredWithoutPaymentSummaryNestedInput
  }

  export type payment_summaryUncheckedUpdateInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onlinePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_summaryCreateManyInput = {
    bookingId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    onlinePaid?: Decimal | DecimalJsLike | number | string
    cashPaid?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    updatedAt?: Date | string
  }

  export type payment_summaryUpdateManyMutationInput = {
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onlinePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_summaryUncheckedUpdateManyInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onlinePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayStatus?: $Enums.GatewayStatus
    gatewayProvider?: string | null
    transactionId?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    booking: bookingsCreateNestedOneWithoutPaymentsInput
    creator?: usersCreateNestedOneWithoutCreatedPaymentsInput
    payer: usersCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id?: string
    bookingId: string
    payerId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayStatus?: $Enums.GatewayStatus
    gatewayProvider?: string | null
    transactionId?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    paidAt?: Date | string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type paymentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: bookingsUpdateOneRequiredWithoutPaymentsNestedInput
    creator?: usersUpdateOneWithoutCreatedPaymentsNestedInput
    payer?: usersUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    payerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsCreateManyInput = {
    id?: string
    bookingId: string
    payerId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayStatus?: $Enums.GatewayStatus
    gatewayProvider?: string | null
    transactionId?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    paidAt?: Date | string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type paymentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    payerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wash_jobsCreateInput = {
    id?: string
    status?: $Enums.WashStatus
    acceptedAt?: Date | string | null
    completedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlot: booking_slotsCreateNestedOneWithoutWashJobInput
    washer?: usersCreateNestedOneWithoutWashJobsInput
  }

  export type wash_jobsUncheckedCreateInput = {
    id?: string
    bookingSlotId: string
    washerId?: string | null
    status?: $Enums.WashStatus
    acceptedAt?: Date | string | null
    completedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type wash_jobsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWashStatusFieldUpdateOperationsInput | $Enums.WashStatus
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlot?: booking_slotsUpdateOneRequiredWithoutWashJobNestedInput
    washer?: usersUpdateOneWithoutWashJobsNestedInput
  }

  export type wash_jobsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingSlotId?: StringFieldUpdateOperationsInput | string
    washerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWashStatusFieldUpdateOperationsInput | $Enums.WashStatus
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wash_jobsCreateManyInput = {
    id?: string
    bookingSlotId: string
    washerId?: string | null
    status?: $Enums.WashStatus
    acceptedAt?: Date | string | null
    completedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type wash_jobsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWashStatusFieldUpdateOperationsInput | $Enums.WashStatus
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wash_jobsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingSlotId?: StringFieldUpdateOperationsInput | string
    washerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWashStatusFieldUpdateOperationsInput | $Enums.WashStatus
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type counter_transactionsCreateInput = {
    id?: string
    action: string
    note?: string | null
    createdAt?: Date | string
    booking: bookingsCreateNestedOneWithoutCounterLogsInput
    counterUser: usersCreateNestedOneWithoutCounterTransactionsInput
  }

  export type counter_transactionsUncheckedCreateInput = {
    id?: string
    counterUserId: string
    bookingId: string
    action: string
    note?: string | null
    createdAt?: Date | string
  }

  export type counter_transactionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: bookingsUpdateOneRequiredWithoutCounterLogsNestedInput
    counterUser?: usersUpdateOneRequiredWithoutCounterTransactionsNestedInput
  }

  export type counter_transactionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    counterUserId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type counter_transactionsCreateManyInput = {
    id?: string
    counterUserId: string
    bookingId: string
    action: string
    note?: string | null
    createdAt?: Date | string
  }

  export type counter_transactionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type counter_transactionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    counterUserId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type notificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type notificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BookingsListRelationFilter = {
    every?: bookingsWhereInput
    some?: bookingsWhereInput
    none?: bookingsWhereInput
  }

  export type Booking_status_historyListRelationFilter = {
    every?: booking_status_historyWhereInput
    some?: booking_status_historyWhereInput
    none?: booking_status_historyWhereInput
  }

  export type Counter_transactionsListRelationFilter = {
    every?: counter_transactionsWhereInput
    some?: counter_transactionsWhereInput
    none?: counter_transactionsWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type PropertiesListRelationFilter = {
    every?: propertiesWhereInput
    some?: propertiesWhereInput
    none?: propertiesWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type User_rolesListRelationFilter = {
    every?: user_rolesWhereInput
    some?: user_rolesWhereInput
    none?: user_rolesWhereInput
  }

  export type VehiclesListRelationFilter = {
    every?: vehiclesWhereInput
    some?: vehiclesWhereInput
    none?: vehiclesWhereInput
  }

  export type Wash_jobsListRelationFilter = {
    every?: wash_jobsWhereInput
    some?: wash_jobsWhereInput
    none?: wash_jobsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type bookingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type booking_status_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type counter_transactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type propertiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehiclesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type wash_jobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    nic?: SortOrder
    residentialAddress?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    nic?: SortOrder
    residentialAddress?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    nic?: SortOrder
    residentialAddress?: SortOrder
    passwordHash?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleNameFilter<$PrismaModel>
    _max?: NestedEnumRoleNameFilter<$PrismaModel>
  }

  export type RolesRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type user_rolesUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: number
  }

  export type user_rolesCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type user_rolesAvgOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type user_rolesMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type user_rolesMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type user_rolesSumOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type Parking_slotsListRelationFilter = {
    every?: parking_slotsWhereInput
    some?: parking_slotsWhereInput
    none?: parking_slotsWhereInput
  }

  export type parking_slotsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type propertiesCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    propertyName?: SortOrder
    address?: SortOrder
    pricePerHour?: SortOrder
    pricePerDay?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    totalSlots?: SortOrder
    totalNormalSlots?: SortOrder
    totalEvSlots?: SortOrder
    totalCarWashSlots?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type propertiesAvgOrderByAggregateInput = {
    pricePerHour?: SortOrder
    pricePerDay?: SortOrder
    totalSlots?: SortOrder
    totalNormalSlots?: SortOrder
    totalEvSlots?: SortOrder
    totalCarWashSlots?: SortOrder
  }

  export type propertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    propertyName?: SortOrder
    address?: SortOrder
    pricePerHour?: SortOrder
    pricePerDay?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    totalSlots?: SortOrder
    totalNormalSlots?: SortOrder
    totalEvSlots?: SortOrder
    totalCarWashSlots?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type propertiesMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    propertyName?: SortOrder
    address?: SortOrder
    pricePerHour?: SortOrder
    pricePerDay?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    totalSlots?: SortOrder
    totalNormalSlots?: SortOrder
    totalEvSlots?: SortOrder
    totalCarWashSlots?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type propertiesSumOrderByAggregateInput = {
    pricePerHour?: SortOrder
    pricePerDay?: SortOrder
    totalSlots?: SortOrder
    totalNormalSlots?: SortOrder
    totalEvSlots?: SortOrder
    totalCarWashSlots?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type EnumSlotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeFilter<$PrismaModel> | $Enums.SlotType
  }

  export type Booking_slotsListRelationFilter = {
    every?: booking_slotsWhereInput
    some?: booking_slotsWhereInput
    none?: booking_slotsWhereInput
  }

  export type PropertiesRelationFilter = {
    is?: propertiesWhereInput
    isNot?: propertiesWhereInput
  }

  export type booking_slotsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type parking_slotsPropertyIdSlotNumberCompoundUniqueInput = {
    propertyId: string
    slotNumber: string
  }

  export type parking_slotsCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    slotNumber?: SortOrder
    slotType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type parking_slotsMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    slotNumber?: SortOrder
    slotType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type parking_slotsMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    slotNumber?: SortOrder
    slotType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSlotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SlotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSlotTypeFilter<$PrismaModel>
    _max?: NestedEnumSlotTypeFilter<$PrismaModel>
  }

  export type vehiclesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleNumber?: SortOrder
    type?: SortOrder
    model?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehiclesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleNumber?: SortOrder
    type?: SortOrder
    model?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehiclesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vehicleNumber?: SortOrder
    type?: SortOrder
    model?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type UsersNullableRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type Payment_summaryNullableRelationFilter = {
    is?: payment_summaryWhereInput | null
    isNot?: payment_summaryWhereInput | null
  }

  export type VehiclesNullableRelationFilter = {
    is?: vehiclesWhereInput | null
    isNot?: vehiclesWhereInput | null
  }

  export type bookingsCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    propertyId?: SortOrder
    vehicleId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    parkingType?: SortOrder
    bookingType?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bookingsMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    propertyId?: SortOrder
    vehicleId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    parkingType?: SortOrder
    bookingType?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bookingsMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    propertyId?: SortOrder
    vehicleId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    parkingType?: SortOrder
    bookingType?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type BookingsRelationFilter = {
    is?: bookingsWhereInput
    isNot?: bookingsWhereInput
  }

  export type Parking_slotsRelationFilter = {
    is?: parking_slotsWhereInput
    isNot?: parking_slotsWhereInput
  }

  export type Wash_jobsNullableRelationFilter = {
    is?: wash_jobsWhereInput | null
    isNot?: wash_jobsWhereInput | null
  }

  export type booking_slotsBookingIdSlotIdCompoundUniqueInput = {
    bookingId: string
    slotId: string
  }

  export type booking_slotsCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    createdAt?: SortOrder
  }

  export type booking_slotsMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    createdAt?: SortOrder
  }

  export type booking_slotsMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    createdAt?: SortOrder
  }

  export type booking_status_historyCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    note?: SortOrder
    changedAt?: SortOrder
  }

  export type booking_status_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    note?: SortOrder
    changedAt?: SortOrder
  }

  export type booking_status_historyMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    note?: SortOrder
    changedAt?: SortOrder
  }

  export type payment_summaryCountOrderByAggregateInput = {
    bookingId?: SortOrder
    totalAmount?: SortOrder
    onlinePaid?: SortOrder
    cashPaid?: SortOrder
    balanceDue?: SortOrder
    currency?: SortOrder
    updatedAt?: SortOrder
  }

  export type payment_summaryAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    onlinePaid?: SortOrder
    cashPaid?: SortOrder
    balanceDue?: SortOrder
  }

  export type payment_summaryMaxOrderByAggregateInput = {
    bookingId?: SortOrder
    totalAmount?: SortOrder
    onlinePaid?: SortOrder
    cashPaid?: SortOrder
    balanceDue?: SortOrder
    currency?: SortOrder
    updatedAt?: SortOrder
  }

  export type payment_summaryMinOrderByAggregateInput = {
    bookingId?: SortOrder
    totalAmount?: SortOrder
    onlinePaid?: SortOrder
    cashPaid?: SortOrder
    balanceDue?: SortOrder
    currency?: SortOrder
    updatedAt?: SortOrder
  }

  export type payment_summarySumOrderByAggregateInput = {
    totalAmount?: SortOrder
    onlinePaid?: SortOrder
    cashPaid?: SortOrder
    balanceDue?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumGatewayStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GatewayStatus | EnumGatewayStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GatewayStatus[] | ListEnumGatewayStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatewayStatus[] | ListEnumGatewayStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGatewayStatusFilter<$PrismaModel> | $Enums.GatewayStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    payerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentStatus?: SortOrder
    gatewayStatus?: SortOrder
    gatewayProvider?: SortOrder
    transactionId?: SortOrder
    cardLast4?: SortOrder
    cardBrand?: SortOrder
    cardExpMonth?: SortOrder
    cardExpYear?: SortOrder
    paidAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    amount?: SortOrder
    cardExpMonth?: SortOrder
    cardExpYear?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    payerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentStatus?: SortOrder
    gatewayStatus?: SortOrder
    gatewayProvider?: SortOrder
    transactionId?: SortOrder
    cardLast4?: SortOrder
    cardBrand?: SortOrder
    cardExpMonth?: SortOrder
    cardExpYear?: SortOrder
    paidAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    payerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    paymentStatus?: SortOrder
    gatewayStatus?: SortOrder
    gatewayProvider?: SortOrder
    transactionId?: SortOrder
    cardLast4?: SortOrder
    cardBrand?: SortOrder
    cardExpMonth?: SortOrder
    cardExpYear?: SortOrder
    paidAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    amount?: SortOrder
    cardExpMonth?: SortOrder
    cardExpYear?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumGatewayStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GatewayStatus | EnumGatewayStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GatewayStatus[] | ListEnumGatewayStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatewayStatus[] | ListEnumGatewayStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGatewayStatusWithAggregatesFilter<$PrismaModel> | $Enums.GatewayStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGatewayStatusFilter<$PrismaModel>
    _max?: NestedEnumGatewayStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumWashStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WashStatus | EnumWashStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WashStatus[] | ListEnumWashStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WashStatus[] | ListEnumWashStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWashStatusFilter<$PrismaModel> | $Enums.WashStatus
  }

  export type Booking_slotsRelationFilter = {
    is?: booking_slotsWhereInput
    isNot?: booking_slotsWhereInput
  }

  export type wash_jobsCountOrderByAggregateInput = {
    id?: SortOrder
    bookingSlotId?: SortOrder
    washerId?: SortOrder
    status?: SortOrder
    acceptedAt?: SortOrder
    completedAt?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wash_jobsMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingSlotId?: SortOrder
    washerId?: SortOrder
    status?: SortOrder
    acceptedAt?: SortOrder
    completedAt?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type wash_jobsMinOrderByAggregateInput = {
    id?: SortOrder
    bookingSlotId?: SortOrder
    washerId?: SortOrder
    status?: SortOrder
    acceptedAt?: SortOrder
    completedAt?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWashStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WashStatus | EnumWashStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WashStatus[] | ListEnumWashStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WashStatus[] | ListEnumWashStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWashStatusWithAggregatesFilter<$PrismaModel> | $Enums.WashStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWashStatusFilter<$PrismaModel>
    _max?: NestedEnumWashStatusFilter<$PrismaModel>
  }

  export type counter_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    counterUserId?: SortOrder
    bookingId?: SortOrder
    action?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type counter_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    counterUserId?: SortOrder
    bookingId?: SortOrder
    action?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type counter_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    counterUserId?: SortOrder
    bookingId?: SortOrder
    action?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type bookingsCreateNestedManyWithoutCustomerInput = {
    create?: XOR<bookingsCreateWithoutCustomerInput, bookingsUncheckedCreateWithoutCustomerInput> | bookingsCreateWithoutCustomerInput[] | bookingsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutCustomerInput | bookingsCreateOrConnectWithoutCustomerInput[]
    createMany?: bookingsCreateManyCustomerInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type bookingsCreateNestedManyWithoutCreatorInput = {
    create?: XOR<bookingsCreateWithoutCreatorInput, bookingsUncheckedCreateWithoutCreatorInput> | bookingsCreateWithoutCreatorInput[] | bookingsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutCreatorInput | bookingsCreateOrConnectWithoutCreatorInput[]
    createMany?: bookingsCreateManyCreatorInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type booking_status_historyCreateNestedManyWithoutChangerInput = {
    create?: XOR<booking_status_historyCreateWithoutChangerInput, booking_status_historyUncheckedCreateWithoutChangerInput> | booking_status_historyCreateWithoutChangerInput[] | booking_status_historyUncheckedCreateWithoutChangerInput[]
    connectOrCreate?: booking_status_historyCreateOrConnectWithoutChangerInput | booking_status_historyCreateOrConnectWithoutChangerInput[]
    createMany?: booking_status_historyCreateManyChangerInputEnvelope
    connect?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
  }

  export type counter_transactionsCreateNestedManyWithoutCounterUserInput = {
    create?: XOR<counter_transactionsCreateWithoutCounterUserInput, counter_transactionsUncheckedCreateWithoutCounterUserInput> | counter_transactionsCreateWithoutCounterUserInput[] | counter_transactionsUncheckedCreateWithoutCounterUserInput[]
    connectOrCreate?: counter_transactionsCreateOrConnectWithoutCounterUserInput | counter_transactionsCreateOrConnectWithoutCounterUserInput[]
    createMany?: counter_transactionsCreateManyCounterUserInputEnvelope
    connect?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationsCreateWithoutUserInput, notificationsUncheckedCreateWithoutUserInput> | notificationsCreateWithoutUserInput[] | notificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUserInput | notificationsCreateOrConnectWithoutUserInput[]
    createMany?: notificationsCreateManyUserInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type propertiesCreateNestedManyWithoutOwnerInput = {
    create?: XOR<propertiesCreateWithoutOwnerInput, propertiesUncheckedCreateWithoutOwnerInput> | propertiesCreateWithoutOwnerInput[] | propertiesUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: propertiesCreateOrConnectWithoutOwnerInput | propertiesCreateOrConnectWithoutOwnerInput[]
    createMany?: propertiesCreateManyOwnerInputEnvelope
    connect?: propertiesWhereUniqueInput | propertiesWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutCreatorInput = {
    create?: XOR<paymentsCreateWithoutCreatorInput, paymentsUncheckedCreateWithoutCreatorInput> | paymentsCreateWithoutCreatorInput[] | paymentsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCreatorInput | paymentsCreateOrConnectWithoutCreatorInput[]
    createMany?: paymentsCreateManyCreatorInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutPayerInput = {
    create?: XOR<paymentsCreateWithoutPayerInput, paymentsUncheckedCreateWithoutPayerInput> | paymentsCreateWithoutPayerInput[] | paymentsUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayerInput | paymentsCreateOrConnectWithoutPayerInput[]
    createMany?: paymentsCreateManyPayerInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type user_rolesCreateNestedManyWithoutUserInput = {
    create?: XOR<user_rolesCreateWithoutUserInput, user_rolesUncheckedCreateWithoutUserInput> | user_rolesCreateWithoutUserInput[] | user_rolesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUserInput | user_rolesCreateOrConnectWithoutUserInput[]
    createMany?: user_rolesCreateManyUserInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type vehiclesCreateNestedManyWithoutUserInput = {
    create?: XOR<vehiclesCreateWithoutUserInput, vehiclesUncheckedCreateWithoutUserInput> | vehiclesCreateWithoutUserInput[] | vehiclesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: vehiclesCreateOrConnectWithoutUserInput | vehiclesCreateOrConnectWithoutUserInput[]
    createMany?: vehiclesCreateManyUserInputEnvelope
    connect?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
  }

  export type wash_jobsCreateNestedManyWithoutWasherInput = {
    create?: XOR<wash_jobsCreateWithoutWasherInput, wash_jobsUncheckedCreateWithoutWasherInput> | wash_jobsCreateWithoutWasherInput[] | wash_jobsUncheckedCreateWithoutWasherInput[]
    connectOrCreate?: wash_jobsCreateOrConnectWithoutWasherInput | wash_jobsCreateOrConnectWithoutWasherInput[]
    createMany?: wash_jobsCreateManyWasherInputEnvelope
    connect?: wash_jobsWhereUniqueInput | wash_jobsWhereUniqueInput[]
  }

  export type bookingsUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<bookingsCreateWithoutCustomerInput, bookingsUncheckedCreateWithoutCustomerInput> | bookingsCreateWithoutCustomerInput[] | bookingsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutCustomerInput | bookingsCreateOrConnectWithoutCustomerInput[]
    createMany?: bookingsCreateManyCustomerInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type bookingsUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<bookingsCreateWithoutCreatorInput, bookingsUncheckedCreateWithoutCreatorInput> | bookingsCreateWithoutCreatorInput[] | bookingsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutCreatorInput | bookingsCreateOrConnectWithoutCreatorInput[]
    createMany?: bookingsCreateManyCreatorInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type booking_status_historyUncheckedCreateNestedManyWithoutChangerInput = {
    create?: XOR<booking_status_historyCreateWithoutChangerInput, booking_status_historyUncheckedCreateWithoutChangerInput> | booking_status_historyCreateWithoutChangerInput[] | booking_status_historyUncheckedCreateWithoutChangerInput[]
    connectOrCreate?: booking_status_historyCreateOrConnectWithoutChangerInput | booking_status_historyCreateOrConnectWithoutChangerInput[]
    createMany?: booking_status_historyCreateManyChangerInputEnvelope
    connect?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
  }

  export type counter_transactionsUncheckedCreateNestedManyWithoutCounterUserInput = {
    create?: XOR<counter_transactionsCreateWithoutCounterUserInput, counter_transactionsUncheckedCreateWithoutCounterUserInput> | counter_transactionsCreateWithoutCounterUserInput[] | counter_transactionsUncheckedCreateWithoutCounterUserInput[]
    connectOrCreate?: counter_transactionsCreateOrConnectWithoutCounterUserInput | counter_transactionsCreateOrConnectWithoutCounterUserInput[]
    createMany?: counter_transactionsCreateManyCounterUserInputEnvelope
    connect?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationsCreateWithoutUserInput, notificationsUncheckedCreateWithoutUserInput> | notificationsCreateWithoutUserInput[] | notificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUserInput | notificationsCreateOrConnectWithoutUserInput[]
    createMany?: notificationsCreateManyUserInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type propertiesUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<propertiesCreateWithoutOwnerInput, propertiesUncheckedCreateWithoutOwnerInput> | propertiesCreateWithoutOwnerInput[] | propertiesUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: propertiesCreateOrConnectWithoutOwnerInput | propertiesCreateOrConnectWithoutOwnerInput[]
    createMany?: propertiesCreateManyOwnerInputEnvelope
    connect?: propertiesWhereUniqueInput | propertiesWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<paymentsCreateWithoutCreatorInput, paymentsUncheckedCreateWithoutCreatorInput> | paymentsCreateWithoutCreatorInput[] | paymentsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCreatorInput | paymentsCreateOrConnectWithoutCreatorInput[]
    createMany?: paymentsCreateManyCreatorInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutPayerInput = {
    create?: XOR<paymentsCreateWithoutPayerInput, paymentsUncheckedCreateWithoutPayerInput> | paymentsCreateWithoutPayerInput[] | paymentsUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayerInput | paymentsCreateOrConnectWithoutPayerInput[]
    createMany?: paymentsCreateManyPayerInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type user_rolesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_rolesCreateWithoutUserInput, user_rolesUncheckedCreateWithoutUserInput> | user_rolesCreateWithoutUserInput[] | user_rolesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUserInput | user_rolesCreateOrConnectWithoutUserInput[]
    createMany?: user_rolesCreateManyUserInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type vehiclesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<vehiclesCreateWithoutUserInput, vehiclesUncheckedCreateWithoutUserInput> | vehiclesCreateWithoutUserInput[] | vehiclesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: vehiclesCreateOrConnectWithoutUserInput | vehiclesCreateOrConnectWithoutUserInput[]
    createMany?: vehiclesCreateManyUserInputEnvelope
    connect?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
  }

  export type wash_jobsUncheckedCreateNestedManyWithoutWasherInput = {
    create?: XOR<wash_jobsCreateWithoutWasherInput, wash_jobsUncheckedCreateWithoutWasherInput> | wash_jobsCreateWithoutWasherInput[] | wash_jobsUncheckedCreateWithoutWasherInput[]
    connectOrCreate?: wash_jobsCreateOrConnectWithoutWasherInput | wash_jobsCreateOrConnectWithoutWasherInput[]
    createMany?: wash_jobsCreateManyWasherInputEnvelope
    connect?: wash_jobsWhereUniqueInput | wash_jobsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type bookingsUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<bookingsCreateWithoutCustomerInput, bookingsUncheckedCreateWithoutCustomerInput> | bookingsCreateWithoutCustomerInput[] | bookingsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutCustomerInput | bookingsCreateOrConnectWithoutCustomerInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutCustomerInput | bookingsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: bookingsCreateManyCustomerInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutCustomerInput | bookingsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutCustomerInput | bookingsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type bookingsUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<bookingsCreateWithoutCreatorInput, bookingsUncheckedCreateWithoutCreatorInput> | bookingsCreateWithoutCreatorInput[] | bookingsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutCreatorInput | bookingsCreateOrConnectWithoutCreatorInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutCreatorInput | bookingsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: bookingsCreateManyCreatorInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutCreatorInput | bookingsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutCreatorInput | bookingsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type booking_status_historyUpdateManyWithoutChangerNestedInput = {
    create?: XOR<booking_status_historyCreateWithoutChangerInput, booking_status_historyUncheckedCreateWithoutChangerInput> | booking_status_historyCreateWithoutChangerInput[] | booking_status_historyUncheckedCreateWithoutChangerInput[]
    connectOrCreate?: booking_status_historyCreateOrConnectWithoutChangerInput | booking_status_historyCreateOrConnectWithoutChangerInput[]
    upsert?: booking_status_historyUpsertWithWhereUniqueWithoutChangerInput | booking_status_historyUpsertWithWhereUniqueWithoutChangerInput[]
    createMany?: booking_status_historyCreateManyChangerInputEnvelope
    set?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    disconnect?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    delete?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    connect?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    update?: booking_status_historyUpdateWithWhereUniqueWithoutChangerInput | booking_status_historyUpdateWithWhereUniqueWithoutChangerInput[]
    updateMany?: booking_status_historyUpdateManyWithWhereWithoutChangerInput | booking_status_historyUpdateManyWithWhereWithoutChangerInput[]
    deleteMany?: booking_status_historyScalarWhereInput | booking_status_historyScalarWhereInput[]
  }

  export type counter_transactionsUpdateManyWithoutCounterUserNestedInput = {
    create?: XOR<counter_transactionsCreateWithoutCounterUserInput, counter_transactionsUncheckedCreateWithoutCounterUserInput> | counter_transactionsCreateWithoutCounterUserInput[] | counter_transactionsUncheckedCreateWithoutCounterUserInput[]
    connectOrCreate?: counter_transactionsCreateOrConnectWithoutCounterUserInput | counter_transactionsCreateOrConnectWithoutCounterUserInput[]
    upsert?: counter_transactionsUpsertWithWhereUniqueWithoutCounterUserInput | counter_transactionsUpsertWithWhereUniqueWithoutCounterUserInput[]
    createMany?: counter_transactionsCreateManyCounterUserInputEnvelope
    set?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    disconnect?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    delete?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    connect?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    update?: counter_transactionsUpdateWithWhereUniqueWithoutCounterUserInput | counter_transactionsUpdateWithWhereUniqueWithoutCounterUserInput[]
    updateMany?: counter_transactionsUpdateManyWithWhereWithoutCounterUserInput | counter_transactionsUpdateManyWithWhereWithoutCounterUserInput[]
    deleteMany?: counter_transactionsScalarWhereInput | counter_transactionsScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationsCreateWithoutUserInput, notificationsUncheckedCreateWithoutUserInput> | notificationsCreateWithoutUserInput[] | notificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUserInput | notificationsCreateOrConnectWithoutUserInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUserInput | notificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationsCreateManyUserInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUserInput | notificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUserInput | notificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type propertiesUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<propertiesCreateWithoutOwnerInput, propertiesUncheckedCreateWithoutOwnerInput> | propertiesCreateWithoutOwnerInput[] | propertiesUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: propertiesCreateOrConnectWithoutOwnerInput | propertiesCreateOrConnectWithoutOwnerInput[]
    upsert?: propertiesUpsertWithWhereUniqueWithoutOwnerInput | propertiesUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: propertiesCreateManyOwnerInputEnvelope
    set?: propertiesWhereUniqueInput | propertiesWhereUniqueInput[]
    disconnect?: propertiesWhereUniqueInput | propertiesWhereUniqueInput[]
    delete?: propertiesWhereUniqueInput | propertiesWhereUniqueInput[]
    connect?: propertiesWhereUniqueInput | propertiesWhereUniqueInput[]
    update?: propertiesUpdateWithWhereUniqueWithoutOwnerInput | propertiesUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: propertiesUpdateManyWithWhereWithoutOwnerInput | propertiesUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: propertiesScalarWhereInput | propertiesScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<paymentsCreateWithoutCreatorInput, paymentsUncheckedCreateWithoutCreatorInput> | paymentsCreateWithoutCreatorInput[] | paymentsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCreatorInput | paymentsCreateOrConnectWithoutCreatorInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutCreatorInput | paymentsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: paymentsCreateManyCreatorInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutCreatorInput | paymentsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutCreatorInput | paymentsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutPayerNestedInput = {
    create?: XOR<paymentsCreateWithoutPayerInput, paymentsUncheckedCreateWithoutPayerInput> | paymentsCreateWithoutPayerInput[] | paymentsUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayerInput | paymentsCreateOrConnectWithoutPayerInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutPayerInput | paymentsUpsertWithWhereUniqueWithoutPayerInput[]
    createMany?: paymentsCreateManyPayerInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutPayerInput | paymentsUpdateWithWhereUniqueWithoutPayerInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutPayerInput | paymentsUpdateManyWithWhereWithoutPayerInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type user_rolesUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_rolesCreateWithoutUserInput, user_rolesUncheckedCreateWithoutUserInput> | user_rolesCreateWithoutUserInput[] | user_rolesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUserInput | user_rolesCreateOrConnectWithoutUserInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutUserInput | user_rolesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_rolesCreateManyUserInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutUserInput | user_rolesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutUserInput | user_rolesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type vehiclesUpdateManyWithoutUserNestedInput = {
    create?: XOR<vehiclesCreateWithoutUserInput, vehiclesUncheckedCreateWithoutUserInput> | vehiclesCreateWithoutUserInput[] | vehiclesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: vehiclesCreateOrConnectWithoutUserInput | vehiclesCreateOrConnectWithoutUserInput[]
    upsert?: vehiclesUpsertWithWhereUniqueWithoutUserInput | vehiclesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: vehiclesCreateManyUserInputEnvelope
    set?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    disconnect?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    delete?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    connect?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    update?: vehiclesUpdateWithWhereUniqueWithoutUserInput | vehiclesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: vehiclesUpdateManyWithWhereWithoutUserInput | vehiclesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: vehiclesScalarWhereInput | vehiclesScalarWhereInput[]
  }

  export type wash_jobsUpdateManyWithoutWasherNestedInput = {
    create?: XOR<wash_jobsCreateWithoutWasherInput, wash_jobsUncheckedCreateWithoutWasherInput> | wash_jobsCreateWithoutWasherInput[] | wash_jobsUncheckedCreateWithoutWasherInput[]
    connectOrCreate?: wash_jobsCreateOrConnectWithoutWasherInput | wash_jobsCreateOrConnectWithoutWasherInput[]
    upsert?: wash_jobsUpsertWithWhereUniqueWithoutWasherInput | wash_jobsUpsertWithWhereUniqueWithoutWasherInput[]
    createMany?: wash_jobsCreateManyWasherInputEnvelope
    set?: wash_jobsWhereUniqueInput | wash_jobsWhereUniqueInput[]
    disconnect?: wash_jobsWhereUniqueInput | wash_jobsWhereUniqueInput[]
    delete?: wash_jobsWhereUniqueInput | wash_jobsWhereUniqueInput[]
    connect?: wash_jobsWhereUniqueInput | wash_jobsWhereUniqueInput[]
    update?: wash_jobsUpdateWithWhereUniqueWithoutWasherInput | wash_jobsUpdateWithWhereUniqueWithoutWasherInput[]
    updateMany?: wash_jobsUpdateManyWithWhereWithoutWasherInput | wash_jobsUpdateManyWithWhereWithoutWasherInput[]
    deleteMany?: wash_jobsScalarWhereInput | wash_jobsScalarWhereInput[]
  }

  export type bookingsUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<bookingsCreateWithoutCustomerInput, bookingsUncheckedCreateWithoutCustomerInput> | bookingsCreateWithoutCustomerInput[] | bookingsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutCustomerInput | bookingsCreateOrConnectWithoutCustomerInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutCustomerInput | bookingsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: bookingsCreateManyCustomerInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutCustomerInput | bookingsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutCustomerInput | bookingsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type bookingsUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<bookingsCreateWithoutCreatorInput, bookingsUncheckedCreateWithoutCreatorInput> | bookingsCreateWithoutCreatorInput[] | bookingsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutCreatorInput | bookingsCreateOrConnectWithoutCreatorInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutCreatorInput | bookingsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: bookingsCreateManyCreatorInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutCreatorInput | bookingsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutCreatorInput | bookingsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type booking_status_historyUncheckedUpdateManyWithoutChangerNestedInput = {
    create?: XOR<booking_status_historyCreateWithoutChangerInput, booking_status_historyUncheckedCreateWithoutChangerInput> | booking_status_historyCreateWithoutChangerInput[] | booking_status_historyUncheckedCreateWithoutChangerInput[]
    connectOrCreate?: booking_status_historyCreateOrConnectWithoutChangerInput | booking_status_historyCreateOrConnectWithoutChangerInput[]
    upsert?: booking_status_historyUpsertWithWhereUniqueWithoutChangerInput | booking_status_historyUpsertWithWhereUniqueWithoutChangerInput[]
    createMany?: booking_status_historyCreateManyChangerInputEnvelope
    set?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    disconnect?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    delete?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    connect?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    update?: booking_status_historyUpdateWithWhereUniqueWithoutChangerInput | booking_status_historyUpdateWithWhereUniqueWithoutChangerInput[]
    updateMany?: booking_status_historyUpdateManyWithWhereWithoutChangerInput | booking_status_historyUpdateManyWithWhereWithoutChangerInput[]
    deleteMany?: booking_status_historyScalarWhereInput | booking_status_historyScalarWhereInput[]
  }

  export type counter_transactionsUncheckedUpdateManyWithoutCounterUserNestedInput = {
    create?: XOR<counter_transactionsCreateWithoutCounterUserInput, counter_transactionsUncheckedCreateWithoutCounterUserInput> | counter_transactionsCreateWithoutCounterUserInput[] | counter_transactionsUncheckedCreateWithoutCounterUserInput[]
    connectOrCreate?: counter_transactionsCreateOrConnectWithoutCounterUserInput | counter_transactionsCreateOrConnectWithoutCounterUserInput[]
    upsert?: counter_transactionsUpsertWithWhereUniqueWithoutCounterUserInput | counter_transactionsUpsertWithWhereUniqueWithoutCounterUserInput[]
    createMany?: counter_transactionsCreateManyCounterUserInputEnvelope
    set?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    disconnect?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    delete?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    connect?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    update?: counter_transactionsUpdateWithWhereUniqueWithoutCounterUserInput | counter_transactionsUpdateWithWhereUniqueWithoutCounterUserInput[]
    updateMany?: counter_transactionsUpdateManyWithWhereWithoutCounterUserInput | counter_transactionsUpdateManyWithWhereWithoutCounterUserInput[]
    deleteMany?: counter_transactionsScalarWhereInput | counter_transactionsScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationsCreateWithoutUserInput, notificationsUncheckedCreateWithoutUserInput> | notificationsCreateWithoutUserInput[] | notificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUserInput | notificationsCreateOrConnectWithoutUserInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUserInput | notificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationsCreateManyUserInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUserInput | notificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUserInput | notificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type propertiesUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<propertiesCreateWithoutOwnerInput, propertiesUncheckedCreateWithoutOwnerInput> | propertiesCreateWithoutOwnerInput[] | propertiesUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: propertiesCreateOrConnectWithoutOwnerInput | propertiesCreateOrConnectWithoutOwnerInput[]
    upsert?: propertiesUpsertWithWhereUniqueWithoutOwnerInput | propertiesUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: propertiesCreateManyOwnerInputEnvelope
    set?: propertiesWhereUniqueInput | propertiesWhereUniqueInput[]
    disconnect?: propertiesWhereUniqueInput | propertiesWhereUniqueInput[]
    delete?: propertiesWhereUniqueInput | propertiesWhereUniqueInput[]
    connect?: propertiesWhereUniqueInput | propertiesWhereUniqueInput[]
    update?: propertiesUpdateWithWhereUniqueWithoutOwnerInput | propertiesUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: propertiesUpdateManyWithWhereWithoutOwnerInput | propertiesUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: propertiesScalarWhereInput | propertiesScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<paymentsCreateWithoutCreatorInput, paymentsUncheckedCreateWithoutCreatorInput> | paymentsCreateWithoutCreatorInput[] | paymentsUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCreatorInput | paymentsCreateOrConnectWithoutCreatorInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutCreatorInput | paymentsUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: paymentsCreateManyCreatorInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutCreatorInput | paymentsUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutCreatorInput | paymentsUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutPayerNestedInput = {
    create?: XOR<paymentsCreateWithoutPayerInput, paymentsUncheckedCreateWithoutPayerInput> | paymentsCreateWithoutPayerInput[] | paymentsUncheckedCreateWithoutPayerInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayerInput | paymentsCreateOrConnectWithoutPayerInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutPayerInput | paymentsUpsertWithWhereUniqueWithoutPayerInput[]
    createMany?: paymentsCreateManyPayerInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutPayerInput | paymentsUpdateWithWhereUniqueWithoutPayerInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutPayerInput | paymentsUpdateManyWithWhereWithoutPayerInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type user_rolesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_rolesCreateWithoutUserInput, user_rolesUncheckedCreateWithoutUserInput> | user_rolesCreateWithoutUserInput[] | user_rolesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUserInput | user_rolesCreateOrConnectWithoutUserInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutUserInput | user_rolesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_rolesCreateManyUserInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutUserInput | user_rolesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutUserInput | user_rolesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type vehiclesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<vehiclesCreateWithoutUserInput, vehiclesUncheckedCreateWithoutUserInput> | vehiclesCreateWithoutUserInput[] | vehiclesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: vehiclesCreateOrConnectWithoutUserInput | vehiclesCreateOrConnectWithoutUserInput[]
    upsert?: vehiclesUpsertWithWhereUniqueWithoutUserInput | vehiclesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: vehiclesCreateManyUserInputEnvelope
    set?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    disconnect?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    delete?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    connect?: vehiclesWhereUniqueInput | vehiclesWhereUniqueInput[]
    update?: vehiclesUpdateWithWhereUniqueWithoutUserInput | vehiclesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: vehiclesUpdateManyWithWhereWithoutUserInput | vehiclesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: vehiclesScalarWhereInput | vehiclesScalarWhereInput[]
  }

  export type wash_jobsUncheckedUpdateManyWithoutWasherNestedInput = {
    create?: XOR<wash_jobsCreateWithoutWasherInput, wash_jobsUncheckedCreateWithoutWasherInput> | wash_jobsCreateWithoutWasherInput[] | wash_jobsUncheckedCreateWithoutWasherInput[]
    connectOrCreate?: wash_jobsCreateOrConnectWithoutWasherInput | wash_jobsCreateOrConnectWithoutWasherInput[]
    upsert?: wash_jobsUpsertWithWhereUniqueWithoutWasherInput | wash_jobsUpsertWithWhereUniqueWithoutWasherInput[]
    createMany?: wash_jobsCreateManyWasherInputEnvelope
    set?: wash_jobsWhereUniqueInput | wash_jobsWhereUniqueInput[]
    disconnect?: wash_jobsWhereUniqueInput | wash_jobsWhereUniqueInput[]
    delete?: wash_jobsWhereUniqueInput | wash_jobsWhereUniqueInput[]
    connect?: wash_jobsWhereUniqueInput | wash_jobsWhereUniqueInput[]
    update?: wash_jobsUpdateWithWhereUniqueWithoutWasherInput | wash_jobsUpdateWithWhereUniqueWithoutWasherInput[]
    updateMany?: wash_jobsUpdateManyWithWhereWithoutWasherInput | wash_jobsUpdateManyWithWhereWithoutWasherInput[]
    deleteMany?: wash_jobsScalarWhereInput | wash_jobsScalarWhereInput[]
  }

  export type user_rolesCreateNestedManyWithoutRoleInput = {
    create?: XOR<user_rolesCreateWithoutRoleInput, user_rolesUncheckedCreateWithoutRoleInput> | user_rolesCreateWithoutRoleInput[] | user_rolesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRoleInput | user_rolesCreateOrConnectWithoutRoleInput[]
    createMany?: user_rolesCreateManyRoleInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type user_rolesUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<user_rolesCreateWithoutRoleInput, user_rolesUncheckedCreateWithoutRoleInput> | user_rolesCreateWithoutRoleInput[] | user_rolesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRoleInput | user_rolesCreateOrConnectWithoutRoleInput[]
    createMany?: user_rolesCreateManyRoleInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type EnumRoleNameFieldUpdateOperationsInput = {
    set?: $Enums.RoleName
  }

  export type user_rolesUpdateManyWithoutRoleNestedInput = {
    create?: XOR<user_rolesCreateWithoutRoleInput, user_rolesUncheckedCreateWithoutRoleInput> | user_rolesCreateWithoutRoleInput[] | user_rolesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRoleInput | user_rolesCreateOrConnectWithoutRoleInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutRoleInput | user_rolesUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: user_rolesCreateManyRoleInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutRoleInput | user_rolesUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutRoleInput | user_rolesUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type user_rolesUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<user_rolesCreateWithoutRoleInput, user_rolesUncheckedCreateWithoutRoleInput> | user_rolesCreateWithoutRoleInput[] | user_rolesUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRoleInput | user_rolesCreateOrConnectWithoutRoleInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutRoleInput | user_rolesUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: user_rolesCreateManyRoleInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutRoleInput | user_rolesUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutRoleInput | user_rolesUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type rolesCreateNestedOneWithoutUsersInput = {
    create?: XOR<rolesCreateWithoutUsersInput, rolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUsersInput
    connect?: rolesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutRolesInput = {
    create?: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutRolesInput
    connect?: usersWhereUniqueInput
  }

  export type rolesUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<rolesCreateWithoutUsersInput, rolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUsersInput
    upsert?: rolesUpsertWithoutUsersInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutUsersInput, rolesUpdateWithoutUsersInput>, rolesUncheckedUpdateWithoutUsersInput>
  }

  export type usersUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutRolesInput
    upsert?: usersUpsertWithoutRolesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRolesInput, usersUpdateWithoutRolesInput>, usersUncheckedUpdateWithoutRolesInput>
  }

  export type bookingsCreateNestedManyWithoutPropertyInput = {
    create?: XOR<bookingsCreateWithoutPropertyInput, bookingsUncheckedCreateWithoutPropertyInput> | bookingsCreateWithoutPropertyInput[] | bookingsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutPropertyInput | bookingsCreateOrConnectWithoutPropertyInput[]
    createMany?: bookingsCreateManyPropertyInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutOwnedPropertiesInput = {
    create?: XOR<usersCreateWithoutOwnedPropertiesInput, usersUncheckedCreateWithoutOwnedPropertiesInput>
    connectOrCreate?: usersCreateOrConnectWithoutOwnedPropertiesInput
    connect?: usersWhereUniqueInput
  }

  export type parking_slotsCreateNestedManyWithoutPropertyInput = {
    create?: XOR<parking_slotsCreateWithoutPropertyInput, parking_slotsUncheckedCreateWithoutPropertyInput> | parking_slotsCreateWithoutPropertyInput[] | parking_slotsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: parking_slotsCreateOrConnectWithoutPropertyInput | parking_slotsCreateOrConnectWithoutPropertyInput[]
    createMany?: parking_slotsCreateManyPropertyInputEnvelope
    connect?: parking_slotsWhereUniqueInput | parking_slotsWhereUniqueInput[]
  }

  export type bookingsUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<bookingsCreateWithoutPropertyInput, bookingsUncheckedCreateWithoutPropertyInput> | bookingsCreateWithoutPropertyInput[] | bookingsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutPropertyInput | bookingsCreateOrConnectWithoutPropertyInput[]
    createMany?: bookingsCreateManyPropertyInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type parking_slotsUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<parking_slotsCreateWithoutPropertyInput, parking_slotsUncheckedCreateWithoutPropertyInput> | parking_slotsCreateWithoutPropertyInput[] | parking_slotsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: parking_slotsCreateOrConnectWithoutPropertyInput | parking_slotsCreateOrConnectWithoutPropertyInput[]
    createMany?: parking_slotsCreateManyPropertyInputEnvelope
    connect?: parking_slotsWhereUniqueInput | parking_slotsWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumPropertyStatusFieldUpdateOperationsInput = {
    set?: $Enums.PropertyStatus
  }

  export type bookingsUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<bookingsCreateWithoutPropertyInput, bookingsUncheckedCreateWithoutPropertyInput> | bookingsCreateWithoutPropertyInput[] | bookingsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutPropertyInput | bookingsCreateOrConnectWithoutPropertyInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutPropertyInput | bookingsUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: bookingsCreateManyPropertyInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutPropertyInput | bookingsUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutPropertyInput | bookingsUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutOwnedPropertiesNestedInput = {
    create?: XOR<usersCreateWithoutOwnedPropertiesInput, usersUncheckedCreateWithoutOwnedPropertiesInput>
    connectOrCreate?: usersCreateOrConnectWithoutOwnedPropertiesInput
    upsert?: usersUpsertWithoutOwnedPropertiesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOwnedPropertiesInput, usersUpdateWithoutOwnedPropertiesInput>, usersUncheckedUpdateWithoutOwnedPropertiesInput>
  }

  export type parking_slotsUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<parking_slotsCreateWithoutPropertyInput, parking_slotsUncheckedCreateWithoutPropertyInput> | parking_slotsCreateWithoutPropertyInput[] | parking_slotsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: parking_slotsCreateOrConnectWithoutPropertyInput | parking_slotsCreateOrConnectWithoutPropertyInput[]
    upsert?: parking_slotsUpsertWithWhereUniqueWithoutPropertyInput | parking_slotsUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: parking_slotsCreateManyPropertyInputEnvelope
    set?: parking_slotsWhereUniqueInput | parking_slotsWhereUniqueInput[]
    disconnect?: parking_slotsWhereUniqueInput | parking_slotsWhereUniqueInput[]
    delete?: parking_slotsWhereUniqueInput | parking_slotsWhereUniqueInput[]
    connect?: parking_slotsWhereUniqueInput | parking_slotsWhereUniqueInput[]
    update?: parking_slotsUpdateWithWhereUniqueWithoutPropertyInput | parking_slotsUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: parking_slotsUpdateManyWithWhereWithoutPropertyInput | parking_slotsUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: parking_slotsScalarWhereInput | parking_slotsScalarWhereInput[]
  }

  export type bookingsUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<bookingsCreateWithoutPropertyInput, bookingsUncheckedCreateWithoutPropertyInput> | bookingsCreateWithoutPropertyInput[] | bookingsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutPropertyInput | bookingsCreateOrConnectWithoutPropertyInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutPropertyInput | bookingsUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: bookingsCreateManyPropertyInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutPropertyInput | bookingsUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutPropertyInput | bookingsUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type parking_slotsUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<parking_slotsCreateWithoutPropertyInput, parking_slotsUncheckedCreateWithoutPropertyInput> | parking_slotsCreateWithoutPropertyInput[] | parking_slotsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: parking_slotsCreateOrConnectWithoutPropertyInput | parking_slotsCreateOrConnectWithoutPropertyInput[]
    upsert?: parking_slotsUpsertWithWhereUniqueWithoutPropertyInput | parking_slotsUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: parking_slotsCreateManyPropertyInputEnvelope
    set?: parking_slotsWhereUniqueInput | parking_slotsWhereUniqueInput[]
    disconnect?: parking_slotsWhereUniqueInput | parking_slotsWhereUniqueInput[]
    delete?: parking_slotsWhereUniqueInput | parking_slotsWhereUniqueInput[]
    connect?: parking_slotsWhereUniqueInput | parking_slotsWhereUniqueInput[]
    update?: parking_slotsUpdateWithWhereUniqueWithoutPropertyInput | parking_slotsUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: parking_slotsUpdateManyWithWhereWithoutPropertyInput | parking_slotsUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: parking_slotsScalarWhereInput | parking_slotsScalarWhereInput[]
  }

  export type booking_slotsCreateNestedManyWithoutSlotInput = {
    create?: XOR<booking_slotsCreateWithoutSlotInput, booking_slotsUncheckedCreateWithoutSlotInput> | booking_slotsCreateWithoutSlotInput[] | booking_slotsUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: booking_slotsCreateOrConnectWithoutSlotInput | booking_slotsCreateOrConnectWithoutSlotInput[]
    createMany?: booking_slotsCreateManySlotInputEnvelope
    connect?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
  }

  export type propertiesCreateNestedOneWithoutParkingSlotsInput = {
    create?: XOR<propertiesCreateWithoutParkingSlotsInput, propertiesUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: propertiesCreateOrConnectWithoutParkingSlotsInput
    connect?: propertiesWhereUniqueInput
  }

  export type booking_slotsUncheckedCreateNestedManyWithoutSlotInput = {
    create?: XOR<booking_slotsCreateWithoutSlotInput, booking_slotsUncheckedCreateWithoutSlotInput> | booking_slotsCreateWithoutSlotInput[] | booking_slotsUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: booking_slotsCreateOrConnectWithoutSlotInput | booking_slotsCreateOrConnectWithoutSlotInput[]
    createMany?: booking_slotsCreateManySlotInputEnvelope
    connect?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
  }

  export type EnumSlotTypeFieldUpdateOperationsInput = {
    set?: $Enums.SlotType
  }

  export type booking_slotsUpdateManyWithoutSlotNestedInput = {
    create?: XOR<booking_slotsCreateWithoutSlotInput, booking_slotsUncheckedCreateWithoutSlotInput> | booking_slotsCreateWithoutSlotInput[] | booking_slotsUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: booking_slotsCreateOrConnectWithoutSlotInput | booking_slotsCreateOrConnectWithoutSlotInput[]
    upsert?: booking_slotsUpsertWithWhereUniqueWithoutSlotInput | booking_slotsUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: booking_slotsCreateManySlotInputEnvelope
    set?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    disconnect?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    delete?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    connect?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    update?: booking_slotsUpdateWithWhereUniqueWithoutSlotInput | booking_slotsUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: booking_slotsUpdateManyWithWhereWithoutSlotInput | booking_slotsUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: booking_slotsScalarWhereInput | booking_slotsScalarWhereInput[]
  }

  export type propertiesUpdateOneRequiredWithoutParkingSlotsNestedInput = {
    create?: XOR<propertiesCreateWithoutParkingSlotsInput, propertiesUncheckedCreateWithoutParkingSlotsInput>
    connectOrCreate?: propertiesCreateOrConnectWithoutParkingSlotsInput
    upsert?: propertiesUpsertWithoutParkingSlotsInput
    connect?: propertiesWhereUniqueInput
    update?: XOR<XOR<propertiesUpdateToOneWithWhereWithoutParkingSlotsInput, propertiesUpdateWithoutParkingSlotsInput>, propertiesUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type booking_slotsUncheckedUpdateManyWithoutSlotNestedInput = {
    create?: XOR<booking_slotsCreateWithoutSlotInput, booking_slotsUncheckedCreateWithoutSlotInput> | booking_slotsCreateWithoutSlotInput[] | booking_slotsUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: booking_slotsCreateOrConnectWithoutSlotInput | booking_slotsCreateOrConnectWithoutSlotInput[]
    upsert?: booking_slotsUpsertWithWhereUniqueWithoutSlotInput | booking_slotsUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: booking_slotsCreateManySlotInputEnvelope
    set?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    disconnect?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    delete?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    connect?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    update?: booking_slotsUpdateWithWhereUniqueWithoutSlotInput | booking_slotsUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: booking_slotsUpdateManyWithWhereWithoutSlotInput | booking_slotsUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: booking_slotsScalarWhereInput | booking_slotsScalarWhereInput[]
  }

  export type bookingsCreateNestedManyWithoutVehicleInput = {
    create?: XOR<bookingsCreateWithoutVehicleInput, bookingsUncheckedCreateWithoutVehicleInput> | bookingsCreateWithoutVehicleInput[] | bookingsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutVehicleInput | bookingsCreateOrConnectWithoutVehicleInput[]
    createMany?: bookingsCreateManyVehicleInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<usersCreateWithoutVehiclesInput, usersUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: usersCreateOrConnectWithoutVehiclesInput
    connect?: usersWhereUniqueInput
  }

  export type bookingsUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<bookingsCreateWithoutVehicleInput, bookingsUncheckedCreateWithoutVehicleInput> | bookingsCreateWithoutVehicleInput[] | bookingsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutVehicleInput | bookingsCreateOrConnectWithoutVehicleInput[]
    createMany?: bookingsCreateManyVehicleInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type bookingsUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<bookingsCreateWithoutVehicleInput, bookingsUncheckedCreateWithoutVehicleInput> | bookingsCreateWithoutVehicleInput[] | bookingsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutVehicleInput | bookingsCreateOrConnectWithoutVehicleInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutVehicleInput | bookingsUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: bookingsCreateManyVehicleInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutVehicleInput | bookingsUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutVehicleInput | bookingsUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutVehiclesNestedInput = {
    create?: XOR<usersCreateWithoutVehiclesInput, usersUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: usersCreateOrConnectWithoutVehiclesInput
    upsert?: usersUpsertWithoutVehiclesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutVehiclesInput, usersUpdateWithoutVehiclesInput>, usersUncheckedUpdateWithoutVehiclesInput>
  }

  export type bookingsUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<bookingsCreateWithoutVehicleInput, bookingsUncheckedCreateWithoutVehicleInput> | bookingsCreateWithoutVehicleInput[] | bookingsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutVehicleInput | bookingsCreateOrConnectWithoutVehicleInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutVehicleInput | bookingsUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: bookingsCreateManyVehicleInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutVehicleInput | bookingsUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutVehicleInput | bookingsUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type booking_slotsCreateNestedManyWithoutBookingInput = {
    create?: XOR<booking_slotsCreateWithoutBookingInput, booking_slotsUncheckedCreateWithoutBookingInput> | booking_slotsCreateWithoutBookingInput[] | booking_slotsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: booking_slotsCreateOrConnectWithoutBookingInput | booking_slotsCreateOrConnectWithoutBookingInput[]
    createMany?: booking_slotsCreateManyBookingInputEnvelope
    connect?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutCustomerBookingsInput = {
    create?: XOR<usersCreateWithoutCustomerBookingsInput, usersUncheckedCreateWithoutCustomerBookingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCustomerBookingsInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCreatedBookingsInput = {
    create?: XOR<usersCreateWithoutCreatedBookingsInput, usersUncheckedCreateWithoutCreatedBookingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCreatedBookingsInput
    connect?: usersWhereUniqueInput
  }

  export type counter_transactionsCreateNestedManyWithoutBookingInput = {
    create?: XOR<counter_transactionsCreateWithoutBookingInput, counter_transactionsUncheckedCreateWithoutBookingInput> | counter_transactionsCreateWithoutBookingInput[] | counter_transactionsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: counter_transactionsCreateOrConnectWithoutBookingInput | counter_transactionsCreateOrConnectWithoutBookingInput[]
    createMany?: counter_transactionsCreateManyBookingInputEnvelope
    connect?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
  }

  export type payment_summaryCreateNestedOneWithoutBookingInput = {
    create?: XOR<payment_summaryCreateWithoutBookingInput, payment_summaryUncheckedCreateWithoutBookingInput>
    connectOrCreate?: payment_summaryCreateOrConnectWithoutBookingInput
    connect?: payment_summaryWhereUniqueInput
  }

  export type paymentsCreateNestedManyWithoutBookingInput = {
    create?: XOR<paymentsCreateWithoutBookingInput, paymentsUncheckedCreateWithoutBookingInput> | paymentsCreateWithoutBookingInput[] | paymentsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutBookingInput | paymentsCreateOrConnectWithoutBookingInput[]
    createMany?: paymentsCreateManyBookingInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type propertiesCreateNestedOneWithoutBookingsInput = {
    create?: XOR<propertiesCreateWithoutBookingsInput, propertiesUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: propertiesCreateOrConnectWithoutBookingsInput
    connect?: propertiesWhereUniqueInput
  }

  export type booking_status_historyCreateNestedManyWithoutBookingInput = {
    create?: XOR<booking_status_historyCreateWithoutBookingInput, booking_status_historyUncheckedCreateWithoutBookingInput> | booking_status_historyCreateWithoutBookingInput[] | booking_status_historyUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: booking_status_historyCreateOrConnectWithoutBookingInput | booking_status_historyCreateOrConnectWithoutBookingInput[]
    createMany?: booking_status_historyCreateManyBookingInputEnvelope
    connect?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
  }

  export type vehiclesCreateNestedOneWithoutBookingsInput = {
    create?: XOR<vehiclesCreateWithoutBookingsInput, vehiclesUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: vehiclesCreateOrConnectWithoutBookingsInput
    connect?: vehiclesWhereUniqueInput
  }

  export type booking_slotsUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<booking_slotsCreateWithoutBookingInput, booking_slotsUncheckedCreateWithoutBookingInput> | booking_slotsCreateWithoutBookingInput[] | booking_slotsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: booking_slotsCreateOrConnectWithoutBookingInput | booking_slotsCreateOrConnectWithoutBookingInput[]
    createMany?: booking_slotsCreateManyBookingInputEnvelope
    connect?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
  }

  export type counter_transactionsUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<counter_transactionsCreateWithoutBookingInput, counter_transactionsUncheckedCreateWithoutBookingInput> | counter_transactionsCreateWithoutBookingInput[] | counter_transactionsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: counter_transactionsCreateOrConnectWithoutBookingInput | counter_transactionsCreateOrConnectWithoutBookingInput[]
    createMany?: counter_transactionsCreateManyBookingInputEnvelope
    connect?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
  }

  export type payment_summaryUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<payment_summaryCreateWithoutBookingInput, payment_summaryUncheckedCreateWithoutBookingInput>
    connectOrCreate?: payment_summaryCreateOrConnectWithoutBookingInput
    connect?: payment_summaryWhereUniqueInput
  }

  export type paymentsUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<paymentsCreateWithoutBookingInput, paymentsUncheckedCreateWithoutBookingInput> | paymentsCreateWithoutBookingInput[] | paymentsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutBookingInput | paymentsCreateOrConnectWithoutBookingInput[]
    createMany?: paymentsCreateManyBookingInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type booking_status_historyUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<booking_status_historyCreateWithoutBookingInput, booking_status_historyUncheckedCreateWithoutBookingInput> | booking_status_historyCreateWithoutBookingInput[] | booking_status_historyUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: booking_status_historyCreateOrConnectWithoutBookingInput | booking_status_historyCreateOrConnectWithoutBookingInput[]
    createMany?: booking_status_historyCreateManyBookingInputEnvelope
    connect?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type booking_slotsUpdateManyWithoutBookingNestedInput = {
    create?: XOR<booking_slotsCreateWithoutBookingInput, booking_slotsUncheckedCreateWithoutBookingInput> | booking_slotsCreateWithoutBookingInput[] | booking_slotsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: booking_slotsCreateOrConnectWithoutBookingInput | booking_slotsCreateOrConnectWithoutBookingInput[]
    upsert?: booking_slotsUpsertWithWhereUniqueWithoutBookingInput | booking_slotsUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: booking_slotsCreateManyBookingInputEnvelope
    set?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    disconnect?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    delete?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    connect?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    update?: booking_slotsUpdateWithWhereUniqueWithoutBookingInput | booking_slotsUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: booking_slotsUpdateManyWithWhereWithoutBookingInput | booking_slotsUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: booking_slotsScalarWhereInput | booking_slotsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutCustomerBookingsNestedInput = {
    create?: XOR<usersCreateWithoutCustomerBookingsInput, usersUncheckedCreateWithoutCustomerBookingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCustomerBookingsInput
    upsert?: usersUpsertWithoutCustomerBookingsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCustomerBookingsInput, usersUpdateWithoutCustomerBookingsInput>, usersUncheckedUpdateWithoutCustomerBookingsInput>
  }

  export type usersUpdateOneWithoutCreatedBookingsNestedInput = {
    create?: XOR<usersCreateWithoutCreatedBookingsInput, usersUncheckedCreateWithoutCreatedBookingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCreatedBookingsInput
    upsert?: usersUpsertWithoutCreatedBookingsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCreatedBookingsInput, usersUpdateWithoutCreatedBookingsInput>, usersUncheckedUpdateWithoutCreatedBookingsInput>
  }

  export type counter_transactionsUpdateManyWithoutBookingNestedInput = {
    create?: XOR<counter_transactionsCreateWithoutBookingInput, counter_transactionsUncheckedCreateWithoutBookingInput> | counter_transactionsCreateWithoutBookingInput[] | counter_transactionsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: counter_transactionsCreateOrConnectWithoutBookingInput | counter_transactionsCreateOrConnectWithoutBookingInput[]
    upsert?: counter_transactionsUpsertWithWhereUniqueWithoutBookingInput | counter_transactionsUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: counter_transactionsCreateManyBookingInputEnvelope
    set?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    disconnect?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    delete?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    connect?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    update?: counter_transactionsUpdateWithWhereUniqueWithoutBookingInput | counter_transactionsUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: counter_transactionsUpdateManyWithWhereWithoutBookingInput | counter_transactionsUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: counter_transactionsScalarWhereInput | counter_transactionsScalarWhereInput[]
  }

  export type payment_summaryUpdateOneWithoutBookingNestedInput = {
    create?: XOR<payment_summaryCreateWithoutBookingInput, payment_summaryUncheckedCreateWithoutBookingInput>
    connectOrCreate?: payment_summaryCreateOrConnectWithoutBookingInput
    upsert?: payment_summaryUpsertWithoutBookingInput
    disconnect?: payment_summaryWhereInput | boolean
    delete?: payment_summaryWhereInput | boolean
    connect?: payment_summaryWhereUniqueInput
    update?: XOR<XOR<payment_summaryUpdateToOneWithWhereWithoutBookingInput, payment_summaryUpdateWithoutBookingInput>, payment_summaryUncheckedUpdateWithoutBookingInput>
  }

  export type paymentsUpdateManyWithoutBookingNestedInput = {
    create?: XOR<paymentsCreateWithoutBookingInput, paymentsUncheckedCreateWithoutBookingInput> | paymentsCreateWithoutBookingInput[] | paymentsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutBookingInput | paymentsCreateOrConnectWithoutBookingInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutBookingInput | paymentsUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: paymentsCreateManyBookingInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutBookingInput | paymentsUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutBookingInput | paymentsUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type propertiesUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<propertiesCreateWithoutBookingsInput, propertiesUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: propertiesCreateOrConnectWithoutBookingsInput
    upsert?: propertiesUpsertWithoutBookingsInput
    connect?: propertiesWhereUniqueInput
    update?: XOR<XOR<propertiesUpdateToOneWithWhereWithoutBookingsInput, propertiesUpdateWithoutBookingsInput>, propertiesUncheckedUpdateWithoutBookingsInput>
  }

  export type booking_status_historyUpdateManyWithoutBookingNestedInput = {
    create?: XOR<booking_status_historyCreateWithoutBookingInput, booking_status_historyUncheckedCreateWithoutBookingInput> | booking_status_historyCreateWithoutBookingInput[] | booking_status_historyUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: booking_status_historyCreateOrConnectWithoutBookingInput | booking_status_historyCreateOrConnectWithoutBookingInput[]
    upsert?: booking_status_historyUpsertWithWhereUniqueWithoutBookingInput | booking_status_historyUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: booking_status_historyCreateManyBookingInputEnvelope
    set?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    disconnect?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    delete?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    connect?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    update?: booking_status_historyUpdateWithWhereUniqueWithoutBookingInput | booking_status_historyUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: booking_status_historyUpdateManyWithWhereWithoutBookingInput | booking_status_historyUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: booking_status_historyScalarWhereInput | booking_status_historyScalarWhereInput[]
  }

  export type vehiclesUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<vehiclesCreateWithoutBookingsInput, vehiclesUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: vehiclesCreateOrConnectWithoutBookingsInput
    upsert?: vehiclesUpsertWithoutBookingsInput
    disconnect?: vehiclesWhereInput | boolean
    delete?: vehiclesWhereInput | boolean
    connect?: vehiclesWhereUniqueInput
    update?: XOR<XOR<vehiclesUpdateToOneWithWhereWithoutBookingsInput, vehiclesUpdateWithoutBookingsInput>, vehiclesUncheckedUpdateWithoutBookingsInput>
  }

  export type booking_slotsUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<booking_slotsCreateWithoutBookingInput, booking_slotsUncheckedCreateWithoutBookingInput> | booking_slotsCreateWithoutBookingInput[] | booking_slotsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: booking_slotsCreateOrConnectWithoutBookingInput | booking_slotsCreateOrConnectWithoutBookingInput[]
    upsert?: booking_slotsUpsertWithWhereUniqueWithoutBookingInput | booking_slotsUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: booking_slotsCreateManyBookingInputEnvelope
    set?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    disconnect?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    delete?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    connect?: booking_slotsWhereUniqueInput | booking_slotsWhereUniqueInput[]
    update?: booking_slotsUpdateWithWhereUniqueWithoutBookingInput | booking_slotsUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: booking_slotsUpdateManyWithWhereWithoutBookingInput | booking_slotsUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: booking_slotsScalarWhereInput | booking_slotsScalarWhereInput[]
  }

  export type counter_transactionsUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<counter_transactionsCreateWithoutBookingInput, counter_transactionsUncheckedCreateWithoutBookingInput> | counter_transactionsCreateWithoutBookingInput[] | counter_transactionsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: counter_transactionsCreateOrConnectWithoutBookingInput | counter_transactionsCreateOrConnectWithoutBookingInput[]
    upsert?: counter_transactionsUpsertWithWhereUniqueWithoutBookingInput | counter_transactionsUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: counter_transactionsCreateManyBookingInputEnvelope
    set?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    disconnect?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    delete?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    connect?: counter_transactionsWhereUniqueInput | counter_transactionsWhereUniqueInput[]
    update?: counter_transactionsUpdateWithWhereUniqueWithoutBookingInput | counter_transactionsUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: counter_transactionsUpdateManyWithWhereWithoutBookingInput | counter_transactionsUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: counter_transactionsScalarWhereInput | counter_transactionsScalarWhereInput[]
  }

  export type payment_summaryUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<payment_summaryCreateWithoutBookingInput, payment_summaryUncheckedCreateWithoutBookingInput>
    connectOrCreate?: payment_summaryCreateOrConnectWithoutBookingInput
    upsert?: payment_summaryUpsertWithoutBookingInput
    disconnect?: payment_summaryWhereInput | boolean
    delete?: payment_summaryWhereInput | boolean
    connect?: payment_summaryWhereUniqueInput
    update?: XOR<XOR<payment_summaryUpdateToOneWithWhereWithoutBookingInput, payment_summaryUpdateWithoutBookingInput>, payment_summaryUncheckedUpdateWithoutBookingInput>
  }

  export type paymentsUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<paymentsCreateWithoutBookingInput, paymentsUncheckedCreateWithoutBookingInput> | paymentsCreateWithoutBookingInput[] | paymentsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutBookingInput | paymentsCreateOrConnectWithoutBookingInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutBookingInput | paymentsUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: paymentsCreateManyBookingInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutBookingInput | paymentsUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutBookingInput | paymentsUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type booking_status_historyUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<booking_status_historyCreateWithoutBookingInput, booking_status_historyUncheckedCreateWithoutBookingInput> | booking_status_historyCreateWithoutBookingInput[] | booking_status_historyUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: booking_status_historyCreateOrConnectWithoutBookingInput | booking_status_historyCreateOrConnectWithoutBookingInput[]
    upsert?: booking_status_historyUpsertWithWhereUniqueWithoutBookingInput | booking_status_historyUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: booking_status_historyCreateManyBookingInputEnvelope
    set?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    disconnect?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    delete?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    connect?: booking_status_historyWhereUniqueInput | booking_status_historyWhereUniqueInput[]
    update?: booking_status_historyUpdateWithWhereUniqueWithoutBookingInput | booking_status_historyUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: booking_status_historyUpdateManyWithWhereWithoutBookingInput | booking_status_historyUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: booking_status_historyScalarWhereInput | booking_status_historyScalarWhereInput[]
  }

  export type bookingsCreateNestedOneWithoutBookingSlotsInput = {
    create?: XOR<bookingsCreateWithoutBookingSlotsInput, bookingsUncheckedCreateWithoutBookingSlotsInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutBookingSlotsInput
    connect?: bookingsWhereUniqueInput
  }

  export type parking_slotsCreateNestedOneWithoutBookingSlotsInput = {
    create?: XOR<parking_slotsCreateWithoutBookingSlotsInput, parking_slotsUncheckedCreateWithoutBookingSlotsInput>
    connectOrCreate?: parking_slotsCreateOrConnectWithoutBookingSlotsInput
    connect?: parking_slotsWhereUniqueInput
  }

  export type wash_jobsCreateNestedOneWithoutBookingSlotInput = {
    create?: XOR<wash_jobsCreateWithoutBookingSlotInput, wash_jobsUncheckedCreateWithoutBookingSlotInput>
    connectOrCreate?: wash_jobsCreateOrConnectWithoutBookingSlotInput
    connect?: wash_jobsWhereUniqueInput
  }

  export type wash_jobsUncheckedCreateNestedOneWithoutBookingSlotInput = {
    create?: XOR<wash_jobsCreateWithoutBookingSlotInput, wash_jobsUncheckedCreateWithoutBookingSlotInput>
    connectOrCreate?: wash_jobsCreateOrConnectWithoutBookingSlotInput
    connect?: wash_jobsWhereUniqueInput
  }

  export type bookingsUpdateOneRequiredWithoutBookingSlotsNestedInput = {
    create?: XOR<bookingsCreateWithoutBookingSlotsInput, bookingsUncheckedCreateWithoutBookingSlotsInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutBookingSlotsInput
    upsert?: bookingsUpsertWithoutBookingSlotsInput
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutBookingSlotsInput, bookingsUpdateWithoutBookingSlotsInput>, bookingsUncheckedUpdateWithoutBookingSlotsInput>
  }

  export type parking_slotsUpdateOneRequiredWithoutBookingSlotsNestedInput = {
    create?: XOR<parking_slotsCreateWithoutBookingSlotsInput, parking_slotsUncheckedCreateWithoutBookingSlotsInput>
    connectOrCreate?: parking_slotsCreateOrConnectWithoutBookingSlotsInput
    upsert?: parking_slotsUpsertWithoutBookingSlotsInput
    connect?: parking_slotsWhereUniqueInput
    update?: XOR<XOR<parking_slotsUpdateToOneWithWhereWithoutBookingSlotsInput, parking_slotsUpdateWithoutBookingSlotsInput>, parking_slotsUncheckedUpdateWithoutBookingSlotsInput>
  }

  export type wash_jobsUpdateOneWithoutBookingSlotNestedInput = {
    create?: XOR<wash_jobsCreateWithoutBookingSlotInput, wash_jobsUncheckedCreateWithoutBookingSlotInput>
    connectOrCreate?: wash_jobsCreateOrConnectWithoutBookingSlotInput
    upsert?: wash_jobsUpsertWithoutBookingSlotInput
    disconnect?: wash_jobsWhereInput | boolean
    delete?: wash_jobsWhereInput | boolean
    connect?: wash_jobsWhereUniqueInput
    update?: XOR<XOR<wash_jobsUpdateToOneWithWhereWithoutBookingSlotInput, wash_jobsUpdateWithoutBookingSlotInput>, wash_jobsUncheckedUpdateWithoutBookingSlotInput>
  }

  export type wash_jobsUncheckedUpdateOneWithoutBookingSlotNestedInput = {
    create?: XOR<wash_jobsCreateWithoutBookingSlotInput, wash_jobsUncheckedCreateWithoutBookingSlotInput>
    connectOrCreate?: wash_jobsCreateOrConnectWithoutBookingSlotInput
    upsert?: wash_jobsUpsertWithoutBookingSlotInput
    disconnect?: wash_jobsWhereInput | boolean
    delete?: wash_jobsWhereInput | boolean
    connect?: wash_jobsWhereUniqueInput
    update?: XOR<XOR<wash_jobsUpdateToOneWithWhereWithoutBookingSlotInput, wash_jobsUpdateWithoutBookingSlotInput>, wash_jobsUncheckedUpdateWithoutBookingSlotInput>
  }

  export type bookingsCreateNestedOneWithoutStatusHistoryInput = {
    create?: XOR<bookingsCreateWithoutStatusHistoryInput, bookingsUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutStatusHistoryInput
    connect?: bookingsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutBookingStatusEventsInput = {
    create?: XOR<usersCreateWithoutBookingStatusEventsInput, usersUncheckedCreateWithoutBookingStatusEventsInput>
    connectOrCreate?: usersCreateOrConnectWithoutBookingStatusEventsInput
    connect?: usersWhereUniqueInput
  }

  export type bookingsUpdateOneRequiredWithoutStatusHistoryNestedInput = {
    create?: XOR<bookingsCreateWithoutStatusHistoryInput, bookingsUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutStatusHistoryInput
    upsert?: bookingsUpsertWithoutStatusHistoryInput
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutStatusHistoryInput, bookingsUpdateWithoutStatusHistoryInput>, bookingsUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type usersUpdateOneWithoutBookingStatusEventsNestedInput = {
    create?: XOR<usersCreateWithoutBookingStatusEventsInput, usersUncheckedCreateWithoutBookingStatusEventsInput>
    connectOrCreate?: usersCreateOrConnectWithoutBookingStatusEventsInput
    upsert?: usersUpsertWithoutBookingStatusEventsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBookingStatusEventsInput, usersUpdateWithoutBookingStatusEventsInput>, usersUncheckedUpdateWithoutBookingStatusEventsInput>
  }

  export type bookingsCreateNestedOneWithoutPaymentSummaryInput = {
    create?: XOR<bookingsCreateWithoutPaymentSummaryInput, bookingsUncheckedCreateWithoutPaymentSummaryInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutPaymentSummaryInput
    connect?: bookingsWhereUniqueInput
  }

  export type bookingsUpdateOneRequiredWithoutPaymentSummaryNestedInput = {
    create?: XOR<bookingsCreateWithoutPaymentSummaryInput, bookingsUncheckedCreateWithoutPaymentSummaryInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutPaymentSummaryInput
    upsert?: bookingsUpsertWithoutPaymentSummaryInput
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutPaymentSummaryInput, bookingsUpdateWithoutPaymentSummaryInput>, bookingsUncheckedUpdateWithoutPaymentSummaryInput>
  }

  export type bookingsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<bookingsCreateWithoutPaymentsInput, bookingsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutPaymentsInput
    connect?: bookingsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCreatedPaymentsInput = {
    create?: XOR<usersCreateWithoutCreatedPaymentsInput, usersUncheckedCreateWithoutCreatedPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCreatedPaymentsInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EnumGatewayStatusFieldUpdateOperationsInput = {
    set?: $Enums.GatewayStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type bookingsUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<bookingsCreateWithoutPaymentsInput, bookingsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutPaymentsInput
    upsert?: bookingsUpsertWithoutPaymentsInput
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutPaymentsInput, bookingsUpdateWithoutPaymentsInput>, bookingsUncheckedUpdateWithoutPaymentsInput>
  }

  export type usersUpdateOneWithoutCreatedPaymentsNestedInput = {
    create?: XOR<usersCreateWithoutCreatedPaymentsInput, usersUncheckedCreateWithoutCreatedPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCreatedPaymentsInput
    upsert?: usersUpsertWithoutCreatedPaymentsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCreatedPaymentsInput, usersUpdateWithoutCreatedPaymentsInput>, usersUncheckedUpdateWithoutCreatedPaymentsInput>
  }

  export type usersUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentsInput
    upsert?: usersUpsertWithoutPaymentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPaymentsInput, usersUpdateWithoutPaymentsInput>, usersUncheckedUpdateWithoutPaymentsInput>
  }

  export type booking_slotsCreateNestedOneWithoutWashJobInput = {
    create?: XOR<booking_slotsCreateWithoutWashJobInput, booking_slotsUncheckedCreateWithoutWashJobInput>
    connectOrCreate?: booking_slotsCreateOrConnectWithoutWashJobInput
    connect?: booking_slotsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutWashJobsInput = {
    create?: XOR<usersCreateWithoutWashJobsInput, usersUncheckedCreateWithoutWashJobsInput>
    connectOrCreate?: usersCreateOrConnectWithoutWashJobsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumWashStatusFieldUpdateOperationsInput = {
    set?: $Enums.WashStatus
  }

  export type booking_slotsUpdateOneRequiredWithoutWashJobNestedInput = {
    create?: XOR<booking_slotsCreateWithoutWashJobInput, booking_slotsUncheckedCreateWithoutWashJobInput>
    connectOrCreate?: booking_slotsCreateOrConnectWithoutWashJobInput
    upsert?: booking_slotsUpsertWithoutWashJobInput
    connect?: booking_slotsWhereUniqueInput
    update?: XOR<XOR<booking_slotsUpdateToOneWithWhereWithoutWashJobInput, booking_slotsUpdateWithoutWashJobInput>, booking_slotsUncheckedUpdateWithoutWashJobInput>
  }

  export type usersUpdateOneWithoutWashJobsNestedInput = {
    create?: XOR<usersCreateWithoutWashJobsInput, usersUncheckedCreateWithoutWashJobsInput>
    connectOrCreate?: usersCreateOrConnectWithoutWashJobsInput
    upsert?: usersUpsertWithoutWashJobsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWashJobsInput, usersUpdateWithoutWashJobsInput>, usersUncheckedUpdateWithoutWashJobsInput>
  }

  export type bookingsCreateNestedOneWithoutCounterLogsInput = {
    create?: XOR<bookingsCreateWithoutCounterLogsInput, bookingsUncheckedCreateWithoutCounterLogsInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutCounterLogsInput
    connect?: bookingsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCounterTransactionsInput = {
    create?: XOR<usersCreateWithoutCounterTransactionsInput, usersUncheckedCreateWithoutCounterTransactionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCounterTransactionsInput
    connect?: usersWhereUniqueInput
  }

  export type bookingsUpdateOneRequiredWithoutCounterLogsNestedInput = {
    create?: XOR<bookingsCreateWithoutCounterLogsInput, bookingsUncheckedCreateWithoutCounterLogsInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutCounterLogsInput
    upsert?: bookingsUpsertWithoutCounterLogsInput
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutCounterLogsInput, bookingsUpdateWithoutCounterLogsInput>, bookingsUncheckedUpdateWithoutCounterLogsInput>
  }

  export type usersUpdateOneRequiredWithoutCounterTransactionsNestedInput = {
    create?: XOR<usersCreateWithoutCounterTransactionsInput, usersUncheckedCreateWithoutCounterTransactionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCounterTransactionsInput
    upsert?: usersUpsertWithoutCounterTransactionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCounterTransactionsInput, usersUpdateWithoutCounterTransactionsInput>, usersUncheckedUpdateWithoutCounterTransactionsInput>
  }

  export type usersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    upsert?: usersUpsertWithoutNotificationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotificationsInput, usersUpdateWithoutNotificationsInput>, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleNameFilter<$PrismaModel>
    _max?: NestedEnumRoleNameFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type NestedEnumSlotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeFilter<$PrismaModel> | $Enums.SlotType
  }

  export type NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SlotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSlotTypeFilter<$PrismaModel>
    _max?: NestedEnumSlotTypeFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumGatewayStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GatewayStatus | EnumGatewayStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GatewayStatus[] | ListEnumGatewayStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatewayStatus[] | ListEnumGatewayStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGatewayStatusFilter<$PrismaModel> | $Enums.GatewayStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumGatewayStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GatewayStatus | EnumGatewayStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GatewayStatus[] | ListEnumGatewayStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatewayStatus[] | ListEnumGatewayStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGatewayStatusWithAggregatesFilter<$PrismaModel> | $Enums.GatewayStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGatewayStatusFilter<$PrismaModel>
    _max?: NestedEnumGatewayStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumWashStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WashStatus | EnumWashStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WashStatus[] | ListEnumWashStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WashStatus[] | ListEnumWashStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWashStatusFilter<$PrismaModel> | $Enums.WashStatus
  }

  export type NestedEnumWashStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WashStatus | EnumWashStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WashStatus[] | ListEnumWashStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WashStatus[] | ListEnumWashStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWashStatusWithAggregatesFilter<$PrismaModel> | $Enums.WashStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWashStatusFilter<$PrismaModel>
    _max?: NestedEnumWashStatusFilter<$PrismaModel>
  }

  export type bookingsCreateWithoutCustomerInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsCreateNestedManyWithoutBookingInput
    creator?: usersCreateNestedOneWithoutCreatedBookingsInput
    counterLogs?: counter_transactionsCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryCreateNestedOneWithoutBookingInput
    payments?: paymentsCreateNestedManyWithoutBookingInput
    property: propertiesCreateNestedOneWithoutBookingsInput
    statusHistory?: booking_status_historyCreateNestedManyWithoutBookingInput
    vehicle?: vehiclesCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutCustomerInput = {
    id?: string
    propertyId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsUncheckedCreateNestedManyWithoutBookingInput
    counterLogs?: counter_transactionsUncheckedCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryUncheckedCreateNestedOneWithoutBookingInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingInput
    statusHistory?: booking_status_historyUncheckedCreateNestedManyWithoutBookingInput
  }

  export type bookingsCreateOrConnectWithoutCustomerInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutCustomerInput, bookingsUncheckedCreateWithoutCustomerInput>
  }

  export type bookingsCreateManyCustomerInputEnvelope = {
    data: bookingsCreateManyCustomerInput | bookingsCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type bookingsCreateWithoutCreatorInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsCreateNestedManyWithoutBookingInput
    customer: usersCreateNestedOneWithoutCustomerBookingsInput
    counterLogs?: counter_transactionsCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryCreateNestedOneWithoutBookingInput
    payments?: paymentsCreateNestedManyWithoutBookingInput
    property: propertiesCreateNestedOneWithoutBookingsInput
    statusHistory?: booking_status_historyCreateNestedManyWithoutBookingInput
    vehicle?: vehiclesCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutCreatorInput = {
    id?: string
    customerId: string
    propertyId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsUncheckedCreateNestedManyWithoutBookingInput
    counterLogs?: counter_transactionsUncheckedCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryUncheckedCreateNestedOneWithoutBookingInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingInput
    statusHistory?: booking_status_historyUncheckedCreateNestedManyWithoutBookingInput
  }

  export type bookingsCreateOrConnectWithoutCreatorInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutCreatorInput, bookingsUncheckedCreateWithoutCreatorInput>
  }

  export type bookingsCreateManyCreatorInputEnvelope = {
    data: bookingsCreateManyCreatorInput | bookingsCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type booking_status_historyCreateWithoutChangerInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    note?: string | null
    changedAt?: Date | string
    booking: bookingsCreateNestedOneWithoutStatusHistoryInput
  }

  export type booking_status_historyUncheckedCreateWithoutChangerInput = {
    id?: string
    bookingId: string
    oldStatus?: string | null
    newStatus: string
    note?: string | null
    changedAt?: Date | string
  }

  export type booking_status_historyCreateOrConnectWithoutChangerInput = {
    where: booking_status_historyWhereUniqueInput
    create: XOR<booking_status_historyCreateWithoutChangerInput, booking_status_historyUncheckedCreateWithoutChangerInput>
  }

  export type booking_status_historyCreateManyChangerInputEnvelope = {
    data: booking_status_historyCreateManyChangerInput | booking_status_historyCreateManyChangerInput[]
    skipDuplicates?: boolean
  }

  export type counter_transactionsCreateWithoutCounterUserInput = {
    id?: string
    action: string
    note?: string | null
    createdAt?: Date | string
    booking: bookingsCreateNestedOneWithoutCounterLogsInput
  }

  export type counter_transactionsUncheckedCreateWithoutCounterUserInput = {
    id?: string
    bookingId: string
    action: string
    note?: string | null
    createdAt?: Date | string
  }

  export type counter_transactionsCreateOrConnectWithoutCounterUserInput = {
    where: counter_transactionsWhereUniqueInput
    create: XOR<counter_transactionsCreateWithoutCounterUserInput, counter_transactionsUncheckedCreateWithoutCounterUserInput>
  }

  export type counter_transactionsCreateManyCounterUserInputEnvelope = {
    data: counter_transactionsCreateManyCounterUserInput | counter_transactionsCreateManyCounterUserInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type notificationsUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type notificationsCreateOrConnectWithoutUserInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutUserInput, notificationsUncheckedCreateWithoutUserInput>
  }

  export type notificationsCreateManyUserInputEnvelope = {
    data: notificationsCreateManyUserInput | notificationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type propertiesCreateWithoutOwnerInput = {
    id?: string
    propertyName: string
    address: string
    pricePerHour?: Decimal | DecimalJsLike | number | string
    pricePerDay?: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PropertyStatus
    totalSlots?: number
    totalNormalSlots?: number
    totalEvSlots?: number
    totalCarWashSlots?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: bookingsCreateNestedManyWithoutPropertyInput
    parkingSlots?: parking_slotsCreateNestedManyWithoutPropertyInput
  }

  export type propertiesUncheckedCreateWithoutOwnerInput = {
    id?: string
    propertyName: string
    address: string
    pricePerHour?: Decimal | DecimalJsLike | number | string
    pricePerDay?: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PropertyStatus
    totalSlots?: number
    totalNormalSlots?: number
    totalEvSlots?: number
    totalCarWashSlots?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: bookingsUncheckedCreateNestedManyWithoutPropertyInput
    parkingSlots?: parking_slotsUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type propertiesCreateOrConnectWithoutOwnerInput = {
    where: propertiesWhereUniqueInput
    create: XOR<propertiesCreateWithoutOwnerInput, propertiesUncheckedCreateWithoutOwnerInput>
  }

  export type propertiesCreateManyOwnerInputEnvelope = {
    data: propertiesCreateManyOwnerInput | propertiesCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutCreatorInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayStatus?: $Enums.GatewayStatus
    gatewayProvider?: string | null
    transactionId?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    booking: bookingsCreateNestedOneWithoutPaymentsInput
    payer: usersCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutCreatorInput = {
    id?: string
    bookingId: string
    payerId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayStatus?: $Enums.GatewayStatus
    gatewayProvider?: string | null
    transactionId?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type paymentsCreateOrConnectWithoutCreatorInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutCreatorInput, paymentsUncheckedCreateWithoutCreatorInput>
  }

  export type paymentsCreateManyCreatorInputEnvelope = {
    data: paymentsCreateManyCreatorInput | paymentsCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutPayerInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayStatus?: $Enums.GatewayStatus
    gatewayProvider?: string | null
    transactionId?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    booking: bookingsCreateNestedOneWithoutPaymentsInput
    creator?: usersCreateNestedOneWithoutCreatedPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutPayerInput = {
    id?: string
    bookingId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayStatus?: $Enums.GatewayStatus
    gatewayProvider?: string | null
    transactionId?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    paidAt?: Date | string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type paymentsCreateOrConnectWithoutPayerInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutPayerInput, paymentsUncheckedCreateWithoutPayerInput>
  }

  export type paymentsCreateManyPayerInputEnvelope = {
    data: paymentsCreateManyPayerInput | paymentsCreateManyPayerInput[]
    skipDuplicates?: boolean
  }

  export type user_rolesCreateWithoutUserInput = {
    role: rolesCreateNestedOneWithoutUsersInput
  }

  export type user_rolesUncheckedCreateWithoutUserInput = {
    roleId: number
  }

  export type user_rolesCreateOrConnectWithoutUserInput = {
    where: user_rolesWhereUniqueInput
    create: XOR<user_rolesCreateWithoutUserInput, user_rolesUncheckedCreateWithoutUserInput>
  }

  export type user_rolesCreateManyUserInputEnvelope = {
    data: user_rolesCreateManyUserInput | user_rolesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type vehiclesCreateWithoutUserInput = {
    id?: string
    vehicleNumber: string
    type?: string | null
    model?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: bookingsCreateNestedManyWithoutVehicleInput
  }

  export type vehiclesUncheckedCreateWithoutUserInput = {
    id?: string
    vehicleNumber: string
    type?: string | null
    model?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: bookingsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehiclesCreateOrConnectWithoutUserInput = {
    where: vehiclesWhereUniqueInput
    create: XOR<vehiclesCreateWithoutUserInput, vehiclesUncheckedCreateWithoutUserInput>
  }

  export type vehiclesCreateManyUserInputEnvelope = {
    data: vehiclesCreateManyUserInput | vehiclesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type wash_jobsCreateWithoutWasherInput = {
    id?: string
    status?: $Enums.WashStatus
    acceptedAt?: Date | string | null
    completedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlot: booking_slotsCreateNestedOneWithoutWashJobInput
  }

  export type wash_jobsUncheckedCreateWithoutWasherInput = {
    id?: string
    bookingSlotId: string
    status?: $Enums.WashStatus
    acceptedAt?: Date | string | null
    completedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type wash_jobsCreateOrConnectWithoutWasherInput = {
    where: wash_jobsWhereUniqueInput
    create: XOR<wash_jobsCreateWithoutWasherInput, wash_jobsUncheckedCreateWithoutWasherInput>
  }

  export type wash_jobsCreateManyWasherInputEnvelope = {
    data: wash_jobsCreateManyWasherInput | wash_jobsCreateManyWasherInput[]
    skipDuplicates?: boolean
  }

  export type bookingsUpsertWithWhereUniqueWithoutCustomerInput = {
    where: bookingsWhereUniqueInput
    update: XOR<bookingsUpdateWithoutCustomerInput, bookingsUncheckedUpdateWithoutCustomerInput>
    create: XOR<bookingsCreateWithoutCustomerInput, bookingsUncheckedCreateWithoutCustomerInput>
  }

  export type bookingsUpdateWithWhereUniqueWithoutCustomerInput = {
    where: bookingsWhereUniqueInput
    data: XOR<bookingsUpdateWithoutCustomerInput, bookingsUncheckedUpdateWithoutCustomerInput>
  }

  export type bookingsUpdateManyWithWhereWithoutCustomerInput = {
    where: bookingsScalarWhereInput
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyWithoutCustomerInput>
  }

  export type bookingsScalarWhereInput = {
    AND?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
    OR?: bookingsScalarWhereInput[]
    NOT?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
    id?: UuidFilter<"bookings"> | string
    customerId?: UuidFilter<"bookings"> | string
    propertyId?: UuidFilter<"bookings"> | string
    vehicleId?: UuidNullableFilter<"bookings"> | string | null
    startTime?: DateTimeFilter<"bookings"> | Date | string
    endTime?: DateTimeFilter<"bookings"> | Date | string
    status?: EnumBookingStatusFilter<"bookings"> | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFilter<"bookings"> | $Enums.SlotType
    bookingType?: StringFilter<"bookings"> | string
    createdBy?: UuidNullableFilter<"bookings"> | string | null
    createdAt?: DateTimeFilter<"bookings"> | Date | string
    updatedAt?: DateTimeFilter<"bookings"> | Date | string
  }

  export type bookingsUpsertWithWhereUniqueWithoutCreatorInput = {
    where: bookingsWhereUniqueInput
    update: XOR<bookingsUpdateWithoutCreatorInput, bookingsUncheckedUpdateWithoutCreatorInput>
    create: XOR<bookingsCreateWithoutCreatorInput, bookingsUncheckedCreateWithoutCreatorInput>
  }

  export type bookingsUpdateWithWhereUniqueWithoutCreatorInput = {
    where: bookingsWhereUniqueInput
    data: XOR<bookingsUpdateWithoutCreatorInput, bookingsUncheckedUpdateWithoutCreatorInput>
  }

  export type bookingsUpdateManyWithWhereWithoutCreatorInput = {
    where: bookingsScalarWhereInput
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyWithoutCreatorInput>
  }

  export type booking_status_historyUpsertWithWhereUniqueWithoutChangerInput = {
    where: booking_status_historyWhereUniqueInput
    update: XOR<booking_status_historyUpdateWithoutChangerInput, booking_status_historyUncheckedUpdateWithoutChangerInput>
    create: XOR<booking_status_historyCreateWithoutChangerInput, booking_status_historyUncheckedCreateWithoutChangerInput>
  }

  export type booking_status_historyUpdateWithWhereUniqueWithoutChangerInput = {
    where: booking_status_historyWhereUniqueInput
    data: XOR<booking_status_historyUpdateWithoutChangerInput, booking_status_historyUncheckedUpdateWithoutChangerInput>
  }

  export type booking_status_historyUpdateManyWithWhereWithoutChangerInput = {
    where: booking_status_historyScalarWhereInput
    data: XOR<booking_status_historyUpdateManyMutationInput, booking_status_historyUncheckedUpdateManyWithoutChangerInput>
  }

  export type booking_status_historyScalarWhereInput = {
    AND?: booking_status_historyScalarWhereInput | booking_status_historyScalarWhereInput[]
    OR?: booking_status_historyScalarWhereInput[]
    NOT?: booking_status_historyScalarWhereInput | booking_status_historyScalarWhereInput[]
    id?: UuidFilter<"booking_status_history"> | string
    bookingId?: UuidFilter<"booking_status_history"> | string
    oldStatus?: StringNullableFilter<"booking_status_history"> | string | null
    newStatus?: StringFilter<"booking_status_history"> | string
    changedBy?: UuidNullableFilter<"booking_status_history"> | string | null
    note?: StringNullableFilter<"booking_status_history"> | string | null
    changedAt?: DateTimeFilter<"booking_status_history"> | Date | string
  }

  export type counter_transactionsUpsertWithWhereUniqueWithoutCounterUserInput = {
    where: counter_transactionsWhereUniqueInput
    update: XOR<counter_transactionsUpdateWithoutCounterUserInput, counter_transactionsUncheckedUpdateWithoutCounterUserInput>
    create: XOR<counter_transactionsCreateWithoutCounterUserInput, counter_transactionsUncheckedCreateWithoutCounterUserInput>
  }

  export type counter_transactionsUpdateWithWhereUniqueWithoutCounterUserInput = {
    where: counter_transactionsWhereUniqueInput
    data: XOR<counter_transactionsUpdateWithoutCounterUserInput, counter_transactionsUncheckedUpdateWithoutCounterUserInput>
  }

  export type counter_transactionsUpdateManyWithWhereWithoutCounterUserInput = {
    where: counter_transactionsScalarWhereInput
    data: XOR<counter_transactionsUpdateManyMutationInput, counter_transactionsUncheckedUpdateManyWithoutCounterUserInput>
  }

  export type counter_transactionsScalarWhereInput = {
    AND?: counter_transactionsScalarWhereInput | counter_transactionsScalarWhereInput[]
    OR?: counter_transactionsScalarWhereInput[]
    NOT?: counter_transactionsScalarWhereInput | counter_transactionsScalarWhereInput[]
    id?: UuidFilter<"counter_transactions"> | string
    counterUserId?: UuidFilter<"counter_transactions"> | string
    bookingId?: UuidFilter<"counter_transactions"> | string
    action?: StringFilter<"counter_transactions"> | string
    note?: StringNullableFilter<"counter_transactions"> | string | null
    createdAt?: DateTimeFilter<"counter_transactions"> | Date | string
  }

  export type notificationsUpsertWithWhereUniqueWithoutUserInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutUserInput, notificationsUncheckedUpdateWithoutUserInput>
    create: XOR<notificationsCreateWithoutUserInput, notificationsUncheckedCreateWithoutUserInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutUserInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutUserInput, notificationsUncheckedUpdateWithoutUserInput>
  }

  export type notificationsUpdateManyWithWhereWithoutUserInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutUserInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: UuidFilter<"notifications"> | string
    userId?: UuidFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    isRead?: BoolFilter<"notifications"> | boolean
    createdAt?: DateTimeFilter<"notifications"> | Date | string
  }

  export type propertiesUpsertWithWhereUniqueWithoutOwnerInput = {
    where: propertiesWhereUniqueInput
    update: XOR<propertiesUpdateWithoutOwnerInput, propertiesUncheckedUpdateWithoutOwnerInput>
    create: XOR<propertiesCreateWithoutOwnerInput, propertiesUncheckedCreateWithoutOwnerInput>
  }

  export type propertiesUpdateWithWhereUniqueWithoutOwnerInput = {
    where: propertiesWhereUniqueInput
    data: XOR<propertiesUpdateWithoutOwnerInput, propertiesUncheckedUpdateWithoutOwnerInput>
  }

  export type propertiesUpdateManyWithWhereWithoutOwnerInput = {
    where: propertiesScalarWhereInput
    data: XOR<propertiesUpdateManyMutationInput, propertiesUncheckedUpdateManyWithoutOwnerInput>
  }

  export type propertiesScalarWhereInput = {
    AND?: propertiesScalarWhereInput | propertiesScalarWhereInput[]
    OR?: propertiesScalarWhereInput[]
    NOT?: propertiesScalarWhereInput | propertiesScalarWhereInput[]
    id?: UuidFilter<"properties"> | string
    ownerId?: UuidFilter<"properties"> | string
    propertyName?: StringFilter<"properties"> | string
    address?: StringFilter<"properties"> | string
    pricePerHour?: DecimalFilter<"properties"> | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFilter<"properties"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"properties"> | string
    status?: EnumPropertyStatusFilter<"properties"> | $Enums.PropertyStatus
    totalSlots?: IntFilter<"properties"> | number
    totalNormalSlots?: IntFilter<"properties"> | number
    totalEvSlots?: IntFilter<"properties"> | number
    totalCarWashSlots?: IntFilter<"properties"> | number
    createdAt?: DateTimeFilter<"properties"> | Date | string
    updatedAt?: DateTimeFilter<"properties"> | Date | string
  }

  export type paymentsUpsertWithWhereUniqueWithoutCreatorInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutCreatorInput, paymentsUncheckedUpdateWithoutCreatorInput>
    create: XOR<paymentsCreateWithoutCreatorInput, paymentsUncheckedCreateWithoutCreatorInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutCreatorInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutCreatorInput, paymentsUncheckedUpdateWithoutCreatorInput>
  }

  export type paymentsUpdateManyWithWhereWithoutCreatorInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutCreatorInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: UuidFilter<"payments"> | string
    bookingId?: UuidFilter<"payments"> | string
    payerId?: UuidFilter<"payments"> | string
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"payments"> | string
    method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFilter<"payments"> | $Enums.GatewayStatus
    gatewayProvider?: StringNullableFilter<"payments"> | string | null
    transactionId?: StringNullableFilter<"payments"> | string | null
    cardLast4?: StringNullableFilter<"payments"> | string | null
    cardBrand?: StringNullableFilter<"payments"> | string | null
    cardExpMonth?: IntNullableFilter<"payments"> | number | null
    cardExpYear?: IntNullableFilter<"payments"> | number | null
    paidAt?: DateTimeNullableFilter<"payments"> | Date | string | null
    createdBy?: UuidNullableFilter<"payments"> | string | null
    createdAt?: DateTimeFilter<"payments"> | Date | string
  }

  export type paymentsUpsertWithWhereUniqueWithoutPayerInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutPayerInput, paymentsUncheckedUpdateWithoutPayerInput>
    create: XOR<paymentsCreateWithoutPayerInput, paymentsUncheckedCreateWithoutPayerInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutPayerInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutPayerInput, paymentsUncheckedUpdateWithoutPayerInput>
  }

  export type paymentsUpdateManyWithWhereWithoutPayerInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutPayerInput>
  }

  export type user_rolesUpsertWithWhereUniqueWithoutUserInput = {
    where: user_rolesWhereUniqueInput
    update: XOR<user_rolesUpdateWithoutUserInput, user_rolesUncheckedUpdateWithoutUserInput>
    create: XOR<user_rolesCreateWithoutUserInput, user_rolesUncheckedCreateWithoutUserInput>
  }

  export type user_rolesUpdateWithWhereUniqueWithoutUserInput = {
    where: user_rolesWhereUniqueInput
    data: XOR<user_rolesUpdateWithoutUserInput, user_rolesUncheckedUpdateWithoutUserInput>
  }

  export type user_rolesUpdateManyWithWhereWithoutUserInput = {
    where: user_rolesScalarWhereInput
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyWithoutUserInput>
  }

  export type user_rolesScalarWhereInput = {
    AND?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
    OR?: user_rolesScalarWhereInput[]
    NOT?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
    userId?: UuidFilter<"user_roles"> | string
    roleId?: IntFilter<"user_roles"> | number
  }

  export type vehiclesUpsertWithWhereUniqueWithoutUserInput = {
    where: vehiclesWhereUniqueInput
    update: XOR<vehiclesUpdateWithoutUserInput, vehiclesUncheckedUpdateWithoutUserInput>
    create: XOR<vehiclesCreateWithoutUserInput, vehiclesUncheckedCreateWithoutUserInput>
  }

  export type vehiclesUpdateWithWhereUniqueWithoutUserInput = {
    where: vehiclesWhereUniqueInput
    data: XOR<vehiclesUpdateWithoutUserInput, vehiclesUncheckedUpdateWithoutUserInput>
  }

  export type vehiclesUpdateManyWithWhereWithoutUserInput = {
    where: vehiclesScalarWhereInput
    data: XOR<vehiclesUpdateManyMutationInput, vehiclesUncheckedUpdateManyWithoutUserInput>
  }

  export type vehiclesScalarWhereInput = {
    AND?: vehiclesScalarWhereInput | vehiclesScalarWhereInput[]
    OR?: vehiclesScalarWhereInput[]
    NOT?: vehiclesScalarWhereInput | vehiclesScalarWhereInput[]
    id?: UuidFilter<"vehicles"> | string
    userId?: UuidFilter<"vehicles"> | string
    vehicleNumber?: StringFilter<"vehicles"> | string
    type?: StringNullableFilter<"vehicles"> | string | null
    model?: StringNullableFilter<"vehicles"> | string | null
    color?: StringNullableFilter<"vehicles"> | string | null
    createdAt?: DateTimeFilter<"vehicles"> | Date | string
    updatedAt?: DateTimeFilter<"vehicles"> | Date | string
  }

  export type wash_jobsUpsertWithWhereUniqueWithoutWasherInput = {
    where: wash_jobsWhereUniqueInput
    update: XOR<wash_jobsUpdateWithoutWasherInput, wash_jobsUncheckedUpdateWithoutWasherInput>
    create: XOR<wash_jobsCreateWithoutWasherInput, wash_jobsUncheckedCreateWithoutWasherInput>
  }

  export type wash_jobsUpdateWithWhereUniqueWithoutWasherInput = {
    where: wash_jobsWhereUniqueInput
    data: XOR<wash_jobsUpdateWithoutWasherInput, wash_jobsUncheckedUpdateWithoutWasherInput>
  }

  export type wash_jobsUpdateManyWithWhereWithoutWasherInput = {
    where: wash_jobsScalarWhereInput
    data: XOR<wash_jobsUpdateManyMutationInput, wash_jobsUncheckedUpdateManyWithoutWasherInput>
  }

  export type wash_jobsScalarWhereInput = {
    AND?: wash_jobsScalarWhereInput | wash_jobsScalarWhereInput[]
    OR?: wash_jobsScalarWhereInput[]
    NOT?: wash_jobsScalarWhereInput | wash_jobsScalarWhereInput[]
    id?: UuidFilter<"wash_jobs"> | string
    bookingSlotId?: UuidFilter<"wash_jobs"> | string
    washerId?: UuidNullableFilter<"wash_jobs"> | string | null
    status?: EnumWashStatusFilter<"wash_jobs"> | $Enums.WashStatus
    acceptedAt?: DateTimeNullableFilter<"wash_jobs"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"wash_jobs"> | Date | string | null
    note?: StringNullableFilter<"wash_jobs"> | string | null
    createdAt?: DateTimeFilter<"wash_jobs"> | Date | string
    updatedAt?: DateTimeFilter<"wash_jobs"> | Date | string
  }

  export type user_rolesCreateWithoutRoleInput = {
    user: usersCreateNestedOneWithoutRolesInput
  }

  export type user_rolesUncheckedCreateWithoutRoleInput = {
    userId: string
  }

  export type user_rolesCreateOrConnectWithoutRoleInput = {
    where: user_rolesWhereUniqueInput
    create: XOR<user_rolesCreateWithoutRoleInput, user_rolesUncheckedCreateWithoutRoleInput>
  }

  export type user_rolesCreateManyRoleInputEnvelope = {
    data: user_rolesCreateManyRoleInput | user_rolesCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type user_rolesUpsertWithWhereUniqueWithoutRoleInput = {
    where: user_rolesWhereUniqueInput
    update: XOR<user_rolesUpdateWithoutRoleInput, user_rolesUncheckedUpdateWithoutRoleInput>
    create: XOR<user_rolesCreateWithoutRoleInput, user_rolesUncheckedCreateWithoutRoleInput>
  }

  export type user_rolesUpdateWithWhereUniqueWithoutRoleInput = {
    where: user_rolesWhereUniqueInput
    data: XOR<user_rolesUpdateWithoutRoleInput, user_rolesUncheckedUpdateWithoutRoleInput>
  }

  export type user_rolesUpdateManyWithWhereWithoutRoleInput = {
    where: user_rolesScalarWhereInput
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyWithoutRoleInput>
  }

  export type rolesCreateWithoutUsersInput = {
    name: $Enums.RoleName
  }

  export type rolesUncheckedCreateWithoutUsersInput = {
    id?: number
    name: $Enums.RoleName
  }

  export type rolesCreateOrConnectWithoutUsersInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutUsersInput, rolesUncheckedCreateWithoutUsersInput>
  }

  export type usersCreateWithoutRolesInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsCreateNestedManyWithoutCreatorInput
    payments?: paymentsCreateNestedManyWithoutPayerInput
    vehicles?: vehiclesCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsCreateNestedManyWithoutWasherInput
  }

  export type usersUncheckedCreateWithoutRolesInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsUncheckedCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsUncheckedCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyUncheckedCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsUncheckedCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesUncheckedCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsUncheckedCreateNestedManyWithoutCreatorInput
    payments?: paymentsUncheckedCreateNestedManyWithoutPayerInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsUncheckedCreateNestedManyWithoutWasherInput
  }

  export type usersCreateOrConnectWithoutRolesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput>
  }

  export type rolesUpsertWithoutUsersInput = {
    update: XOR<rolesUpdateWithoutUsersInput, rolesUncheckedUpdateWithoutUsersInput>
    create: XOR<rolesCreateWithoutUsersInput, rolesUncheckedCreateWithoutUsersInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutUsersInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutUsersInput, rolesUncheckedUpdateWithoutUsersInput>
  }

  export type rolesUpdateWithoutUsersInput = {
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
  }

  export type rolesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
  }

  export type usersUpsertWithoutRolesInput = {
    update: XOR<usersUpdateWithoutRolesInput, usersUncheckedUpdateWithoutRolesInput>
    create: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRolesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRolesInput, usersUncheckedUpdateWithoutRolesInput>
  }

  export type usersUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUpdateManyWithoutPayerNestedInput
    vehicles?: vehiclesUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUpdateManyWithoutWasherNestedInput
  }

  export type usersUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUncheckedUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUncheckedUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUncheckedUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUncheckedUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUncheckedUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutPayerNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUncheckedUpdateManyWithoutWasherNestedInput
  }

  export type bookingsCreateWithoutPropertyInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsCreateNestedManyWithoutBookingInput
    customer: usersCreateNestedOneWithoutCustomerBookingsInput
    creator?: usersCreateNestedOneWithoutCreatedBookingsInput
    counterLogs?: counter_transactionsCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryCreateNestedOneWithoutBookingInput
    payments?: paymentsCreateNestedManyWithoutBookingInput
    statusHistory?: booking_status_historyCreateNestedManyWithoutBookingInput
    vehicle?: vehiclesCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutPropertyInput = {
    id?: string
    customerId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsUncheckedCreateNestedManyWithoutBookingInput
    counterLogs?: counter_transactionsUncheckedCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryUncheckedCreateNestedOneWithoutBookingInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingInput
    statusHistory?: booking_status_historyUncheckedCreateNestedManyWithoutBookingInput
  }

  export type bookingsCreateOrConnectWithoutPropertyInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutPropertyInput, bookingsUncheckedCreateWithoutPropertyInput>
  }

  export type bookingsCreateManyPropertyInputEnvelope = {
    data: bookingsCreateManyPropertyInput | bookingsCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutOwnedPropertiesInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsCreateNestedManyWithoutUserInput
    createdPayments?: paymentsCreateNestedManyWithoutCreatorInput
    payments?: paymentsCreateNestedManyWithoutPayerInput
    roles?: user_rolesCreateNestedManyWithoutUserInput
    vehicles?: vehiclesCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsCreateNestedManyWithoutWasherInput
  }

  export type usersUncheckedCreateWithoutOwnedPropertiesInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsUncheckedCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsUncheckedCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyUncheckedCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsUncheckedCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUserInput
    createdPayments?: paymentsUncheckedCreateNestedManyWithoutCreatorInput
    payments?: paymentsUncheckedCreateNestedManyWithoutPayerInput
    roles?: user_rolesUncheckedCreateNestedManyWithoutUserInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsUncheckedCreateNestedManyWithoutWasherInput
  }

  export type usersCreateOrConnectWithoutOwnedPropertiesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOwnedPropertiesInput, usersUncheckedCreateWithoutOwnedPropertiesInput>
  }

  export type parking_slotsCreateWithoutPropertyInput = {
    id?: string
    slotNumber: string
    slotType: $Enums.SlotType
    isActive?: boolean
    createdAt?: Date | string
    bookingSlots?: booking_slotsCreateNestedManyWithoutSlotInput
  }

  export type parking_slotsUncheckedCreateWithoutPropertyInput = {
    id?: string
    slotNumber: string
    slotType: $Enums.SlotType
    isActive?: boolean
    createdAt?: Date | string
    bookingSlots?: booking_slotsUncheckedCreateNestedManyWithoutSlotInput
  }

  export type parking_slotsCreateOrConnectWithoutPropertyInput = {
    where: parking_slotsWhereUniqueInput
    create: XOR<parking_slotsCreateWithoutPropertyInput, parking_slotsUncheckedCreateWithoutPropertyInput>
  }

  export type parking_slotsCreateManyPropertyInputEnvelope = {
    data: parking_slotsCreateManyPropertyInput | parking_slotsCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type bookingsUpsertWithWhereUniqueWithoutPropertyInput = {
    where: bookingsWhereUniqueInput
    update: XOR<bookingsUpdateWithoutPropertyInput, bookingsUncheckedUpdateWithoutPropertyInput>
    create: XOR<bookingsCreateWithoutPropertyInput, bookingsUncheckedCreateWithoutPropertyInput>
  }

  export type bookingsUpdateWithWhereUniqueWithoutPropertyInput = {
    where: bookingsWhereUniqueInput
    data: XOR<bookingsUpdateWithoutPropertyInput, bookingsUncheckedUpdateWithoutPropertyInput>
  }

  export type bookingsUpdateManyWithWhereWithoutPropertyInput = {
    where: bookingsScalarWhereInput
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyWithoutPropertyInput>
  }

  export type usersUpsertWithoutOwnedPropertiesInput = {
    update: XOR<usersUpdateWithoutOwnedPropertiesInput, usersUncheckedUpdateWithoutOwnedPropertiesInput>
    create: XOR<usersCreateWithoutOwnedPropertiesInput, usersUncheckedCreateWithoutOwnedPropertiesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutOwnedPropertiesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutOwnedPropertiesInput, usersUncheckedUpdateWithoutOwnedPropertiesInput>
  }

  export type usersUpdateWithoutOwnedPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUpdateManyWithoutUserNestedInput
    createdPayments?: paymentsUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUpdateManyWithoutWasherNestedInput
  }

  export type usersUncheckedUpdateWithoutOwnedPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUncheckedUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUncheckedUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUncheckedUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUserNestedInput
    createdPayments?: paymentsUncheckedUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUncheckedUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUncheckedUpdateManyWithoutWasherNestedInput
  }

  export type parking_slotsUpsertWithWhereUniqueWithoutPropertyInput = {
    where: parking_slotsWhereUniqueInput
    update: XOR<parking_slotsUpdateWithoutPropertyInput, parking_slotsUncheckedUpdateWithoutPropertyInput>
    create: XOR<parking_slotsCreateWithoutPropertyInput, parking_slotsUncheckedCreateWithoutPropertyInput>
  }

  export type parking_slotsUpdateWithWhereUniqueWithoutPropertyInput = {
    where: parking_slotsWhereUniqueInput
    data: XOR<parking_slotsUpdateWithoutPropertyInput, parking_slotsUncheckedUpdateWithoutPropertyInput>
  }

  export type parking_slotsUpdateManyWithWhereWithoutPropertyInput = {
    where: parking_slotsScalarWhereInput
    data: XOR<parking_slotsUpdateManyMutationInput, parking_slotsUncheckedUpdateManyWithoutPropertyInput>
  }

  export type parking_slotsScalarWhereInput = {
    AND?: parking_slotsScalarWhereInput | parking_slotsScalarWhereInput[]
    OR?: parking_slotsScalarWhereInput[]
    NOT?: parking_slotsScalarWhereInput | parking_slotsScalarWhereInput[]
    id?: UuidFilter<"parking_slots"> | string
    propertyId?: UuidFilter<"parking_slots"> | string
    slotNumber?: StringFilter<"parking_slots"> | string
    slotType?: EnumSlotTypeFilter<"parking_slots"> | $Enums.SlotType
    isActive?: BoolFilter<"parking_slots"> | boolean
    createdAt?: DateTimeFilter<"parking_slots"> | Date | string
  }

  export type booking_slotsCreateWithoutSlotInput = {
    id?: string
    createdAt?: Date | string
    booking: bookingsCreateNestedOneWithoutBookingSlotsInput
    washJob?: wash_jobsCreateNestedOneWithoutBookingSlotInput
  }

  export type booking_slotsUncheckedCreateWithoutSlotInput = {
    id?: string
    bookingId: string
    createdAt?: Date | string
    washJob?: wash_jobsUncheckedCreateNestedOneWithoutBookingSlotInput
  }

  export type booking_slotsCreateOrConnectWithoutSlotInput = {
    where: booking_slotsWhereUniqueInput
    create: XOR<booking_slotsCreateWithoutSlotInput, booking_slotsUncheckedCreateWithoutSlotInput>
  }

  export type booking_slotsCreateManySlotInputEnvelope = {
    data: booking_slotsCreateManySlotInput | booking_slotsCreateManySlotInput[]
    skipDuplicates?: boolean
  }

  export type propertiesCreateWithoutParkingSlotsInput = {
    id?: string
    propertyName: string
    address: string
    pricePerHour?: Decimal | DecimalJsLike | number | string
    pricePerDay?: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PropertyStatus
    totalSlots?: number
    totalNormalSlots?: number
    totalEvSlots?: number
    totalCarWashSlots?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: bookingsCreateNestedManyWithoutPropertyInput
    owner: usersCreateNestedOneWithoutOwnedPropertiesInput
  }

  export type propertiesUncheckedCreateWithoutParkingSlotsInput = {
    id?: string
    ownerId: string
    propertyName: string
    address: string
    pricePerHour?: Decimal | DecimalJsLike | number | string
    pricePerDay?: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PropertyStatus
    totalSlots?: number
    totalNormalSlots?: number
    totalEvSlots?: number
    totalCarWashSlots?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: bookingsUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type propertiesCreateOrConnectWithoutParkingSlotsInput = {
    where: propertiesWhereUniqueInput
    create: XOR<propertiesCreateWithoutParkingSlotsInput, propertiesUncheckedCreateWithoutParkingSlotsInput>
  }

  export type booking_slotsUpsertWithWhereUniqueWithoutSlotInput = {
    where: booking_slotsWhereUniqueInput
    update: XOR<booking_slotsUpdateWithoutSlotInput, booking_slotsUncheckedUpdateWithoutSlotInput>
    create: XOR<booking_slotsCreateWithoutSlotInput, booking_slotsUncheckedCreateWithoutSlotInput>
  }

  export type booking_slotsUpdateWithWhereUniqueWithoutSlotInput = {
    where: booking_slotsWhereUniqueInput
    data: XOR<booking_slotsUpdateWithoutSlotInput, booking_slotsUncheckedUpdateWithoutSlotInput>
  }

  export type booking_slotsUpdateManyWithWhereWithoutSlotInput = {
    where: booking_slotsScalarWhereInput
    data: XOR<booking_slotsUpdateManyMutationInput, booking_slotsUncheckedUpdateManyWithoutSlotInput>
  }

  export type booking_slotsScalarWhereInput = {
    AND?: booking_slotsScalarWhereInput | booking_slotsScalarWhereInput[]
    OR?: booking_slotsScalarWhereInput[]
    NOT?: booking_slotsScalarWhereInput | booking_slotsScalarWhereInput[]
    id?: UuidFilter<"booking_slots"> | string
    bookingId?: UuidFilter<"booking_slots"> | string
    slotId?: UuidFilter<"booking_slots"> | string
    createdAt?: DateTimeFilter<"booking_slots"> | Date | string
  }

  export type propertiesUpsertWithoutParkingSlotsInput = {
    update: XOR<propertiesUpdateWithoutParkingSlotsInput, propertiesUncheckedUpdateWithoutParkingSlotsInput>
    create: XOR<propertiesCreateWithoutParkingSlotsInput, propertiesUncheckedCreateWithoutParkingSlotsInput>
    where?: propertiesWhereInput
  }

  export type propertiesUpdateToOneWithWhereWithoutParkingSlotsInput = {
    where?: propertiesWhereInput
    data: XOR<propertiesUpdateWithoutParkingSlotsInput, propertiesUncheckedUpdateWithoutParkingSlotsInput>
  }

  export type propertiesUpdateWithoutParkingSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    totalSlots?: IntFieldUpdateOperationsInput | number
    totalNormalSlots?: IntFieldUpdateOperationsInput | number
    totalEvSlots?: IntFieldUpdateOperationsInput | number
    totalCarWashSlots?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUpdateManyWithoutPropertyNestedInput
    owner?: usersUpdateOneRequiredWithoutOwnedPropertiesNestedInput
  }

  export type propertiesUncheckedUpdateWithoutParkingSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    totalSlots?: IntFieldUpdateOperationsInput | number
    totalNormalSlots?: IntFieldUpdateOperationsInput | number
    totalEvSlots?: IntFieldUpdateOperationsInput | number
    totalCarWashSlots?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type bookingsCreateWithoutVehicleInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsCreateNestedManyWithoutBookingInput
    customer: usersCreateNestedOneWithoutCustomerBookingsInput
    creator?: usersCreateNestedOneWithoutCreatedBookingsInput
    counterLogs?: counter_transactionsCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryCreateNestedOneWithoutBookingInput
    payments?: paymentsCreateNestedManyWithoutBookingInput
    property: propertiesCreateNestedOneWithoutBookingsInput
    statusHistory?: booking_status_historyCreateNestedManyWithoutBookingInput
  }

  export type bookingsUncheckedCreateWithoutVehicleInput = {
    id?: string
    customerId: string
    propertyId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsUncheckedCreateNestedManyWithoutBookingInput
    counterLogs?: counter_transactionsUncheckedCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryUncheckedCreateNestedOneWithoutBookingInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingInput
    statusHistory?: booking_status_historyUncheckedCreateNestedManyWithoutBookingInput
  }

  export type bookingsCreateOrConnectWithoutVehicleInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutVehicleInput, bookingsUncheckedCreateWithoutVehicleInput>
  }

  export type bookingsCreateManyVehicleInputEnvelope = {
    data: bookingsCreateManyVehicleInput | bookingsCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutVehiclesInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsCreateNestedManyWithoutCreatorInput
    payments?: paymentsCreateNestedManyWithoutPayerInput
    roles?: user_rolesCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsCreateNestedManyWithoutWasherInput
  }

  export type usersUncheckedCreateWithoutVehiclesInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsUncheckedCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsUncheckedCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyUncheckedCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsUncheckedCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesUncheckedCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsUncheckedCreateNestedManyWithoutCreatorInput
    payments?: paymentsUncheckedCreateNestedManyWithoutPayerInput
    roles?: user_rolesUncheckedCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsUncheckedCreateNestedManyWithoutWasherInput
  }

  export type usersCreateOrConnectWithoutVehiclesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVehiclesInput, usersUncheckedCreateWithoutVehiclesInput>
  }

  export type bookingsUpsertWithWhereUniqueWithoutVehicleInput = {
    where: bookingsWhereUniqueInput
    update: XOR<bookingsUpdateWithoutVehicleInput, bookingsUncheckedUpdateWithoutVehicleInput>
    create: XOR<bookingsCreateWithoutVehicleInput, bookingsUncheckedCreateWithoutVehicleInput>
  }

  export type bookingsUpdateWithWhereUniqueWithoutVehicleInput = {
    where: bookingsWhereUniqueInput
    data: XOR<bookingsUpdateWithoutVehicleInput, bookingsUncheckedUpdateWithoutVehicleInput>
  }

  export type bookingsUpdateManyWithWhereWithoutVehicleInput = {
    where: bookingsScalarWhereInput
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyWithoutVehicleInput>
  }

  export type usersUpsertWithoutVehiclesInput = {
    update: XOR<usersUpdateWithoutVehiclesInput, usersUncheckedUpdateWithoutVehiclesInput>
    create: XOR<usersCreateWithoutVehiclesInput, usersUncheckedCreateWithoutVehiclesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutVehiclesInput, usersUncheckedUpdateWithoutVehiclesInput>
  }

  export type usersUpdateWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUpdateManyWithoutWasherNestedInput
  }

  export type usersUncheckedUpdateWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUncheckedUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUncheckedUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUncheckedUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUncheckedUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUncheckedUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUncheckedUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUncheckedUpdateManyWithoutWasherNestedInput
  }

  export type booking_slotsCreateWithoutBookingInput = {
    id?: string
    createdAt?: Date | string
    slot: parking_slotsCreateNestedOneWithoutBookingSlotsInput
    washJob?: wash_jobsCreateNestedOneWithoutBookingSlotInput
  }

  export type booking_slotsUncheckedCreateWithoutBookingInput = {
    id?: string
    slotId: string
    createdAt?: Date | string
    washJob?: wash_jobsUncheckedCreateNestedOneWithoutBookingSlotInput
  }

  export type booking_slotsCreateOrConnectWithoutBookingInput = {
    where: booking_slotsWhereUniqueInput
    create: XOR<booking_slotsCreateWithoutBookingInput, booking_slotsUncheckedCreateWithoutBookingInput>
  }

  export type booking_slotsCreateManyBookingInputEnvelope = {
    data: booking_slotsCreateManyBookingInput | booking_slotsCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutCustomerBookingsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBookings?: bookingsCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsCreateNestedManyWithoutCreatorInput
    payments?: paymentsCreateNestedManyWithoutPayerInput
    roles?: user_rolesCreateNestedManyWithoutUserInput
    vehicles?: vehiclesCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsCreateNestedManyWithoutWasherInput
  }

  export type usersUncheckedCreateWithoutCustomerBookingsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBookings?: bookingsUncheckedCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyUncheckedCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsUncheckedCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesUncheckedCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsUncheckedCreateNestedManyWithoutCreatorInput
    payments?: paymentsUncheckedCreateNestedManyWithoutPayerInput
    roles?: user_rolesUncheckedCreateNestedManyWithoutUserInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsUncheckedCreateNestedManyWithoutWasherInput
  }

  export type usersCreateOrConnectWithoutCustomerBookingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCustomerBookingsInput, usersUncheckedCreateWithoutCustomerBookingsInput>
  }

  export type usersCreateWithoutCreatedBookingsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsCreateNestedManyWithoutCustomerInput
    bookingStatusEvents?: booking_status_historyCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsCreateNestedManyWithoutCreatorInput
    payments?: paymentsCreateNestedManyWithoutPayerInput
    roles?: user_rolesCreateNestedManyWithoutUserInput
    vehicles?: vehiclesCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsCreateNestedManyWithoutWasherInput
  }

  export type usersUncheckedCreateWithoutCreatedBookingsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsUncheckedCreateNestedManyWithoutCustomerInput
    bookingStatusEvents?: booking_status_historyUncheckedCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsUncheckedCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesUncheckedCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsUncheckedCreateNestedManyWithoutCreatorInput
    payments?: paymentsUncheckedCreateNestedManyWithoutPayerInput
    roles?: user_rolesUncheckedCreateNestedManyWithoutUserInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsUncheckedCreateNestedManyWithoutWasherInput
  }

  export type usersCreateOrConnectWithoutCreatedBookingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCreatedBookingsInput, usersUncheckedCreateWithoutCreatedBookingsInput>
  }

  export type counter_transactionsCreateWithoutBookingInput = {
    id?: string
    action: string
    note?: string | null
    createdAt?: Date | string
    counterUser: usersCreateNestedOneWithoutCounterTransactionsInput
  }

  export type counter_transactionsUncheckedCreateWithoutBookingInput = {
    id?: string
    counterUserId: string
    action: string
    note?: string | null
    createdAt?: Date | string
  }

  export type counter_transactionsCreateOrConnectWithoutBookingInput = {
    where: counter_transactionsWhereUniqueInput
    create: XOR<counter_transactionsCreateWithoutBookingInput, counter_transactionsUncheckedCreateWithoutBookingInput>
  }

  export type counter_transactionsCreateManyBookingInputEnvelope = {
    data: counter_transactionsCreateManyBookingInput | counter_transactionsCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type payment_summaryCreateWithoutBookingInput = {
    totalAmount?: Decimal | DecimalJsLike | number | string
    onlinePaid?: Decimal | DecimalJsLike | number | string
    cashPaid?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    updatedAt?: Date | string
  }

  export type payment_summaryUncheckedCreateWithoutBookingInput = {
    totalAmount?: Decimal | DecimalJsLike | number | string
    onlinePaid?: Decimal | DecimalJsLike | number | string
    cashPaid?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    updatedAt?: Date | string
  }

  export type payment_summaryCreateOrConnectWithoutBookingInput = {
    where: payment_summaryWhereUniqueInput
    create: XOR<payment_summaryCreateWithoutBookingInput, payment_summaryUncheckedCreateWithoutBookingInput>
  }

  export type paymentsCreateWithoutBookingInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayStatus?: $Enums.GatewayStatus
    gatewayProvider?: string | null
    transactionId?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    creator?: usersCreateNestedOneWithoutCreatedPaymentsInput
    payer: usersCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutBookingInput = {
    id?: string
    payerId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayStatus?: $Enums.GatewayStatus
    gatewayProvider?: string | null
    transactionId?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    paidAt?: Date | string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type paymentsCreateOrConnectWithoutBookingInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutBookingInput, paymentsUncheckedCreateWithoutBookingInput>
  }

  export type paymentsCreateManyBookingInputEnvelope = {
    data: paymentsCreateManyBookingInput | paymentsCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type propertiesCreateWithoutBookingsInput = {
    id?: string
    propertyName: string
    address: string
    pricePerHour?: Decimal | DecimalJsLike | number | string
    pricePerDay?: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PropertyStatus
    totalSlots?: number
    totalNormalSlots?: number
    totalEvSlots?: number
    totalCarWashSlots?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: usersCreateNestedOneWithoutOwnedPropertiesInput
    parkingSlots?: parking_slotsCreateNestedManyWithoutPropertyInput
  }

  export type propertiesUncheckedCreateWithoutBookingsInput = {
    id?: string
    ownerId: string
    propertyName: string
    address: string
    pricePerHour?: Decimal | DecimalJsLike | number | string
    pricePerDay?: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PropertyStatus
    totalSlots?: number
    totalNormalSlots?: number
    totalEvSlots?: number
    totalCarWashSlots?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parkingSlots?: parking_slotsUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type propertiesCreateOrConnectWithoutBookingsInput = {
    where: propertiesWhereUniqueInput
    create: XOR<propertiesCreateWithoutBookingsInput, propertiesUncheckedCreateWithoutBookingsInput>
  }

  export type booking_status_historyCreateWithoutBookingInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    note?: string | null
    changedAt?: Date | string
    changer?: usersCreateNestedOneWithoutBookingStatusEventsInput
  }

  export type booking_status_historyUncheckedCreateWithoutBookingInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    changedBy?: string | null
    note?: string | null
    changedAt?: Date | string
  }

  export type booking_status_historyCreateOrConnectWithoutBookingInput = {
    where: booking_status_historyWhereUniqueInput
    create: XOR<booking_status_historyCreateWithoutBookingInput, booking_status_historyUncheckedCreateWithoutBookingInput>
  }

  export type booking_status_historyCreateManyBookingInputEnvelope = {
    data: booking_status_historyCreateManyBookingInput | booking_status_historyCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type vehiclesCreateWithoutBookingsInput = {
    id?: string
    vehicleNumber: string
    type?: string | null
    model?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutVehiclesInput
  }

  export type vehiclesUncheckedCreateWithoutBookingsInput = {
    id?: string
    userId: string
    vehicleNumber: string
    type?: string | null
    model?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehiclesCreateOrConnectWithoutBookingsInput = {
    where: vehiclesWhereUniqueInput
    create: XOR<vehiclesCreateWithoutBookingsInput, vehiclesUncheckedCreateWithoutBookingsInput>
  }

  export type booking_slotsUpsertWithWhereUniqueWithoutBookingInput = {
    where: booking_slotsWhereUniqueInput
    update: XOR<booking_slotsUpdateWithoutBookingInput, booking_slotsUncheckedUpdateWithoutBookingInput>
    create: XOR<booking_slotsCreateWithoutBookingInput, booking_slotsUncheckedCreateWithoutBookingInput>
  }

  export type booking_slotsUpdateWithWhereUniqueWithoutBookingInput = {
    where: booking_slotsWhereUniqueInput
    data: XOR<booking_slotsUpdateWithoutBookingInput, booking_slotsUncheckedUpdateWithoutBookingInput>
  }

  export type booking_slotsUpdateManyWithWhereWithoutBookingInput = {
    where: booking_slotsScalarWhereInput
    data: XOR<booking_slotsUpdateManyMutationInput, booking_slotsUncheckedUpdateManyWithoutBookingInput>
  }

  export type usersUpsertWithoutCustomerBookingsInput = {
    update: XOR<usersUpdateWithoutCustomerBookingsInput, usersUncheckedUpdateWithoutCustomerBookingsInput>
    create: XOR<usersCreateWithoutCustomerBookingsInput, usersUncheckedCreateWithoutCustomerBookingsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCustomerBookingsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCustomerBookingsInput, usersUncheckedUpdateWithoutCustomerBookingsInput>
  }

  export type usersUpdateWithoutCustomerBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBookings?: bookingsUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUpdateManyWithoutWasherNestedInput
  }

  export type usersUncheckedUpdateWithoutCustomerBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBookings?: bookingsUncheckedUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUncheckedUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUncheckedUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUncheckedUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUncheckedUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUncheckedUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUncheckedUpdateManyWithoutWasherNestedInput
  }

  export type usersUpsertWithoutCreatedBookingsInput = {
    update: XOR<usersUpdateWithoutCreatedBookingsInput, usersUncheckedUpdateWithoutCreatedBookingsInput>
    create: XOR<usersCreateWithoutCreatedBookingsInput, usersUncheckedCreateWithoutCreatedBookingsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCreatedBookingsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCreatedBookingsInput, usersUncheckedUpdateWithoutCreatedBookingsInput>
  }

  export type usersUpdateWithoutCreatedBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUpdateManyWithoutCustomerNestedInput
    bookingStatusEvents?: booking_status_historyUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUpdateManyWithoutWasherNestedInput
  }

  export type usersUncheckedUpdateWithoutCreatedBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    bookingStatusEvents?: booking_status_historyUncheckedUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUncheckedUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUncheckedUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUncheckedUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUncheckedUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUncheckedUpdateManyWithoutWasherNestedInput
  }

  export type counter_transactionsUpsertWithWhereUniqueWithoutBookingInput = {
    where: counter_transactionsWhereUniqueInput
    update: XOR<counter_transactionsUpdateWithoutBookingInput, counter_transactionsUncheckedUpdateWithoutBookingInput>
    create: XOR<counter_transactionsCreateWithoutBookingInput, counter_transactionsUncheckedCreateWithoutBookingInput>
  }

  export type counter_transactionsUpdateWithWhereUniqueWithoutBookingInput = {
    where: counter_transactionsWhereUniqueInput
    data: XOR<counter_transactionsUpdateWithoutBookingInput, counter_transactionsUncheckedUpdateWithoutBookingInput>
  }

  export type counter_transactionsUpdateManyWithWhereWithoutBookingInput = {
    where: counter_transactionsScalarWhereInput
    data: XOR<counter_transactionsUpdateManyMutationInput, counter_transactionsUncheckedUpdateManyWithoutBookingInput>
  }

  export type payment_summaryUpsertWithoutBookingInput = {
    update: XOR<payment_summaryUpdateWithoutBookingInput, payment_summaryUncheckedUpdateWithoutBookingInput>
    create: XOR<payment_summaryCreateWithoutBookingInput, payment_summaryUncheckedCreateWithoutBookingInput>
    where?: payment_summaryWhereInput
  }

  export type payment_summaryUpdateToOneWithWhereWithoutBookingInput = {
    where?: payment_summaryWhereInput
    data: XOR<payment_summaryUpdateWithoutBookingInput, payment_summaryUncheckedUpdateWithoutBookingInput>
  }

  export type payment_summaryUpdateWithoutBookingInput = {
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onlinePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_summaryUncheckedUpdateWithoutBookingInput = {
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onlinePaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cashPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUpsertWithWhereUniqueWithoutBookingInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutBookingInput, paymentsUncheckedUpdateWithoutBookingInput>
    create: XOR<paymentsCreateWithoutBookingInput, paymentsUncheckedCreateWithoutBookingInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutBookingInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutBookingInput, paymentsUncheckedUpdateWithoutBookingInput>
  }

  export type paymentsUpdateManyWithWhereWithoutBookingInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutBookingInput>
  }

  export type propertiesUpsertWithoutBookingsInput = {
    update: XOR<propertiesUpdateWithoutBookingsInput, propertiesUncheckedUpdateWithoutBookingsInput>
    create: XOR<propertiesCreateWithoutBookingsInput, propertiesUncheckedCreateWithoutBookingsInput>
    where?: propertiesWhereInput
  }

  export type propertiesUpdateToOneWithWhereWithoutBookingsInput = {
    where?: propertiesWhereInput
    data: XOR<propertiesUpdateWithoutBookingsInput, propertiesUncheckedUpdateWithoutBookingsInput>
  }

  export type propertiesUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    totalSlots?: IntFieldUpdateOperationsInput | number
    totalNormalSlots?: IntFieldUpdateOperationsInput | number
    totalEvSlots?: IntFieldUpdateOperationsInput | number
    totalCarWashSlots?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: usersUpdateOneRequiredWithoutOwnedPropertiesNestedInput
    parkingSlots?: parking_slotsUpdateManyWithoutPropertyNestedInput
  }

  export type propertiesUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    totalSlots?: IntFieldUpdateOperationsInput | number
    totalNormalSlots?: IntFieldUpdateOperationsInput | number
    totalEvSlots?: IntFieldUpdateOperationsInput | number
    totalCarWashSlots?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parkingSlots?: parking_slotsUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type booking_status_historyUpsertWithWhereUniqueWithoutBookingInput = {
    where: booking_status_historyWhereUniqueInput
    update: XOR<booking_status_historyUpdateWithoutBookingInput, booking_status_historyUncheckedUpdateWithoutBookingInput>
    create: XOR<booking_status_historyCreateWithoutBookingInput, booking_status_historyUncheckedCreateWithoutBookingInput>
  }

  export type booking_status_historyUpdateWithWhereUniqueWithoutBookingInput = {
    where: booking_status_historyWhereUniqueInput
    data: XOR<booking_status_historyUpdateWithoutBookingInput, booking_status_historyUncheckedUpdateWithoutBookingInput>
  }

  export type booking_status_historyUpdateManyWithWhereWithoutBookingInput = {
    where: booking_status_historyScalarWhereInput
    data: XOR<booking_status_historyUpdateManyMutationInput, booking_status_historyUncheckedUpdateManyWithoutBookingInput>
  }

  export type vehiclesUpsertWithoutBookingsInput = {
    update: XOR<vehiclesUpdateWithoutBookingsInput, vehiclesUncheckedUpdateWithoutBookingsInput>
    create: XOR<vehiclesCreateWithoutBookingsInput, vehiclesUncheckedCreateWithoutBookingsInput>
    where?: vehiclesWhereInput
  }

  export type vehiclesUpdateToOneWithWhereWithoutBookingsInput = {
    where?: vehiclesWhereInput
    data: XOR<vehiclesUpdateWithoutBookingsInput, vehiclesUncheckedUpdateWithoutBookingsInput>
  }

  export type vehiclesUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutVehiclesNestedInput
  }

  export type vehiclesUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookingsCreateWithoutBookingSlotsInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: usersCreateNestedOneWithoutCustomerBookingsInput
    creator?: usersCreateNestedOneWithoutCreatedBookingsInput
    counterLogs?: counter_transactionsCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryCreateNestedOneWithoutBookingInput
    payments?: paymentsCreateNestedManyWithoutBookingInput
    property: propertiesCreateNestedOneWithoutBookingsInput
    statusHistory?: booking_status_historyCreateNestedManyWithoutBookingInput
    vehicle?: vehiclesCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutBookingSlotsInput = {
    id?: string
    customerId: string
    propertyId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    counterLogs?: counter_transactionsUncheckedCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryUncheckedCreateNestedOneWithoutBookingInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingInput
    statusHistory?: booking_status_historyUncheckedCreateNestedManyWithoutBookingInput
  }

  export type bookingsCreateOrConnectWithoutBookingSlotsInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutBookingSlotsInput, bookingsUncheckedCreateWithoutBookingSlotsInput>
  }

  export type parking_slotsCreateWithoutBookingSlotsInput = {
    id?: string
    slotNumber: string
    slotType: $Enums.SlotType
    isActive?: boolean
    createdAt?: Date | string
    property: propertiesCreateNestedOneWithoutParkingSlotsInput
  }

  export type parking_slotsUncheckedCreateWithoutBookingSlotsInput = {
    id?: string
    propertyId: string
    slotNumber: string
    slotType: $Enums.SlotType
    isActive?: boolean
    createdAt?: Date | string
  }

  export type parking_slotsCreateOrConnectWithoutBookingSlotsInput = {
    where: parking_slotsWhereUniqueInput
    create: XOR<parking_slotsCreateWithoutBookingSlotsInput, parking_slotsUncheckedCreateWithoutBookingSlotsInput>
  }

  export type wash_jobsCreateWithoutBookingSlotInput = {
    id?: string
    status?: $Enums.WashStatus
    acceptedAt?: Date | string | null
    completedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    washer?: usersCreateNestedOneWithoutWashJobsInput
  }

  export type wash_jobsUncheckedCreateWithoutBookingSlotInput = {
    id?: string
    washerId?: string | null
    status?: $Enums.WashStatus
    acceptedAt?: Date | string | null
    completedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type wash_jobsCreateOrConnectWithoutBookingSlotInput = {
    where: wash_jobsWhereUniqueInput
    create: XOR<wash_jobsCreateWithoutBookingSlotInput, wash_jobsUncheckedCreateWithoutBookingSlotInput>
  }

  export type bookingsUpsertWithoutBookingSlotsInput = {
    update: XOR<bookingsUpdateWithoutBookingSlotsInput, bookingsUncheckedUpdateWithoutBookingSlotsInput>
    create: XOR<bookingsCreateWithoutBookingSlotsInput, bookingsUncheckedCreateWithoutBookingSlotsInput>
    where?: bookingsWhereInput
  }

  export type bookingsUpdateToOneWithWhereWithoutBookingSlotsInput = {
    where?: bookingsWhereInput
    data: XOR<bookingsUpdateWithoutBookingSlotsInput, bookingsUncheckedUpdateWithoutBookingSlotsInput>
  }

  export type bookingsUpdateWithoutBookingSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: usersUpdateOneRequiredWithoutCustomerBookingsNestedInput
    creator?: usersUpdateOneWithoutCreatedBookingsNestedInput
    counterLogs?: counter_transactionsUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUpdateOneWithoutBookingNestedInput
    payments?: paymentsUpdateManyWithoutBookingNestedInput
    property?: propertiesUpdateOneRequiredWithoutBookingsNestedInput
    statusHistory?: booking_status_historyUpdateManyWithoutBookingNestedInput
    vehicle?: vehiclesUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutBookingSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counterLogs?: counter_transactionsUncheckedUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUncheckedUpdateOneWithoutBookingNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingNestedInput
    statusHistory?: booking_status_historyUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type parking_slotsUpsertWithoutBookingSlotsInput = {
    update: XOR<parking_slotsUpdateWithoutBookingSlotsInput, parking_slotsUncheckedUpdateWithoutBookingSlotsInput>
    create: XOR<parking_slotsCreateWithoutBookingSlotsInput, parking_slotsUncheckedCreateWithoutBookingSlotsInput>
    where?: parking_slotsWhereInput
  }

  export type parking_slotsUpdateToOneWithWhereWithoutBookingSlotsInput = {
    where?: parking_slotsWhereInput
    data: XOR<parking_slotsUpdateWithoutBookingSlotsInput, parking_slotsUncheckedUpdateWithoutBookingSlotsInput>
  }

  export type parking_slotsUpdateWithoutBookingSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: propertiesUpdateOneRequiredWithoutParkingSlotsNestedInput
  }

  export type parking_slotsUncheckedUpdateWithoutBookingSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wash_jobsUpsertWithoutBookingSlotInput = {
    update: XOR<wash_jobsUpdateWithoutBookingSlotInput, wash_jobsUncheckedUpdateWithoutBookingSlotInput>
    create: XOR<wash_jobsCreateWithoutBookingSlotInput, wash_jobsUncheckedCreateWithoutBookingSlotInput>
    where?: wash_jobsWhereInput
  }

  export type wash_jobsUpdateToOneWithWhereWithoutBookingSlotInput = {
    where?: wash_jobsWhereInput
    data: XOR<wash_jobsUpdateWithoutBookingSlotInput, wash_jobsUncheckedUpdateWithoutBookingSlotInput>
  }

  export type wash_jobsUpdateWithoutBookingSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWashStatusFieldUpdateOperationsInput | $Enums.WashStatus
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    washer?: usersUpdateOneWithoutWashJobsNestedInput
  }

  export type wash_jobsUncheckedUpdateWithoutBookingSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    washerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWashStatusFieldUpdateOperationsInput | $Enums.WashStatus
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookingsCreateWithoutStatusHistoryInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsCreateNestedManyWithoutBookingInput
    customer: usersCreateNestedOneWithoutCustomerBookingsInput
    creator?: usersCreateNestedOneWithoutCreatedBookingsInput
    counterLogs?: counter_transactionsCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryCreateNestedOneWithoutBookingInput
    payments?: paymentsCreateNestedManyWithoutBookingInput
    property: propertiesCreateNestedOneWithoutBookingsInput
    vehicle?: vehiclesCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutStatusHistoryInput = {
    id?: string
    customerId: string
    propertyId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsUncheckedCreateNestedManyWithoutBookingInput
    counterLogs?: counter_transactionsUncheckedCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryUncheckedCreateNestedOneWithoutBookingInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingInput
  }

  export type bookingsCreateOrConnectWithoutStatusHistoryInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutStatusHistoryInput, bookingsUncheckedCreateWithoutStatusHistoryInput>
  }

  export type usersCreateWithoutBookingStatusEventsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsCreateNestedManyWithoutCreatorInput
    counterTransactions?: counter_transactionsCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsCreateNestedManyWithoutCreatorInput
    payments?: paymentsCreateNestedManyWithoutPayerInput
    roles?: user_rolesCreateNestedManyWithoutUserInput
    vehicles?: vehiclesCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsCreateNestedManyWithoutWasherInput
  }

  export type usersUncheckedCreateWithoutBookingStatusEventsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsUncheckedCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsUncheckedCreateNestedManyWithoutCreatorInput
    counterTransactions?: counter_transactionsUncheckedCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesUncheckedCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsUncheckedCreateNestedManyWithoutCreatorInput
    payments?: paymentsUncheckedCreateNestedManyWithoutPayerInput
    roles?: user_rolesUncheckedCreateNestedManyWithoutUserInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsUncheckedCreateNestedManyWithoutWasherInput
  }

  export type usersCreateOrConnectWithoutBookingStatusEventsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBookingStatusEventsInput, usersUncheckedCreateWithoutBookingStatusEventsInput>
  }

  export type bookingsUpsertWithoutStatusHistoryInput = {
    update: XOR<bookingsUpdateWithoutStatusHistoryInput, bookingsUncheckedUpdateWithoutStatusHistoryInput>
    create: XOR<bookingsCreateWithoutStatusHistoryInput, bookingsUncheckedCreateWithoutStatusHistoryInput>
    where?: bookingsWhereInput
  }

  export type bookingsUpdateToOneWithWhereWithoutStatusHistoryInput = {
    where?: bookingsWhereInput
    data: XOR<bookingsUpdateWithoutStatusHistoryInput, bookingsUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type bookingsUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUpdateManyWithoutBookingNestedInput
    customer?: usersUpdateOneRequiredWithoutCustomerBookingsNestedInput
    creator?: usersUpdateOneWithoutCreatedBookingsNestedInput
    counterLogs?: counter_transactionsUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUpdateOneWithoutBookingNestedInput
    payments?: paymentsUpdateManyWithoutBookingNestedInput
    property?: propertiesUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: vehiclesUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUncheckedUpdateManyWithoutBookingNestedInput
    counterLogs?: counter_transactionsUncheckedUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUncheckedUpdateOneWithoutBookingNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type usersUpsertWithoutBookingStatusEventsInput = {
    update: XOR<usersUpdateWithoutBookingStatusEventsInput, usersUncheckedUpdateWithoutBookingStatusEventsInput>
    create: XOR<usersCreateWithoutBookingStatusEventsInput, usersUncheckedCreateWithoutBookingStatusEventsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutBookingStatusEventsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutBookingStatusEventsInput, usersUncheckedUpdateWithoutBookingStatusEventsInput>
  }

  export type usersUpdateWithoutBookingStatusEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUpdateManyWithoutCreatorNestedInput
    counterTransactions?: counter_transactionsUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUpdateManyWithoutWasherNestedInput
  }

  export type usersUncheckedUpdateWithoutBookingStatusEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUncheckedUpdateManyWithoutCreatorNestedInput
    counterTransactions?: counter_transactionsUncheckedUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUncheckedUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUncheckedUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUncheckedUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUncheckedUpdateManyWithoutWasherNestedInput
  }

  export type bookingsCreateWithoutPaymentSummaryInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsCreateNestedManyWithoutBookingInput
    customer: usersCreateNestedOneWithoutCustomerBookingsInput
    creator?: usersCreateNestedOneWithoutCreatedBookingsInput
    counterLogs?: counter_transactionsCreateNestedManyWithoutBookingInput
    payments?: paymentsCreateNestedManyWithoutBookingInput
    property: propertiesCreateNestedOneWithoutBookingsInput
    statusHistory?: booking_status_historyCreateNestedManyWithoutBookingInput
    vehicle?: vehiclesCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutPaymentSummaryInput = {
    id?: string
    customerId: string
    propertyId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsUncheckedCreateNestedManyWithoutBookingInput
    counterLogs?: counter_transactionsUncheckedCreateNestedManyWithoutBookingInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingInput
    statusHistory?: booking_status_historyUncheckedCreateNestedManyWithoutBookingInput
  }

  export type bookingsCreateOrConnectWithoutPaymentSummaryInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutPaymentSummaryInput, bookingsUncheckedCreateWithoutPaymentSummaryInput>
  }

  export type bookingsUpsertWithoutPaymentSummaryInput = {
    update: XOR<bookingsUpdateWithoutPaymentSummaryInput, bookingsUncheckedUpdateWithoutPaymentSummaryInput>
    create: XOR<bookingsCreateWithoutPaymentSummaryInput, bookingsUncheckedCreateWithoutPaymentSummaryInput>
    where?: bookingsWhereInput
  }

  export type bookingsUpdateToOneWithWhereWithoutPaymentSummaryInput = {
    where?: bookingsWhereInput
    data: XOR<bookingsUpdateWithoutPaymentSummaryInput, bookingsUncheckedUpdateWithoutPaymentSummaryInput>
  }

  export type bookingsUpdateWithoutPaymentSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUpdateManyWithoutBookingNestedInput
    customer?: usersUpdateOneRequiredWithoutCustomerBookingsNestedInput
    creator?: usersUpdateOneWithoutCreatedBookingsNestedInput
    counterLogs?: counter_transactionsUpdateManyWithoutBookingNestedInput
    payments?: paymentsUpdateManyWithoutBookingNestedInput
    property?: propertiesUpdateOneRequiredWithoutBookingsNestedInput
    statusHistory?: booking_status_historyUpdateManyWithoutBookingNestedInput
    vehicle?: vehiclesUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutPaymentSummaryInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUncheckedUpdateManyWithoutBookingNestedInput
    counterLogs?: counter_transactionsUncheckedUpdateManyWithoutBookingNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingNestedInput
    statusHistory?: booking_status_historyUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type bookingsCreateWithoutPaymentsInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsCreateNestedManyWithoutBookingInput
    customer: usersCreateNestedOneWithoutCustomerBookingsInput
    creator?: usersCreateNestedOneWithoutCreatedBookingsInput
    counterLogs?: counter_transactionsCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryCreateNestedOneWithoutBookingInput
    property: propertiesCreateNestedOneWithoutBookingsInput
    statusHistory?: booking_status_historyCreateNestedManyWithoutBookingInput
    vehicle?: vehiclesCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutPaymentsInput = {
    id?: string
    customerId: string
    propertyId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsUncheckedCreateNestedManyWithoutBookingInput
    counterLogs?: counter_transactionsUncheckedCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryUncheckedCreateNestedOneWithoutBookingInput
    statusHistory?: booking_status_historyUncheckedCreateNestedManyWithoutBookingInput
  }

  export type bookingsCreateOrConnectWithoutPaymentsInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutPaymentsInput, bookingsUncheckedCreateWithoutPaymentsInput>
  }

  export type usersCreateWithoutCreatedPaymentsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesCreateNestedManyWithoutOwnerInput
    payments?: paymentsCreateNestedManyWithoutPayerInput
    roles?: user_rolesCreateNestedManyWithoutUserInput
    vehicles?: vehiclesCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsCreateNestedManyWithoutWasherInput
  }

  export type usersUncheckedCreateWithoutCreatedPaymentsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsUncheckedCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsUncheckedCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyUncheckedCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsUncheckedCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesUncheckedCreateNestedManyWithoutOwnerInput
    payments?: paymentsUncheckedCreateNestedManyWithoutPayerInput
    roles?: user_rolesUncheckedCreateNestedManyWithoutUserInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsUncheckedCreateNestedManyWithoutWasherInput
  }

  export type usersCreateOrConnectWithoutCreatedPaymentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCreatedPaymentsInput, usersUncheckedCreateWithoutCreatedPaymentsInput>
  }

  export type usersCreateWithoutPaymentsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsCreateNestedManyWithoutCreatorInput
    roles?: user_rolesCreateNestedManyWithoutUserInput
    vehicles?: vehiclesCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsCreateNestedManyWithoutWasherInput
  }

  export type usersUncheckedCreateWithoutPaymentsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsUncheckedCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsUncheckedCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyUncheckedCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsUncheckedCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesUncheckedCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsUncheckedCreateNestedManyWithoutCreatorInput
    roles?: user_rolesUncheckedCreateNestedManyWithoutUserInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsUncheckedCreateNestedManyWithoutWasherInput
  }

  export type usersCreateOrConnectWithoutPaymentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
  }

  export type bookingsUpsertWithoutPaymentsInput = {
    update: XOR<bookingsUpdateWithoutPaymentsInput, bookingsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<bookingsCreateWithoutPaymentsInput, bookingsUncheckedCreateWithoutPaymentsInput>
    where?: bookingsWhereInput
  }

  export type bookingsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: bookingsWhereInput
    data: XOR<bookingsUpdateWithoutPaymentsInput, bookingsUncheckedUpdateWithoutPaymentsInput>
  }

  export type bookingsUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUpdateManyWithoutBookingNestedInput
    customer?: usersUpdateOneRequiredWithoutCustomerBookingsNestedInput
    creator?: usersUpdateOneWithoutCreatedBookingsNestedInput
    counterLogs?: counter_transactionsUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUpdateOneWithoutBookingNestedInput
    property?: propertiesUpdateOneRequiredWithoutBookingsNestedInput
    statusHistory?: booking_status_historyUpdateManyWithoutBookingNestedInput
    vehicle?: vehiclesUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUncheckedUpdateManyWithoutBookingNestedInput
    counterLogs?: counter_transactionsUncheckedUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUncheckedUpdateOneWithoutBookingNestedInput
    statusHistory?: booking_status_historyUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type usersUpsertWithoutCreatedPaymentsInput = {
    update: XOR<usersUpdateWithoutCreatedPaymentsInput, usersUncheckedUpdateWithoutCreatedPaymentsInput>
    create: XOR<usersCreateWithoutCreatedPaymentsInput, usersUncheckedCreateWithoutCreatedPaymentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCreatedPaymentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCreatedPaymentsInput, usersUncheckedUpdateWithoutCreatedPaymentsInput>
  }

  export type usersUpdateWithoutCreatedPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUpdateManyWithoutOwnerNestedInput
    payments?: paymentsUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUpdateManyWithoutWasherNestedInput
  }

  export type usersUncheckedUpdateWithoutCreatedPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUncheckedUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUncheckedUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUncheckedUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUncheckedUpdateManyWithoutOwnerNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUncheckedUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUncheckedUpdateManyWithoutWasherNestedInput
  }

  export type usersUpsertWithoutPaymentsInput = {
    update: XOR<usersUpdateWithoutPaymentsInput, usersUncheckedUpdateWithoutPaymentsInput>
    create: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPaymentsInput, usersUncheckedUpdateWithoutPaymentsInput>
  }

  export type usersUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUpdateManyWithoutCreatorNestedInput
    roles?: user_rolesUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUpdateManyWithoutWasherNestedInput
  }

  export type usersUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUncheckedUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUncheckedUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUncheckedUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUncheckedUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUncheckedUpdateManyWithoutCreatorNestedInput
    roles?: user_rolesUncheckedUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUncheckedUpdateManyWithoutWasherNestedInput
  }

  export type booking_slotsCreateWithoutWashJobInput = {
    id?: string
    createdAt?: Date | string
    booking: bookingsCreateNestedOneWithoutBookingSlotsInput
    slot: parking_slotsCreateNestedOneWithoutBookingSlotsInput
  }

  export type booking_slotsUncheckedCreateWithoutWashJobInput = {
    id?: string
    bookingId: string
    slotId: string
    createdAt?: Date | string
  }

  export type booking_slotsCreateOrConnectWithoutWashJobInput = {
    where: booking_slotsWhereUniqueInput
    create: XOR<booking_slotsCreateWithoutWashJobInput, booking_slotsUncheckedCreateWithoutWashJobInput>
  }

  export type usersCreateWithoutWashJobsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsCreateNestedManyWithoutCreatorInput
    payments?: paymentsCreateNestedManyWithoutPayerInput
    roles?: user_rolesCreateNestedManyWithoutUserInput
    vehicles?: vehiclesCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutWashJobsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsUncheckedCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsUncheckedCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyUncheckedCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsUncheckedCreateNestedManyWithoutCounterUserInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesUncheckedCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsUncheckedCreateNestedManyWithoutCreatorInput
    payments?: paymentsUncheckedCreateNestedManyWithoutPayerInput
    roles?: user_rolesUncheckedCreateNestedManyWithoutUserInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutWashJobsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWashJobsInput, usersUncheckedCreateWithoutWashJobsInput>
  }

  export type booking_slotsUpsertWithoutWashJobInput = {
    update: XOR<booking_slotsUpdateWithoutWashJobInput, booking_slotsUncheckedUpdateWithoutWashJobInput>
    create: XOR<booking_slotsCreateWithoutWashJobInput, booking_slotsUncheckedCreateWithoutWashJobInput>
    where?: booking_slotsWhereInput
  }

  export type booking_slotsUpdateToOneWithWhereWithoutWashJobInput = {
    where?: booking_slotsWhereInput
    data: XOR<booking_slotsUpdateWithoutWashJobInput, booking_slotsUncheckedUpdateWithoutWashJobInput>
  }

  export type booking_slotsUpdateWithoutWashJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: bookingsUpdateOneRequiredWithoutBookingSlotsNestedInput
    slot?: parking_slotsUpdateOneRequiredWithoutBookingSlotsNestedInput
  }

  export type booking_slotsUncheckedUpdateWithoutWashJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutWashJobsInput = {
    update: XOR<usersUpdateWithoutWashJobsInput, usersUncheckedUpdateWithoutWashJobsInput>
    create: XOR<usersCreateWithoutWashJobsInput, usersUncheckedCreateWithoutWashJobsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWashJobsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWashJobsInput, usersUncheckedUpdateWithoutWashJobsInput>
  }

  export type usersUpdateWithoutWashJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutWashJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUncheckedUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUncheckedUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUncheckedUpdateManyWithoutCounterUserNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUncheckedUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUncheckedUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUncheckedUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type bookingsCreateWithoutCounterLogsInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsCreateNestedManyWithoutBookingInput
    customer: usersCreateNestedOneWithoutCustomerBookingsInput
    creator?: usersCreateNestedOneWithoutCreatedBookingsInput
    paymentSummary?: payment_summaryCreateNestedOneWithoutBookingInput
    payments?: paymentsCreateNestedManyWithoutBookingInput
    property: propertiesCreateNestedOneWithoutBookingsInput
    statusHistory?: booking_status_historyCreateNestedManyWithoutBookingInput
    vehicle?: vehiclesCreateNestedOneWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutCounterLogsInput = {
    id?: string
    customerId: string
    propertyId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingSlots?: booking_slotsUncheckedCreateNestedManyWithoutBookingInput
    paymentSummary?: payment_summaryUncheckedCreateNestedOneWithoutBookingInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingInput
    statusHistory?: booking_status_historyUncheckedCreateNestedManyWithoutBookingInput
  }

  export type bookingsCreateOrConnectWithoutCounterLogsInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutCounterLogsInput, bookingsUncheckedCreateWithoutCounterLogsInput>
  }

  export type usersCreateWithoutCounterTransactionsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyCreateNestedManyWithoutChangerInput
    notifications?: notificationsCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsCreateNestedManyWithoutCreatorInput
    payments?: paymentsCreateNestedManyWithoutPayerInput
    roles?: user_rolesCreateNestedManyWithoutUserInput
    vehicles?: vehiclesCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsCreateNestedManyWithoutWasherInput
  }

  export type usersUncheckedCreateWithoutCounterTransactionsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsUncheckedCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsUncheckedCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyUncheckedCreateNestedManyWithoutChangerInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUserInput
    ownedProperties?: propertiesUncheckedCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsUncheckedCreateNestedManyWithoutCreatorInput
    payments?: paymentsUncheckedCreateNestedManyWithoutPayerInput
    roles?: user_rolesUncheckedCreateNestedManyWithoutUserInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsUncheckedCreateNestedManyWithoutWasherInput
  }

  export type usersCreateOrConnectWithoutCounterTransactionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCounterTransactionsInput, usersUncheckedCreateWithoutCounterTransactionsInput>
  }

  export type bookingsUpsertWithoutCounterLogsInput = {
    update: XOR<bookingsUpdateWithoutCounterLogsInput, bookingsUncheckedUpdateWithoutCounterLogsInput>
    create: XOR<bookingsCreateWithoutCounterLogsInput, bookingsUncheckedCreateWithoutCounterLogsInput>
    where?: bookingsWhereInput
  }

  export type bookingsUpdateToOneWithWhereWithoutCounterLogsInput = {
    where?: bookingsWhereInput
    data: XOR<bookingsUpdateWithoutCounterLogsInput, bookingsUncheckedUpdateWithoutCounterLogsInput>
  }

  export type bookingsUpdateWithoutCounterLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUpdateManyWithoutBookingNestedInput
    customer?: usersUpdateOneRequiredWithoutCustomerBookingsNestedInput
    creator?: usersUpdateOneWithoutCreatedBookingsNestedInput
    paymentSummary?: payment_summaryUpdateOneWithoutBookingNestedInput
    payments?: paymentsUpdateManyWithoutBookingNestedInput
    property?: propertiesUpdateOneRequiredWithoutBookingsNestedInput
    statusHistory?: booking_status_historyUpdateManyWithoutBookingNestedInput
    vehicle?: vehiclesUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutCounterLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUncheckedUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUncheckedUpdateOneWithoutBookingNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingNestedInput
    statusHistory?: booking_status_historyUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type usersUpsertWithoutCounterTransactionsInput = {
    update: XOR<usersUpdateWithoutCounterTransactionsInput, usersUncheckedUpdateWithoutCounterTransactionsInput>
    create: XOR<usersCreateWithoutCounterTransactionsInput, usersUncheckedCreateWithoutCounterTransactionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCounterTransactionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCounterTransactionsInput, usersUncheckedUpdateWithoutCounterTransactionsInput>
  }

  export type usersUpdateWithoutCounterTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUpdateManyWithoutChangerNestedInput
    notifications?: notificationsUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUpdateManyWithoutWasherNestedInput
  }

  export type usersUncheckedUpdateWithoutCounterTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUncheckedUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUncheckedUpdateManyWithoutChangerNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUserNestedInput
    ownedProperties?: propertiesUncheckedUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUncheckedUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUncheckedUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUncheckedUpdateManyWithoutWasherNestedInput
  }

  export type usersCreateWithoutNotificationsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsCreateNestedManyWithoutCounterUserInput
    ownedProperties?: propertiesCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsCreateNestedManyWithoutCreatorInput
    payments?: paymentsCreateNestedManyWithoutPayerInput
    roles?: user_rolesCreateNestedManyWithoutUserInput
    vehicles?: vehiclesCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsCreateNestedManyWithoutWasherInput
  }

  export type usersUncheckedCreateWithoutNotificationsInput = {
    id?: string
    fullName: string
    email: string
    phone?: string | null
    nic?: string | null
    residentialAddress?: string | null
    passwordHash: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerBookings?: bookingsUncheckedCreateNestedManyWithoutCustomerInput
    createdBookings?: bookingsUncheckedCreateNestedManyWithoutCreatorInput
    bookingStatusEvents?: booking_status_historyUncheckedCreateNestedManyWithoutChangerInput
    counterTransactions?: counter_transactionsUncheckedCreateNestedManyWithoutCounterUserInput
    ownedProperties?: propertiesUncheckedCreateNestedManyWithoutOwnerInput
    createdPayments?: paymentsUncheckedCreateNestedManyWithoutCreatorInput
    payments?: paymentsUncheckedCreateNestedManyWithoutPayerInput
    roles?: user_rolesUncheckedCreateNestedManyWithoutUserInput
    vehicles?: vehiclesUncheckedCreateNestedManyWithoutUserInput
    washJobs?: wash_jobsUncheckedCreateNestedManyWithoutWasherInput
  }

  export type usersCreateOrConnectWithoutNotificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
  }

  export type usersUpsertWithoutNotificationsInput = {
    update: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type usersUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUpdateManyWithoutCounterUserNestedInput
    ownedProperties?: propertiesUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUpdateManyWithoutWasherNestedInput
  }

  export type usersUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    nic?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerBookings?: bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    createdBookings?: bookingsUncheckedUpdateManyWithoutCreatorNestedInput
    bookingStatusEvents?: booking_status_historyUncheckedUpdateManyWithoutChangerNestedInput
    counterTransactions?: counter_transactionsUncheckedUpdateManyWithoutCounterUserNestedInput
    ownedProperties?: propertiesUncheckedUpdateManyWithoutOwnerNestedInput
    createdPayments?: paymentsUncheckedUpdateManyWithoutCreatorNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutPayerNestedInput
    roles?: user_rolesUncheckedUpdateManyWithoutUserNestedInput
    vehicles?: vehiclesUncheckedUpdateManyWithoutUserNestedInput
    washJobs?: wash_jobsUncheckedUpdateManyWithoutWasherNestedInput
  }

  export type bookingsCreateManyCustomerInput = {
    id?: string
    propertyId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type bookingsCreateManyCreatorInput = {
    id?: string
    customerId: string
    propertyId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type booking_status_historyCreateManyChangerInput = {
    id?: string
    bookingId: string
    oldStatus?: string | null
    newStatus: string
    note?: string | null
    changedAt?: Date | string
  }

  export type counter_transactionsCreateManyCounterUserInput = {
    id?: string
    bookingId: string
    action: string
    note?: string | null
    createdAt?: Date | string
  }

  export type notificationsCreateManyUserInput = {
    id?: string
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type propertiesCreateManyOwnerInput = {
    id?: string
    propertyName: string
    address: string
    pricePerHour?: Decimal | DecimalJsLike | number | string
    pricePerDay?: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PropertyStatus
    totalSlots?: number
    totalNormalSlots?: number
    totalEvSlots?: number
    totalCarWashSlots?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type paymentsCreateManyCreatorInput = {
    id?: string
    bookingId: string
    payerId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayStatus?: $Enums.GatewayStatus
    gatewayProvider?: string | null
    transactionId?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    paidAt?: Date | string | null
    createdAt?: Date | string
  }

  export type paymentsCreateManyPayerInput = {
    id?: string
    bookingId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayStatus?: $Enums.GatewayStatus
    gatewayProvider?: string | null
    transactionId?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    paidAt?: Date | string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type user_rolesCreateManyUserInput = {
    roleId: number
  }

  export type vehiclesCreateManyUserInput = {
    id?: string
    vehicleNumber: string
    type?: string | null
    model?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type wash_jobsCreateManyWasherInput = {
    id?: string
    bookingSlotId: string
    status?: $Enums.WashStatus
    acceptedAt?: Date | string | null
    completedAt?: Date | string | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type bookingsUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUpdateManyWithoutBookingNestedInput
    creator?: usersUpdateOneWithoutCreatedBookingsNestedInput
    counterLogs?: counter_transactionsUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUpdateOneWithoutBookingNestedInput
    payments?: paymentsUpdateManyWithoutBookingNestedInput
    property?: propertiesUpdateOneRequiredWithoutBookingsNestedInput
    statusHistory?: booking_status_historyUpdateManyWithoutBookingNestedInput
    vehicle?: vehiclesUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUncheckedUpdateManyWithoutBookingNestedInput
    counterLogs?: counter_transactionsUncheckedUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUncheckedUpdateOneWithoutBookingNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingNestedInput
    statusHistory?: booking_status_historyUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type bookingsUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookingsUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUpdateManyWithoutBookingNestedInput
    customer?: usersUpdateOneRequiredWithoutCustomerBookingsNestedInput
    counterLogs?: counter_transactionsUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUpdateOneWithoutBookingNestedInput
    payments?: paymentsUpdateManyWithoutBookingNestedInput
    property?: propertiesUpdateOneRequiredWithoutBookingsNestedInput
    statusHistory?: booking_status_historyUpdateManyWithoutBookingNestedInput
    vehicle?: vehiclesUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUncheckedUpdateManyWithoutBookingNestedInput
    counterLogs?: counter_transactionsUncheckedUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUncheckedUpdateOneWithoutBookingNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingNestedInput
    statusHistory?: booking_status_historyUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type bookingsUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_status_historyUpdateWithoutChangerInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: bookingsUpdateOneRequiredWithoutStatusHistoryNestedInput
  }

  export type booking_status_historyUncheckedUpdateWithoutChangerInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_status_historyUncheckedUpdateManyWithoutChangerInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type counter_transactionsUpdateWithoutCounterUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: bookingsUpdateOneRequiredWithoutCounterLogsNestedInput
  }

  export type counter_transactionsUncheckedUpdateWithoutCounterUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type counter_transactionsUncheckedUpdateManyWithoutCounterUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type propertiesUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    totalSlots?: IntFieldUpdateOperationsInput | number
    totalNormalSlots?: IntFieldUpdateOperationsInput | number
    totalEvSlots?: IntFieldUpdateOperationsInput | number
    totalCarWashSlots?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUpdateManyWithoutPropertyNestedInput
    parkingSlots?: parking_slotsUpdateManyWithoutPropertyNestedInput
  }

  export type propertiesUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    totalSlots?: IntFieldUpdateOperationsInput | number
    totalNormalSlots?: IntFieldUpdateOperationsInput | number
    totalEvSlots?: IntFieldUpdateOperationsInput | number
    totalCarWashSlots?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUncheckedUpdateManyWithoutPropertyNestedInput
    parkingSlots?: parking_slotsUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type propertiesUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pricePerHour?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    totalSlots?: IntFieldUpdateOperationsInput | number
    totalNormalSlots?: IntFieldUpdateOperationsInput | number
    totalEvSlots?: IntFieldUpdateOperationsInput | number
    totalCarWashSlots?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: bookingsUpdateOneRequiredWithoutPaymentsNestedInput
    payer?: usersUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    payerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    payerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUpdateWithoutPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: bookingsUpdateOneRequiredWithoutPaymentsNestedInput
    creator?: usersUpdateOneWithoutCreatedPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUncheckedUpdateManyWithoutPayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_rolesUpdateWithoutUserInput = {
    role?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type user_rolesUncheckedUpdateWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type user_rolesUncheckedUpdateManyWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type vehiclesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUpdateManyWithoutVehicleNestedInput
  }

  export type vehiclesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: bookingsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehiclesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wash_jobsUpdateWithoutWasherInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumWashStatusFieldUpdateOperationsInput | $Enums.WashStatus
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlot?: booking_slotsUpdateOneRequiredWithoutWashJobNestedInput
  }

  export type wash_jobsUncheckedUpdateWithoutWasherInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingSlotId?: StringFieldUpdateOperationsInput | string
    status?: EnumWashStatusFieldUpdateOperationsInput | $Enums.WashStatus
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wash_jobsUncheckedUpdateManyWithoutWasherInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingSlotId?: StringFieldUpdateOperationsInput | string
    status?: EnumWashStatusFieldUpdateOperationsInput | $Enums.WashStatus
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_rolesCreateManyRoleInput = {
    userId: string
  }

  export type user_rolesUpdateWithoutRoleInput = {
    user?: usersUpdateOneRequiredWithoutRolesNestedInput
  }

  export type user_rolesUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type user_rolesUncheckedUpdateManyWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type bookingsCreateManyPropertyInput = {
    id?: string
    customerId: string
    vehicleId?: string | null
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type parking_slotsCreateManyPropertyInput = {
    id?: string
    slotNumber: string
    slotType: $Enums.SlotType
    isActive?: boolean
    createdAt?: Date | string
  }

  export type bookingsUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUpdateManyWithoutBookingNestedInput
    customer?: usersUpdateOneRequiredWithoutCustomerBookingsNestedInput
    creator?: usersUpdateOneWithoutCreatedBookingsNestedInput
    counterLogs?: counter_transactionsUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUpdateOneWithoutBookingNestedInput
    payments?: paymentsUpdateManyWithoutBookingNestedInput
    statusHistory?: booking_status_historyUpdateManyWithoutBookingNestedInput
    vehicle?: vehiclesUpdateOneWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUncheckedUpdateManyWithoutBookingNestedInput
    counterLogs?: counter_transactionsUncheckedUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUncheckedUpdateOneWithoutBookingNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingNestedInput
    statusHistory?: booking_status_historyUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type bookingsUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type parking_slotsUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUpdateManyWithoutSlotNestedInput
  }

  export type parking_slotsUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type parking_slotsUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotNumber?: StringFieldUpdateOperationsInput | string
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_slotsCreateManySlotInput = {
    id?: string
    bookingId: string
    createdAt?: Date | string
  }

  export type booking_slotsUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: bookingsUpdateOneRequiredWithoutBookingSlotsNestedInput
    washJob?: wash_jobsUpdateOneWithoutBookingSlotNestedInput
  }

  export type booking_slotsUncheckedUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    washJob?: wash_jobsUncheckedUpdateOneWithoutBookingSlotNestedInput
  }

  export type booking_slotsUncheckedUpdateManyWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bookingsCreateManyVehicleInput = {
    id?: string
    customerId: string
    propertyId: string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    parkingType?: $Enums.SlotType
    bookingType?: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type bookingsUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUpdateManyWithoutBookingNestedInput
    customer?: usersUpdateOneRequiredWithoutCustomerBookingsNestedInput
    creator?: usersUpdateOneWithoutCreatedBookingsNestedInput
    counterLogs?: counter_transactionsUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUpdateOneWithoutBookingNestedInput
    payments?: paymentsUpdateManyWithoutBookingNestedInput
    property?: propertiesUpdateOneRequiredWithoutBookingsNestedInput
    statusHistory?: booking_status_historyUpdateManyWithoutBookingNestedInput
  }

  export type bookingsUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingSlots?: booking_slotsUncheckedUpdateManyWithoutBookingNestedInput
    counterLogs?: counter_transactionsUncheckedUpdateManyWithoutBookingNestedInput
    paymentSummary?: payment_summaryUncheckedUpdateOneWithoutBookingNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingNestedInput
    statusHistory?: booking_status_historyUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type bookingsUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    parkingType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    bookingType?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_slotsCreateManyBookingInput = {
    id?: string
    slotId: string
    createdAt?: Date | string
  }

  export type counter_transactionsCreateManyBookingInput = {
    id?: string
    counterUserId: string
    action: string
    note?: string | null
    createdAt?: Date | string
  }

  export type paymentsCreateManyBookingInput = {
    id?: string
    payerId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: $Enums.PaymentMethod
    paymentStatus?: $Enums.PaymentStatus
    gatewayStatus?: $Enums.GatewayStatus
    gatewayProvider?: string | null
    transactionId?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    cardExpMonth?: number | null
    cardExpYear?: number | null
    paidAt?: Date | string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type booking_status_historyCreateManyBookingInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    changedBy?: string | null
    note?: string | null
    changedAt?: Date | string
  }

  export type booking_slotsUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: parking_slotsUpdateOneRequiredWithoutBookingSlotsNestedInput
    washJob?: wash_jobsUpdateOneWithoutBookingSlotNestedInput
  }

  export type booking_slotsUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    washJob?: wash_jobsUncheckedUpdateOneWithoutBookingSlotNestedInput
  }

  export type booking_slotsUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type counter_transactionsUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counterUser?: usersUpdateOneRequiredWithoutCounterTransactionsNestedInput
  }

  export type counter_transactionsUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    counterUserId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type counter_transactionsUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    counterUserId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: usersUpdateOneWithoutCreatedPaymentsNestedInput
    payer?: usersUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    payerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    payerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    gatewayStatus?: EnumGatewayStatusFieldUpdateOperationsInput | $Enums.GatewayStatus
    gatewayProvider?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    cardExpMonth?: NullableIntFieldUpdateOperationsInput | number | null
    cardExpYear?: NullableIntFieldUpdateOperationsInput | number | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_status_historyUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changer?: usersUpdateOneWithoutBookingStatusEventsNestedInput
  }

  export type booking_status_historyUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type booking_status_historyUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesCountOutputTypeDefaultArgs instead
     */
    export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PropertiesCountOutputTypeDefaultArgs instead
     */
    export type PropertiesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PropertiesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Parking_slotsCountOutputTypeDefaultArgs instead
     */
    export type Parking_slotsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Parking_slotsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehiclesCountOutputTypeDefaultArgs instead
     */
    export type VehiclesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehiclesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingsCountOutputTypeDefaultArgs instead
     */
    export type BookingsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolesDefaultArgs instead
     */
    export type rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_rolesDefaultArgs instead
     */
    export type user_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_rolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use propertiesDefaultArgs instead
     */
    export type propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = propertiesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use parking_slotsDefaultArgs instead
     */
    export type parking_slotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = parking_slotsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use vehiclesDefaultArgs instead
     */
    export type vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = vehiclesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bookingsDefaultArgs instead
     */
    export type bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bookingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use booking_slotsDefaultArgs instead
     */
    export type booking_slotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = booking_slotsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use booking_status_historyDefaultArgs instead
     */
    export type booking_status_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = booking_status_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use payment_summaryDefaultArgs instead
     */
    export type payment_summaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = payment_summaryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use paymentsDefaultArgs instead
     */
    export type paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = paymentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use wash_jobsDefaultArgs instead
     */
    export type wash_jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = wash_jobsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use counter_transactionsDefaultArgs instead
     */
    export type counter_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = counter_transactionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notificationsDefaultArgs instead
     */
    export type notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notificationsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}